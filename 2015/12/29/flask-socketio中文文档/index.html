<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Hi!Roy!"><title>flask-socketio中文文档 - Hi!Roy!</title><meta name="author" content="Roy"><link rel="icon" href="http://www.hi-roy.com/assets/images/favicon.ico"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><meta name="description" content="官网在这里，英语好的直接去看官网文档吧，我是英语渣只能翻译个大概;另外注意本文翻译时间，可能你看到的时候官网已经更新了。flask-socketio赋予了flask程序支持服务端和客户端间双向低延迟通讯的能力，客户端可以使用 SocketIO 库或任何支持与服务端建立长链接的兼容库。安装可以直接使用pip安装：1pip install flask-socketio依赖自从1.0版开始，这个扩展完全"><meta name="keywords" content="python,flask"><meta property="og:type" content="blog"><meta property="og:title" content="flask-socketio中文文档"><meta property="og:url" content="http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/index.html"><meta property="og:site_name" content="Hi!Roy!"><meta property="og:description" content="官网在这里，英语好的直接去看官网文档吧，我是英语渣只能翻译个大概;另外注意本文翻译时间，可能你看到的时候官网已经更新了。flask-socketio赋予了flask程序支持服务端和客户端间双向低延迟通讯的能力，客户端可以使用 SocketIO 库或任何支持与服务端建立长链接的兼容库。安装可以直接使用pip安装：1pip install flask-socketio依赖自从1.0版开始，这个扩展完全"><meta property="og:locale" content="zh-cn"><meta property="og:updated_time" content="2019-09-16T08:11:51.489Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="flask-socketio中文文档"><meta name="twitter:description" content="官网在这里，英语好的直接去看官网文档吧，我是英语渣只能翻译个大概;另外注意本文翻译时间，可能你看到的时候官网已经更新了。flask-socketio赋予了flask程序支持服务端和客户端间双向低延迟通讯的能力，客户端可以使用 SocketIO 库或任何支持与服务端建立长链接的兼容库。安装可以直接使用pip安装：1pip install flask-socketio依赖自从1.0版开始，这个扩展完全"><meta property="og:image" content="http://www.hi-roy.com/assets/images/my.jpg"><link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?21513ec2bcd577b3297a1b16da82fa40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div id="blog"><header id="header" data-behavior="4"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/">Hi!Roy!</a></div><a class="header-right-icon" href="#about"><i class="fa fa-lg fa-question"></i></a></header><nav id="sidebar" data-behavior="4"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about"><img class="sidebar-profile-picture" src="/assets/images/my.jpg" alt="作者的图片"></a><h4 class="sidebar-profile-name">Roy</h4><h5 class="sidebar-profile-bio"><p>君以国士待我，我必以国士报君。</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/"><i class="sidebar-button-icon fa fa-lg fa-home"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories"><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags"><i class="sidebar-button-icon fa fa-lg fa-tags"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives"><i class="sidebar-button-icon fa fa-lg fa-archive"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link open-algolia-search" href="#search"><i class="sidebar-button-icon fa fa-lg fa-search"></i> <span class="sidebar-button-desc">搜索</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about"><i class="sidebar-button-icon fa fa-lg fa-question"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/shenyushun" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-github"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:darkcooking@gmail.com" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml"><i class="sidebar-button-icon fa fa-lg fa-rss"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div id="main" data-behavior="4" class="hasCoverMetaIn"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><div class="post-header main-content-wrap text-left"><h1 class="post-title" itemprop="headline">flask-socketio中文文档</h1><div class="post-meta"><time itemprop="datePublished" datetime="2015-12-29T16:18:34+08:00">12月 29, 2015 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="post-content markdown" itemprop="articleBody"><div class="main-content-wrap"><p>官网在<a href="https://flask-socketio.readthedocs.org/en/latest/" target="_blank" rel="noopener">这里</a>，英语好的直接去看官网文档吧，我是英语渣只能翻译个大概;另外注意本文翻译时间，可能你看到的时候官网已经更新了。</p><hr><p>flask-socketio赋予了flask程序支持服务端和客户端间双向低延迟通讯的能力，客户端可以使用 <a href="http://socket.io/" target="_blank" rel="noopener">SocketIO</a> 库或任何支持与服务端建立长链接的兼容库。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接使用pip安装：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-socketio</span><br></pre></td></tr></table></figure><p></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>自从1.0版开始，这个扩展完全兼容了python2.7和python3.3+版本。异步服务的支持基于下面3个选择中的一个：</p><ul><li><a href="http://eventlet.net/" target="_blank" rel="noopener">eventlet</a> 是3个选项中性能最高的，同时支持长轮循(long-polling)和WebSocket。</li><li><a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 是在以前版本中使用的框架，支持长轮循，如果想支持WebSocket的话需要同时安装<a href="https://pypi.python.org/pypi/gevent-websocket/" target="_blank" rel="noopener">gevent-websocket</a> 库。使用gevent和gevent-websocket结合性能也不错，但略低于eventlet。</li><li>flask 基于Werkzeug的开发服务也能用，不过性能上不如上面2个选项，所以它应该只用于开发时使用。这个选项只支持长轮循。<br>本扩展将自动检测哪些异步框架被安装，默认首选eventlet，其次是gevent，最后是flask自带的开发服务。<br>对于客户端来说，可以使用官方的Socket.Io来建立于服务端的链接，也有使用swift和c++写成的客户端。非官方的客户端也能工作，只要它实现了<a href="https://github.com/socketio/socket.io-protocol" target="_blank" rel="noopener">Socket.IO</a> 协议。</li></ul><h2 id="目前的局限"><a href="#目前的局限" class="headerlink" title="目前的局限"></a>目前的局限</h2><p>目前flask-socketio只能同时运行在单个进程中（这里应该指的是一个进程中仅能存在一个实例的意思，而非只能开启一个进程吧…），解决这个限制的工作正在进行中。<br>（关于升级变化、以及从老版本迁移到新版的注意事项我就不翻译了，因为没用过老版本）</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>下面的代码展示了如何添加flask-socketio到flask程序中：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> SocketIO</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'secret!'</span></span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    socketio.run(app)</span><br></pre></td></tr></table></figure><p></p><p>init_app()这种初始化方式也支持，注意web服务器的启动方式。socketio.run()封装并替换了app.run()这种flask的标准启动方式。在debug模式中，Werkzeug服务依然被使用并在socketio.run()中进行了正确的配置。在生产环境中将优先使用eventlet或者gevent，如果这2个都没安装的话werkzeug将被使用。</p><p>程序必须为客户端提供一个页面使其能够加载Socket.io库并建立链接：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> socket = io.connect(<span class="string">'http://'</span> + <span class="built_in">document</span>.domain + <span class="string">':'</span> + location.port);</span><br><span class="line">    socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'my event'</span>, &#123;<span class="attr">data</span>: <span class="string">'I\'m connected!'</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>当使用Socketio时，消息以事件的形式被双方接收。客户端使用Javascript的回调函数，服务端需要为事件注册处理函数，就像在视图中注册路由处理函数那样。</p><p>下面的代码展示了如何创建服务端未命名事件处理函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'received message: '</span> + message)</span><br></pre></td></tr></table></figure><p></p><p>上面的例子使用了字符串消息，下面的例子展示如何使用json格式的消息：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json: '</span> + str(json))</span><br></pre></td></tr></table></figure><p></p><p>更灵活的方式是使用自定义的事件名称：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json: '</span> + str(json))</span><br></pre></td></tr></table></figure><p></p><p>命名事件是非常灵活的，这种方式不需要添加额外的数据来描述消息类型（不过截至到翻译这里，没看出自定义名称的好处…待使用后看看吧）</p><p>Flask-SocketIO也支持SocketIO的命名空间，准许客户端在同一个socket上建立多个独立的链接：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event', namespace='/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_namespace_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json: '</span> + str(json))</span><br></pre></td></tr></table></figure><p></p><p>如果没有指定命名空间，默认使用全局默认命名空间“/”。</p><p>客户端也许需要一个回调来确认收到了消息，任何从服务端处理函数返回的值将作为客户端回调函数的参数被传递回客户端：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json: '</span> + str(json))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'one'</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure><p></p><p>上面的例子中，客户端的回调函数将收到2个参数，’one’和2。如果服务端没返回任何值，客户端的回调函数就不会收到任何参数。</p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>正如上面说的，SocketIO事件处理函数可以通过调用send()和emit()函数来向链接的客户端发送回应消息。下面的例子展示了服务端接受客户端的消息并返回给客户端：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> send, emit</span><br><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message)</span><br><span class="line"><span class="meta">@socketio.on('json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    send(json, json=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json)</span><br></pre></td></tr></table></figure><p></p><p>注意send()用于非自定义的事件而emit()用于自定义的事件中。</p><p>当使用命名空间时，send()和emit()默认使用传进来的消息的命名空间，我们也可以使用namespace参数来指定使用哪个命名空间：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message, namespace=<span class="string">'/chat'</span>)</span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json, namespace=<span class="string">'/chat'</span>)</span><br><span class="line"></span><br><span class="line">SocketIO支持确认回调来确认消息被客户端成功接收：</span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'message was received!'</span></span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json, callback=ack)</span><br></pre></td></tr></table></figure><p></p><p>当使用回调的时候Javascript客户端接受一个回调函数来调用接收到的消息，在客户端回调函数执行完成后服务端相应的回调函数将被执行。如果客户端的回调函数返回了任何值，它们将被作为参数传递给服务端的回调函数。</p><p>应用程序的客户端也可以向服务端为一个事件请求确认回调，如果服务端想为这个回调提供参数，仅需要在事件处理函数中返回它们就可以了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="comment"># ... handle the event</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="number">123</span>  <span class="comment"># client callback will receive these 3 arguments</span></span><br></pre></td></tr></table></figure><p></p><p>（关于上面客户端回调、服务端回调以及相关确认回调神码的有些绕，需要从代码层面去理解一下真正的含义）</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>SocketIO中另一个特别有用的特性就是消息广播。Flask-SocketIO通过在send()和emit()函数中设定参数broadcast=True来支持这一特性：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, data, broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p></p><p>当一条消息以广播方式发送时，同命名空间下的所有建立了链接的客户端都将收到这条消息，包括发送者自己。如果没有使用命名空间，所以链接到全局命名空间的客户端都将收到这条消息。注意，回调函数不会被广播消息触发。</p><p>至此，上述所有的示例都在说明服务端如何响应客户端发起的事件请求，但对于某些情况，服务端需要作为消息的发起者。比如服务器需要在后端向所有客户端发送通知的情景中，socketio.send()和socketio.emit()可以用来向所有用户发送广播：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span><span class="params">()</span>:</span></span><br><span class="line">    socketio.emit(<span class="string">'some event'</span>, &#123;<span class="string">'data'</span>: <span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p>这里注意socketio.send()、socketio.emit()和send()、emit()函数并不相同。</p><p>（原文是： <em>Note that socketio.send() and socketio.emit() are not the same functions as the context-aware send() and emit()</em> ，但context-aware翻译成上下文敏感感觉有些怪异）</p><p>同时注意上述例子中并没有客户端卵事，所以默认broadcast=True，不需要额外指定了。</p><h2 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h2><p>在很多程序需要对用户进行分组，并且每个组之间的成员可以相互发送消息。典型的例子就是聊天室程序，用户接受他们进入的房间的消息，而不会收到其它房间发送的消息。Flask-SocketIO通过join_room() 和leave_room()函数来支持这种特性：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> join_room, leave_room</span><br><span class="line"><span class="meta">@socketio.on('join')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_join</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    join_room(room)</span><br><span class="line">    send(username + <span class="string">' has entered the room.'</span>, room=room)</span><br><span class="line"><span class="meta">@socketio.on('leave')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_leave</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    leave_room(room)</span><br><span class="line">    send(username + <span class="string">' has left the room.'</span>, room=room)</span><br></pre></td></tr></table></figure><p></p><p>send()和emit()函数通过指定room参数来确保消息发送给所有在同房间的客户端。</p><p>所有的客户端在建立链接时就被分配了一个房间，并根据链接的session id来命名。这个值可以从request.sid中获得。客户端可以加入任何房间并可以被赋予任何名字。当客户端断开链接时，它将被从所有加入的房间中被移除。与上下文无关的(context-free)socketio.send()、socketio.emit()函数也接受room参数向房间中的所有客户端发送广播。</p><p>每个客户端都被指定了个人房间后，向个人发送消息可以使用客户端的session id作为room的参数。（个人理解就是私聊功能）</p><h2 id="链接事件"><a href="#链接事件" class="headerlink" title="链接事件"></a>链接事件</h2><p>Flask-SocketIO也分离了建立链接和断开链接事件，下面的示例展示了如何为这2个事件注册处理函数：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span><span class="params">()</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'data'</span>: <span class="string">'Connected'</span>&#125;)</span><br><span class="line"><span class="meta">@socketio.on('disconnect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Client disconnected'</span>)</span><br></pre></td></tr></table></figure><p></p><p>connect事件可以选择return False来拒绝链接，这样可以对客户端进行身份认证。</p><p>注意connect和disconnect事件在每个命名空间中被单独发送。</p><h2 id="错误控制"><a href="#错误控制" class="headerlink" title="错误控制"></a>错误控制</h2><p>Flask-SocketIO也可以处理异常：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on_error()        # Handles the default namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@socketio.on_error('/chat') # handles the '/chat' namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler_chat</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@socketio.on_error_default  # handles all namespaces without an explicit error handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><p>错误处理程序接受exception object作为参数。</p><p>当前请求的消息和数据可以通过request.event 来获取，这在记录错误日志和调试程序时候是非常有用的：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="meta">@socketio.on("my error event")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError()</span><br><span class="line"><span class="meta">@socketio.on_error_default</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> request.event[<span class="string">"message"</span>] <span class="comment"># "my error event"</span></span><br><span class="line">    <span class="keyword">print</span> request.event[<span class="string">"args"</span>]    <span class="comment"># (data,)</span></span><br></pre></td></tr></table></figure><p></p><h2 id="访问Flask全局上下文"><a href="#访问Flask全局上下文" class="headerlink" title="访问Flask全局上下文"></a>访问Flask全局上下文</h2><p>SocketIO事件处理函数和路由处理函数是不同的，这些不同使人们在SocketIO事件处理函数中什么可以做、什么不可以做感到很困惑。最主要的区别在于：所有为客户端SocketIO而编写的事件处理函数都发生在单一的长时间请求上下文中。</p><p>尽管有差异，Flask-SocketIO尝试通过使环境类似一个普通的HTTP请求来简化SocketIO的事件处理函数。下面的列表说明了什么可以做和什么不可以做：</p><ol><li>应用程序上下文(application context)在事件处理函数被调用前载入，所以current_app 和 g可以在处理函数中使用</li><li>请求上下文(request context)在事件处理函数被调用前载入，所以request和session可以在处理函数中使用。但注意，在WebSocket事件中并不和单个请求关联，所以请求上下文在链接建立时被所有事件都载入了并在整个请求的生命周期中都存在。</li><li>全局请求上下文( request context global)通过增加sid来支持为链接设置独一无二的session id。这个值在第一个用户进入房间是被使用。</li><li>全局请求上下文( request context global)通过增加 namespace和event来记录当前事件处理函数的命名空间和事件参数。event是一个用message和args当作key的字典。</li><li>全局会话上下文(session context global)的行为和常规的不同，在SocketIO链接建立时创建的用户session副本可以在事件处理函数中被使用。如果SocketIO事件处理函数中修改了这个session，修改后的值可以在以后的SocketIO事件处理函数中被使用，但常规的http路由处理函数并不知道这些改变。事实上，当一个SocketIO事件处理函数修改了session，一个当前session的分支将会被专门创建出来。作出这种限制的原因在于当我们需要存储会话时cookie将被发送到客户端，而这需要HTTP请求与回应，这里并不存在SocketIO链接。当使用类似Flask-Session或Flask-KVSession这种服务端会话扩展时，在HTTP路由处理函数中修改session在SocketIO事件处理函数中是可见的，只要不再SocketIO事件处理函数中修改。（上面这一大段翻译的比较绕，核心观点就是如果要对session进行操作，请在http路由处理函数中而别在SocketIO处理函数中。路由函数中处理后事件函数中可见，反之则不行）</li><li>before_request 和 after_request钩子不会在事件处理函数中调用</li><li>SocketIO事件处理函数可以被自定义的装饰器所装饰，但大多数Flask装饰器不适用于事件处理函数，因为在事件处理函数中没有了Response object这个概念。</li></ol><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>一个常见的需求就是验证用户身份，传统的验证方式基于HTTP请求和web from不能在SocketIO链接中使用，因为没有地方发送HTTP请求和响应。如果必要的话，应用程序可以实现一个定制的登录功能，当用户按下登录按钮时通过SocketIO向服务端发送一个凭证。</p><p>然而更方便的方法是在建立SocketIO链接之前进行传统的认证，用户的认证信息可以被存储在session或者cookie中，晚些时候在SocketIO链接建立时候，这些认证信息将可以在事件处理函数中使用。</p><h2 id="结合使用Flask-Login与Flask-SocketIO"><a href="#结合使用Flask-Login与Flask-SocketIO" class="headerlink" title="结合使用Flask-Login与Flask-SocketIO"></a>结合使用Flask-Login与Flask-SocketIO</h2><p>Flask_socketIO能够使用由Flask-Login维护的用户信息。当常规的Flask-Login身份验证执行后， login_user()被调用在session中记录用户信息，任何事件处理函数都可以使用current_user变量：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_handler</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        emit(<span class="string">'my response'</span>,</span><br><span class="line">             &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">             broadcast=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># not allowed here</span></span><br></pre></td></tr></table></figure><p></p><p>注意login_required装饰器不能在SocketIO事件处理函数上使用，但下面所示的自定义装饰器可以断开未认证用户的链接：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask_login <span class="keyword">import</span> current_user</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> disconnect</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticated_only</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current_user.is_authenticated:</span><br><span class="line">            disconnect()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="meta">@authenticated_only</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">         broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>最简单的部署方式就是安装eventlet或者gevent，并且按照上面说的调用socketio.run(app)，这将在eventlet或者gevent上运行程序。</p><p>另一种替代方式是使用<a href="http://gunicorn.org/" target="_blank" rel="noopener">gunicorn</a> 作为网络服务器，并使用eventlet或者gevent workers:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --worker-class eventlet module:app</span><br><span class="line"></span><br><span class="line">gunicorn --worker-class gevent module:app</span><br></pre></td></tr></table></figure><p></p><p>上面的命令中，module指定义了应用程序实例的python的包或模块名，app就是应用程序实例本身。</p><p>eventlet本身就支持了WebSocket标准，但gevent想使用WebSocket需要安装gevent-websocket，如果这个没安装则仅能使用长轮循的机制。</p><p>当在gunicorn中使用gevent worker和WebSocket时，启动命令必须指明使用支持WebSocket的gevent worker:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --worker-class geventwebsocket.gunicorn.workers.GeventWebSocketWorker module:app</span><br></pre></td></tr></table></figure><p></p><h2 id="使用Nginx作为WebSocket的反向代理"><a href="#使用Nginx作为WebSocket的反向代理" class="headerlink" title="使用Nginx作为WebSocket的反向代理"></a>使用Nginx作为WebSocket的反向代理</h2><p>使用nginx作为应用程序的前端反向代理是可能的，然而有一点需要特别注意的是只有1.4及以后的版本才支持WebSocket协议，下面是一个常规的配置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    access_log /var/log/nginx/example.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:5000;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">    location /socket.io &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:5000/socket.io;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_buffering off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至于API部分就不翻译了，有需求的自己去官网看吧。</p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-link" href="/source/all-tags/flask/">flask</a> <a class="tag tag--primary tag--small t-link" href="/source/all-tags/python/">python</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2016/01/03/你好，2016！/" data-tooltip="你好，2016！"><i class="fa fa-angle-left"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2015/12/28/centos7安装Metasploit框架/" data-tooltip="centos7安装Metasploit框架"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions"><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-google-plus"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-weibo"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/&amp;title=flask-socketio中文文档"><i class="fa fa-qq"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-star"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-renren"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#"><i class="fa fa-list"></i></a></li></ul></div></div></article><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2020 Roy. All Rights Reserved.</span></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="4"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2016/01/03/你好，2016！/" data-tooltip="你好，2016！"><i class="fa fa-angle-left"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2015/12/28/centos7安装Metasploit框架/" data-tooltip="centos7安装Metasploit框架"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions"><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-google-plus"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-weibo"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/&amp;title=flask-socketio中文文档"><i class="fa fa-qq"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-star"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-renren"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#"><i class="fa fa-list"></i></a></li></ul></div></div><div id="share-options-bar" class="share-options-bar" data-behavior="4"><i id="btn-close-shareoptions" class="fa fa-close"></i><ul class="share-options"><li class="share-option"><a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-facebook-official"></i><span>分享到 Facebook</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-twitter"></i><span>分享到 Twitter</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-google-plus"></i><span>分享到 Google+</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-weibo"></i><span>分享到 Weibo</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/&amp;title=flask-socketio中文文档"><i class="fa fa-qq"></i><span>分享到 QQ</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-star"></i><span>分享到 Qzone</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2015/12/29/flask-socketio中文文档/"><i class="fa fa-renren"></i><span>分享到 Renren</span></a></li></ul></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-remove"></i></div><img id="about-card-picture" src="/assets/images/my.jpg" alt="作者的图片"><h4 id="about-card-name">Roy</h4><div id="about-card-bio"><p>君以国士待我，我必以国士报君。</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>野生程序猿</p></div><div id="about-card-location"><i class="fa fa-map-marker"></i><br>China</div></div></div><div id="algolia-search-modal" class="modal-container"><div class="modal"><div class="modal-header"><span class="close-button"><i class="fa fa-close"></i></span> <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled"><span class="searchby-algolia-text text-color-light text-small">by</span> <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg"> </a><i class="search-icon fa fa-search"></i><form id="algolia-search-form"><input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search "></form></div><div class="modal-body"><div class="no-result text-color-light text-center">没有找到文章</div><div class="results"><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/02/12/Ubuntu下Gogant的简易破墙术/"><h3 class="media-heading">Ubuntu下Gogant的简易破墙术</h3></a><span class="media-meta"><span class="media-date text-small">2013年2月12日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/10/31/python常用第三方库-转载/"><h3 class="media-heading">Python常用第三方库(转载)</h3></a><span class="media-meta"><span class="media-date text-small">2013年10月31日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19安装ar8161网卡驱动/"><h3 class="media-heading">fedora19安装ar8161网卡驱动</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19源，rpmforge，fastestmirror/"><h3 class="media-heading">fedora19源，rpmforge，fastestmirror</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/python中如何自定义解析域名/"><h3 class="media-heading">python中如何自定义解析域名</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django版本更换/"><h3 class="media-heading">django版本更换</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django-groundwork个人1-5-3修改版/"><h3 class="media-heading">django-groundwork个人1.5.3修改版</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19美化/"><h3 class="media-heading">fedora19美化</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/装饰器/"><h3 class="media-heading">装饰器</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/SVN常用操作/"><h3 class="media-heading">SVN常用操作</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div></div></div><div class="modal-footer"><p class="results-count text-medium" data-message-zero="没有找到文章" data-message-one="找到 1 篇文章" data-message-other="找到 {n} 篇文章">找到 232 篇文章</p></div></div></div><div id="cover" style="background-image:url(/assets/images/cover.jpg)"></div><script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script><script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><script>var algoliaClient=algoliasearch("51U8PIBLP6","16909d9ce1780cda71113841864e7aa8"),algoliaIndex=algoliaClient.initIndex("my-blog")</script></body></html>