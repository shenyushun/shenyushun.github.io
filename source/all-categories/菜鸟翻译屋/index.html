<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Hi!Roy!"><title>分类: 菜鸟翻译屋 - Hi!Roy!</title><meta name="author" content="Roy"><link rel="icon" href="http://www.hi-roy.com/assets/images/favicon.ico"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><meta property="og:type" content="blog"><meta property="og:title" content="Hi!Roy!"><meta property="og:url" content="http://www.hi-roy.com/source/all-categories/菜鸟翻译屋/index.html"><meta property="og:site_name" content="Hi!Roy!"><meta property="og:locale" content="zh-cn"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hi!Roy!"><meta property="og:image" content="http://www.hi-roy.com/assets/images/my.jpg"><link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?21513ec2bcd577b3297a1b16da82fa40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div id="blog"><header id="header" data-behavior="1"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/">Hi!Roy!</a></div><a class="header-right-icon" href="#about"><i class="fa fa-lg fa-question"></i></a></header><nav id="sidebar" data-behavior="1"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about"><img class="sidebar-profile-picture" src="/assets/images/my.jpg" alt="作者的图片"></a><h4 class="sidebar-profile-name">Roy</h4><h5 class="sidebar-profile-bio"><p>君以国士待我，我必以国士报君。</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/"><i class="sidebar-button-icon fa fa-lg fa-home"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories"><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags"><i class="sidebar-button-icon fa fa-lg fa-tags"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives"><i class="sidebar-button-icon fa fa-lg fa-archive"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link open-algolia-search" href="#search"><i class="sidebar-button-icon fa fa-lg fa-search"></i> <span class="sidebar-button-desc">搜索</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about"><i class="sidebar-button-icon fa fa-lg fa-question"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/shenyushun" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-github"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:darkcooking@gmail.com" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml"><i class="sidebar-button-icon fa fa-lg fa-rss"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div id="main" data-behavior="1" class="hasCoverMetaIn"><section class="postShorten-group main-content-wrap"><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/12/03/如何更好的code-review/">如何更好的Code Review</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-12-03T11:05:03+08:00">12月 03, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://levelup.gitconnected.com/how-to-do-good-code-reviews-ee481f73b11b" target="_blank" rel="noopener">原文</a>，向原作者表示感谢。不过不知道作者是不是在国内学过作文，让我想起了小学时老师教的作文要多引用名人名言哈哈。</p><hr><p>几年前当我还是个菜鸟的时候，我过得十分潇洒。</p><p>写代码——交给别人review——改代码，绳命是多磨美好！工作内容就是仔细阅读我收到的评论、建议，学着成为一个更优秀的开发者。如今我成长为了一名高级开发人员，给别人做code review成为了我的职责之一，这时我意识到我的经验还不足以完成这种职责转变。</p><p>每次给别人做code review时我都感觉到害怕，感觉自己像是一个骗子，很多问题都困扰着我：</p><p><em>我该给这行代码提建议吗？</em></p><p><em>应该有更好的办法写这段代码，我应该告诉他吗？</em></p><p><em>他会怎么想？他的经验比我丰富。</em></p><p><em>改了这一行代码会不会使程序崩溃？</em></p><p>这时我的导师给了我建议。</p><p>好的code review聚焦于获得额外的产出，而非仅仅是找到bug。别把review当做是审讯，而当做是一种提高代码质量、发现其他方案、增加学习能力以及加强友谊的办法。</p><p>作为reviewer，你对代码的反馈是将渴望贡献的开发者组建成社区的一种主要方法。通过培养一个活跃的社区，你将提升产品、团队、和人生的质量。</p><p>这里有一些做好code review的建议。</p><a href="/2019/12/03/如何更好的code-review/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2017/12/01/基于虚拟可视化的网页分割/">基于虚拟可视化的网页分割</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2017-12-01T14:22:53+08:00">12月 01, 2017 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="http://blog.mapado.com/web-page-segmentation-by-visual-clustering/" target="_blank" rel="noopener">原文地址</a>，向原作者表示感谢。</p><p>我们在Mapado的工作就是收集世界上所有“要做的事”。</p><p>为了得到大量数据，我们抓取整个网络，就像Goole做的那样，搜集所有关于演唱会、演出、访问、景点……当我们发现一个有趣的页面，我们就尝试从这个页面提取“好”的数据。</p><p>我们面临的一个主要挑战就是如何从垃圾信息中(广告、导航栏、页脚、相关内容……)分离我们感兴趣的内容(标题、简介、图片、日期……)</p><p>在这个挑战中，一个任务就是重组在视觉上相近的内容。通常，组成页面主要部分的元素相互之间距离是很近的。</p><p>当我们开始进行任务时，很天真的以为可以操作DOM来实现。在DOM中，元素以层级结构存储，所以在同一个父元素中的元素很大可能是相关的。</p><p>一个非常有趣的介绍页面分割的论文可以在这里找到 <a href="http://wims.vestforsk.no/slides/alcic.pdf" target="_blank" rel="noopener">Page Segmentation by Web Content Clustering</a>。</p><a href="/2017/12/01/基于虚拟可视化的网页分割/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2017/10/30/10分钟入门Pandas/">10分钟入门Pandas</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2017-10-30T11:38:23+08:00">10月 30, 2017 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="http://pandas.pydata.org/pandas-docs/stable/10min.html" target="_blank" rel="noopener">原文地址</a>，是官网的《10 Minutes to pandas》翻译，代码中添加了个人的一些注释。</p><p>通常来说，我们像下面这样来引入包:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p></p><a href="/2017/10/30/10分钟入门Pandas/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2016/12/22/什么时候不使用箭头函数/">什么时候不使用箭头函数</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2016-12-22T17:07:08+08:00">12月 22, 2016 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>作为一个前端渣渣，最近在写js代码的时候，开始使用一些ES6的新特性，结果到箭头函数部分“掉坑”了。网上大部分都说箭头函数怎么用，而很少说箭头什么时候 <em>不要用</em>，所以这里翻译一篇文章来说说什么时候不要用的问题。</p><p><a href="https://rainsoft.io/when-not-to-use-arrow-functions-in-javascript/" target="_blank" rel="noopener">原文地址</a>，向原作者表示感谢。</p><a href="/2016/12/22/什么时候不使用箭头函数/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2016/11/08/我特么是如何利用Django-Django-REST-Framework-Angular-1-1-x和Webpack构建一个项目的/">我特么是如何利用Django, Django REST Framework, Angular 1.1.x和Webpack构建一个项目的</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2016-11-08T13:50:46+08:00">11月 08, 2016 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="http://gregblogs.com/how-the-do-i-build-a-django-django-rest-framework-angular-1-1-x-and-webpack-project/#prereq" target="_blank" rel="noopener">原文地址</a>，向原作者表示感谢。由于本人并没学习过angular，所以翻译有误的地方恳请指正。</p><hr><p>我已经受够了JS社区的那帮二货，我只是想使用Django作为后端结合Angular做一个简单的、可复用的项目，却没有一个简明的指导教我如何做到。如果你也为此挣扎，这里有一份指南教你如何构建一个由Django作为后端、Webpack进行组织的Angular程序。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我想开发一个Angular1.1.x的项目并使用Django作为后端提供数据，我喜欢使用Django REST Framework(DRF)来构造RESTful API。我也想打包需要的JavaScript资源。目前，我打算使用单一的服务器上运行这个程序。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>Python 2.x</li><li>a virtual Python environment</li><li>Django 1.9.x (pip install django)</li><li>npm 2.15.8+</li><li>Webpack 1.13.x (sudo npm i -g webpack)</li><li>ESLint 2.13.1+ (sudo npm i -g eslint)</li><li>NodeJS 4.4.7+</li></ul><a href="/2016/11/08/我特么是如何利用Django-Django-REST-Framework-Angular-1-1-x和Webpack构建一个项目的/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2016/08/15/在MySQL中存储树结构/">在MySQL中存储树状结构</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2016-08-15T17:46:18+08:00">8月 15, 2016 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/" target="_blank" rel="noopener">原文地址</a>，原文中<code>Hierarchical Data</code>直译为 <em>分层结构</em>，这里我翻译成 <em>树状结构</em>。</p><p>补充资源：</p><ol><li><a href="https://django-mptt.github.io/django-mptt/" target="_blank" rel="noopener">https://django-mptt.github.io/django-mptt/</a> ，如果你也使用python和django，这个是现成的APP。</li></ol><p>另外，个人觉得这种方法对于搜索的效率提升最大，而相应的新增、删除等操作则会变慢，个人猜测未经测试。</p><p>个人总结的核心：如果一个节点A是节点B的子节点，那么A的左值一定大于B的左值，A的右值一定小于B的右值。或者说，A的左值一定在B的左值和右值之间。<br><a href="/2016/08/15/在MySQL中存储树结构/" class="postShorten-excerpt_link link">阅读全文</a></p></div></div></article><article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2016/06/27/django-REST-framework中文文档教程/">Django-REST-framework中文文档教程</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2016-06-27T13:44:46+08:00">6月 27, 2016 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-content" itemprop="articleBody"><p>目前网上的关于Django-REST-framework中文文档教程大多数都是你抄我我抄你，也找不出到底是出自谁手以及哪个版本的文档翻译了。于是我决定将自己阅读文档的翻译记录下来，供有需要的人阅读。</p><p>但经过排版，发现这种由多章组成的系列教程，在博客上怎么弄都不方便看，所以教程直接放到gitbook上，请移步至:</p><p><a href="https://darkcooking.gitbooks.io/django-rest-framework-cn/content/" target="_blank" rel="noopener">https://darkcooking.gitbooks.io/django-rest-framework-cn/content/</a></p><p><a href="/2016/06/27/django-REST-framework中文文档教程/#post-footer" class="postShorten-excerpt_link link">评论和分享</a></p></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2016/03/16/名词王国里的死刑（翻译）/">名词王国里的死刑（翻译）</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2016-03-16T17:02:02+08:00">3月 16, 2016 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>真是惭愧，直到今日才读到这篇文章，原文在<a href="http://steve-yegge.blogspot.hk/2006/03/execution-in-kingdom-of-nouns.html" target="_blank" rel="noopener">这里</a>。我本人大学课程中唯一没选修的语言就是Java，不知什么原因对于Java就是不感冒。虽然由于某些原因做了一阵android的开发，但是这段经历更是让我坚定了“能不写java程序就不写java程序”的想法。这里无意引起“语言之战”，仅是个人喜好问题罢了。</p><a href="/2016/03/16/名词王国里的死刑（翻译）/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2015/12/29/flask-socketio中文文档/">flask-socketio中文文档</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2015-12-29T16:18:34+08:00">12月 29, 2015 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>官网在<a href="https://flask-socketio.readthedocs.org/en/latest/" target="_blank" rel="noopener">这里</a>，英语好的直接去看官网文档吧，我是英语渣只能翻译个大概;另外注意本文翻译时间，可能你看到的时候官网已经更新了。</p><hr><p>flask-socketio赋予了flask程序支持服务端和客户端间双向低延迟通讯的能力，客户端可以使用 <a href="http://socket.io/" target="_blank" rel="noopener">SocketIO</a> 库或任何支持与服务端建立长链接的兼容库。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接使用pip安装：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-socketio</span><br></pre></td></tr></table></figure><p></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>自从1.0版开始，这个扩展完全兼容了python2.7和python3.3+版本。异步服务的支持基于下面3个选择中的一个：</p><ul><li><a href="http://eventlet.net/" target="_blank" rel="noopener">eventlet</a> 是3个选项中性能最高的，同时支持长轮循(long-polling)和WebSocket。</li><li><a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 是在以前版本中使用的框架，支持长轮循，如果想支持WebSocket的话需要同时安装<a href="https://pypi.python.org/pypi/gevent-websocket/" target="_blank" rel="noopener">gevent-websocket</a> 库。使用gevent和gevent-websocket结合性能也不错，但略低于eventlet。</li><li>flask 基于Werkzeug的开发服务也能用，不过性能上不如上面2个选项，所以它应该只用于开发时使用。这个选项只支持长轮循。<br>本扩展将自动检测哪些异步框架被安装，默认首选eventlet，其次是gevent，最后是flask自带的开发服务。<br>对于客户端来说，可以使用官方的Socket.Io来建立于服务端的链接，也有使用swift和c++写成的客户端。非官方的客户端也能工作，只要它实现了<a href="https://github.com/socketio/socket.io-protocol" target="_blank" rel="noopener">Socket.IO</a> 协议。</li></ul><h2 id="目前的局限"><a href="#目前的局限" class="headerlink" title="目前的局限"></a>目前的局限</h2><p>目前flask-socketio只能同时运行在单个进程中（这里应该指的是一个进程中仅能存在一个实例的意思，而非只能开启一个进程吧…），解决这个限制的工作正在进行中。<br>（关于升级变化、以及从老版本迁移到新版的注意事项我就不翻译了，因为没用过老版本）</p><a href="/2015/12/29/flask-socketio中文文档/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2015/04/23/使用firewalld-cmd配置防火墙/">使用firewalld-cmd配置防火墙</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2015-04-23T17:44:52+08:00">4月 23, 2015 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-content" itemprop="articleBody"><p>CentOS7和fedora中的默认防火墙都变成了firewalld，当然你也可以选择禁用这个并自己安装iptables，下面内容原文：<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html" target="_blank" rel="noopener">这里</a>，而且只翻译我用到的部分文章。原文中还展示了如何使用图形界面进行配置，不过作为键盘爱好者，能不用鼠标的就尽量不用鼠标了，直接上命令行操作。</p><hr><h3 id="4-5-4-理解域概念"><a href="#4-5-4-理解域概念" class="headerlink" title="4.5.4 理解域概念"></a>4.5.4 理解域概念</h3><p>firewalld可以根据不同的信任级别，将处于不同域内的设备进行分离。NetworkManager用于管理firewalld将接口分配到哪个域中，可以通过NetworkManager界面或filrewall-config工具来进行设置。</p><p>默认的配置文件位于/etc/firewalld/可以快速的应用在网络接口上，这里有一份关于域的简短的说明：</p><p>dorp:任何入站请求都被忽略，无任何回复，只有发起的网络链接请求被放行。</p><p>block:任何入站请求都被拒绝，ipv4协议回复”icmp-host-prohibited”消息，ipv6协议回复”icmp6-adm-prohibited”，只有从系统内部发出的链接请求才被放行。</p><p>（个人感觉上面两个区别就是在于有无回复，对内的话用block、对外用dorp好一些，让外部扫描费点劲才知道被防火墙过滤了）</p><p>public:为在公共场所准备，你不相信网络中的其他电脑不会对你的电脑造成伤害，只有被选定的入站链接被接受。</p><p>external:为有伪装的外部网络特别是路由器准备，你不相信网络中的其他电脑不会对你的电脑造成伤害，只有被选定的入站链接被接受。</p><p>dmz:为那些处于隔离区(demilitarized zone)可以访问部分内部网络的电脑准备，只有被选定的入站链接被接受。</p><p>work:为工作域的电脑准备，你相信网络中其他电脑不会对你的电脑造成伤害，只有被选定的入站链接被接受。</p><p>home:为家庭域的电脑准备，你相信网络中其他电脑不会对你的电脑造成伤害，只有被选定的入站链接被接受。</p><p>internal:为内部域的电脑准备，你相信网络中其他电脑不会对你的电脑造成伤害，只有被选定的入站链接被接受。</p><p>trusted:接受全部请求。</p><p>你可以指定一个域为默认域，当一个新接口被添加到NetworkManager中时，它将被分配到默认域中。在默认情况下public为默认域。</p><h3 id="4-5-6-理解预设服务"><a href="#4-5-6-理解预设服务" class="headerlink" title="4.5.6 理解预设服务"></a>4.5.6 理解预设服务</h3><p>如果一个服务可用的话，它应该有一份本地端口和目标端口的列表，同时防火墙辅助模块自动载入这份列表。使用预设服务可以让用户轻松控制服务是否可以被访问，通过使用预设服务或用户自定义服务的方式来控制访问权限而不是通过管理端口或端口范围也许让管理员更加轻松。(翻译的不好，意思就是只记mysql而不用记3306端口了)服务的配置选项和通用文件信息在firewalld.service(5)中有介绍。服务被指定使用xml文件格式并且命名为service-name.xml这种格式。<br>可以通过下面的命令查看默认的预设服务：<code>ls /usr/lib/firewalld/services/</code></p><p>不要修改/usr/lib/firewalld/services中的文件，只有/etc/firewalld/services/才可以被修改。</p><p>查看系统或用户创建的服务可以使用:<code>ls /etc/firewalld/services/</code></p><p>服务可以通过图形界面或编辑/etc/firewalld/services/中的文件来新增或删除，如果你还没添加或修改过任何一个服务，/etc/firewalld/services/目录下是没有任何文件的，可以把从/usr/lib/firewalld/services/中复制出一个文件作为模板，比如：<br><code>cp /usr/lib/firewalld/services/[service].xml /etc/firewalld/services/[service].xml</code></p><p>你也许想新建一个文件，firewalld更喜欢新文件在/etc/firewalld/services/中而非/usr/lib/firewalld/services/中。</p><h3 id="4-5-7-理解直接接口"><a href="#4-5-7-理解直接接口" class="headerlink" title="4.5.7 理解直接接口"></a>4.5.7 理解直接接口</h3><p>firewalld中有一个功能叫做”直接接口“，它能直接通过iptables、ip6tables、ebtables的规则，这是为应用准备而不是为用户准备的。如果你对iptables不是十分熟悉的话用直接接口是很危险的，这无意间可能导致防火墙规则漏洞。某些规则被添加时仍然被firewalld所追踪，所以还可以用firewalld查看那些应用程序使用直接接口引起变化的规则。可以通过在firewalld-cmd 添加–direct来使用直接接口。</p><p>直接接口的目的是让服务或程序在运行时添加特定的防火墙规则, 通过使用–permanent参数或修改/etc/firewalld/direct.xml文件可以让这些规则持久化。如果规则没被持久化，则每次重启、重加载时都要重新添加。</p><h3 id="4-5-15-3-通过命令行查看firewalld"><a href="#4-5-15-3-通过命令行查看firewalld" class="headerlink" title="4.5.15.3 通过命令行查看firewalld"></a>4.5.15.3 通过命令行查看firewalld</h3><p>查看状态：<br><code>firewall-cmd --state</code></p><p>查看当前域：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br><span class="line">public</span><br><span class="line">  interfaces: em1</span><br></pre></td></tr></table></figure><p></p><p>根据接口查看所属域：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-zone-of-interface=em1</span><br><span class="line">public</span><br></pre></td></tr></table></figure><p></p><p>查看某域下所有接口：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-interfaces</span><br><span class="line">em1 wlan0</span><br></pre></td></tr></table></figure><p></p><p>这个命令的结果来自Networkmanager而且只显示接口不显示链接。</p><p>查看某域的所有设定：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-all</span><br><span class="line">public</span><br><span class="line">  interfaces:</span><br><span class="line">  services: mdns dhcpv6-client ssh</span><br><span class="line">  ports:</span><br><span class="line">  forward-ports:</span><br><span class="line">  icmp-blocks: source-quench</span><br></pre></td></tr></table></figure><p></p><p>查看当前哪些服务被加载：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br><span class="line">cluster-suite pop3s bacula-client smtp ipp radius bacula ftp mdns samba dhcpv6-client dns openvpn imaps samba-client http https ntp vnc-server telnet libvirt ssh ipsec ipp-client amanda-client tftp-client nfs tftp libvirt-tls</span><br></pre></td></tr></table></figure><p></p><p>这将展示出所有位于/usr/lib/firewalld/services/的预设服务和当前载入的所有用户自定义服务，注意xml文件名必须是<em>service-name</em>.xml。如果用户自定义服务以及创建但没被加载，可以使用命令：<code>firewall-cmd --permanent --get-services</code></p><p>这个命令将展示所有的服务，包括未被加载的那些位于/etc/firewalld/services/的服务。</p><h3 id="4-5-15-4-通过命令行设置firewalld"><a href="#4-5-15-4-通过命令行设置firewalld" class="headerlink" title="4.5.15.4 通过命令行设置firewalld"></a>4.5.15.4 通过命令行设置firewalld</h3><h4 id="4-5-15-4-1-忽略所有包"><a href="#4-5-15-4-1-忽略所有包" class="headerlink" title="4.5.15.4.1 忽略所有包"></a>4.5.15.4.1 忽略所有包</h4><p>使用下面的命令忽略所有入站和出站请求：<code>firewall-cmd --panic-on</code></p><p>已经建立的链接将在会话过期后被终止。重新接受所有请求：<code>firewall-cmd --panic-off</code></p><p>查看panic状态：<code>firewall-cmd --query-panic</code></p><p>yes为启用，no为关闭。</p><h4 id="4-5-15-4-2-重载防火墙"><a href="#4-5-15-4-2-重载防火墙" class="headerlink" title="4.5.15.4.2 重载防火墙"></a>4.5.15.4.2 重载防火墙</h4><p>重载防火墙但并不打断用户链接：<code>firewall-cmd --reload</code></p><p>重载防火墙同时打断用户链接：<code>firewall-cmd --complete-reload</code></p><p>通常情况这个命令只有在防火墙服务出问题了才被使用。</p><h4 id="4-5-15-4-3-通过命令行添加新接口到某个域"><a href="#4-5-15-4-3-通过命令行添加新接口到某个域" class="headerlink" title="4.5.15.4.3 通过命令行添加新接口到某个域"></a>4.5.15.4.3 通过命令行添加新接口到某个域</h4><p>更改接口到某个域:<code>firewall-cmd --zone=public --add-interface=em1</code></p><p>从域中删除某接口:<code>firewall-cmd --zone=dmz --change-interface=em1</code></p><p>如果想要持久化，记得添加–permanent参数以及重载防火墙:<code>firewall-cmd --zone=public --remove-interface=em1</code></p><h4 id="4-5-15-4-4-通过修改文件添加新接口到某个域"><a href="#4-5-15-4-4-通过修改文件添加新接口到某个域" class="headerlink" title="4.5.15.4.4 通过修改文件添加新接口到某个域"></a>4.5.15.4.4 通过修改文件添加新接口到某个域</h4><p>编辑ifcfg-em1文件(一般位于/ets/sysconfig/network-scripts目录)，添加<br><code>ZONE=work</code></p><p>如果你省略zone或zone=””,默认将使用默认域。修改完成后NetworkManager将自动重连并设置相应域。</p><h4 id="4-5-15-4-5-通过修改配置文件修改默认域"><a href="#4-5-15-4-5-通过修改配置文件修改默认域" class="headerlink" title="4.5.15.4.5 通过修改配置文件修改默认域"></a>4.5.15.4.5 通过修改配置文件修改默认域</h4><p>编辑 /etc/firewalld/firewalld.conf<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default zone</span><br><span class="line"># The default zone used if an empty zone string is used.</span><br><span class="line"># Default: public</span><br><span class="line">DefaultZone=home</span><br></pre></td></tr></table></figure><p></p><p>保存后重载防火墙，这将中断所有链接。</p><h4 id="4-5-15-4-6-通过命令行修改默认域"><a href="#4-5-15-4-6-通过命令行修改默认域" class="headerlink" title="4.5.15.4.6 通过命令行修改默认域"></a>4.5.15.4.6 通过命令行修改默认域</h4><p>使用命令：<code>firewall-cmd --set-default-zone=public</code></p><p>将立即生效而不需要重载防火墙 。</p><h4 id="4-5-15-4-7-通过命令行开放端口"><a href="#4-5-15-4-7-通过命令行开放端口" class="headerlink" title="4.5.15.4.7 通过命令行开放端口"></a>4.5.15.4.7 通过命令行开放端口</h4><p>首先列出所有开放的端口，以dmz域为例：<code>firewall-cmd --zone=dmz --list-ports</code></p><p>注意，这里不会展示被–add-services参数打开的端口。</p><p>开放某域内的端口，比如开放dmz域的8080端口，命令如下：<code>firewall-cmd --zone=dmz --add-port=8080/tcp</code></p><p>开放某段的端口，命令如下：<code>firewall-cmd --zone=public --add-port=5060-5065/udp</code></p><p>如果需要的话，记得使用<code>--permanent</code>参数进行持久化。</p><h4 id="4-5-15-4-8-通过命令行添加删除服务到某域"><a href="#4-5-15-4-8-通过命令行添加删除服务到某域" class="headerlink" title="4.5.15.4.8 通过命令行添加删除服务到某域"></a>4.5.15.4.8 通过命令行添加删除服务到某域</h4><p>这里以smtp服务添加到work域为例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=work --add-service=smtp</span><br><span class="line">firewall-cmd --zone=work --remove-service=smtp</span><br></pre></td></tr></table></figure><p></p><p>同样的添加<code>--permanent</code>进行持久化，如果你使用了这个参数并想立即生效，请重载防火墙。</p><h4 id="4-5-15-4-9-通过修改xml文件添加删除服务到某域"><a href="#4-5-15-4-9-通过修改xml文件添加删除服务到某域" class="headerlink" title="4.5.15.4.9 通过修改xml文件添加删除服务到某域"></a>4.5.15.4.9 通过修改xml文件添加删除服务到某域</h4><p>首先查看默认域文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/lib/firewalld/zones/</span><br><span class="line">block.xml  drop.xml      home.xml      public.xml   work.xml</span><br><span class="line">dmz.xml    external.xml  internal.xml  trusted.xml</span><br></pre></td></tr></table></figure><p></p><p>不要编辑这些文件，如果/etc/firewalld/zones/目录中没有等效文件这些文件将被使用。</p><p>想查看哪些域文件被修改，使用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/firewalld/zones/</span><br><span class="line">external.xml  public.xml  public.xml.old</span><br></pre></td></tr></table></figure><p></p><p>这里我们以向work域添加服务为例，首先：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/lib/firewalld/zones/work.xml /etc/firewalld/zones/</span><br></pre></td></tr></table></figure><p></p><p>现在可以编辑位于/etc/firewalld/zones下的文件了，以添加smtp服务为例，修改work.xml添加：<code>&lt;service name=&quot;smtp&quot;/&gt;</code></p><p>如果你删除了这个文件，那么/usr/lib/firewalld/zones/中的文件将被使用。</p><p>删除操作和添加相反，删除我们编辑的xml文件中添加的行就行了，就不翻了。</p><h4 id="4-5-14-4-12-ip地址伪装"><a href="#4-5-14-4-12-ip地址伪装" class="headerlink" title="4.5.14.4.12 ip地址伪装"></a>4.5.14.4.12 ip地址伪装</h4><p>查看:<code>firewall-cmd --zone=external --query-masquerade</code></p><p>启用:<code>firewall-cmd --zone=external --add-masquerade</code></p><p>禁用:<code>firewall-cmd --zone=external --remove-masquerade</code></p><p>记得添加<code>--permanent</code>以及重载防火墙。</p><h4 id="4-5-14-4-12-端口转发"><a href="#4-5-14-4-12-端口转发" class="headerlink" title="4.5.14.4.12 端口转发"></a>4.5.14.4.12 端口转发</h4><p>想要进行端口转发，先要启用ip地址伪装，然后使用:<code>firewall-cmd --zone=external --add-forward-port=port=22:proto=tcp:toport=3753</code></p><p>上面的例子中把external域中22端口转发给本机的3753端口，协议为tcp。其中端口可以是一个端口也可以是端口范围，而proto则只能是tcp或udp的协议中的一个。</p><p>如果是转发给另一个ip，通常是内部Ip并且端口不变，则<code>firewall-cmd --zone=external --add-forward-port=port=22:proto=tcp:toaddr=192.0.2.55</code></p><p>如果端口也变了:<code>firewall-cmd --zone=external --add-forward-port=port=22:proto=tcp:toport=2055:toaddr=192.0.2.55</code></p><p>记得添加<code>--permanent</code>以及重载防火墙。</p><h3 id="4-5-14-6-使用直接接口"><a href="#4-5-14-6-使用直接接口" class="headerlink" title="4.5.14.6 使用直接接口"></a>4.5.14.6 使用直接接口</h3><p>车轱辘话略过，见上面</p><h4 id="4-5-14-6-1-添加用户规则"><a href="#4-5-14-6-1-添加用户规则" class="headerlink" title="4.5.14.6.1 添加用户规则"></a>4.5.14.6.1 添加用户规则</h4><p>添加规则链<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --direct --add-rule ipv4 filter IN_public_allow \</span><br><span class="line">      0 -m tcp -p tcp --dport 666 -j ACCEPT</span><br></pre></td></tr></table></figure><p></p><h4 id="4-5-14-6-2-删除用户规则"><a href="#4-5-14-6-2-删除用户规则" class="headerlink" title="4.5.14.6.2 删除用户规则"></a>4.5.14.6.2 删除用户规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --direct --remove-rule ipv4 filter IN_public_allow \</span><br><span class="line">      0 -m tcp -p tcp --dport 666 -j ACCEPT</span><br></pre></td></tr></table></figure><h4 id="4-5-14-6-3-展示用户规则"><a href="#4-5-14-6-3-展示用户规则" class="headerlink" title="4.5.14.6.3 展示用户规则"></a>4.5.14.6.3 展示用户规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --direct --get-rules ipv4 filter IN_public_allow</span><br></pre></td></tr></table></figure><p>如果需要的话，同样使用<code>--permanent</code>以及重载防火墙。</p><hr><p>翻到后面发现车轮话太多了，就只进行了意译，而且个人也就使用开放端口、转发一类的常见操作，高深地方就不不翻译了，用到了在说吧。注意的就是如果不加<code>--permanent</code>参数则会实时生效，但重启或重加载后会失效。加<code>--permanent</code>参数则不会实时生效，需要重新reload。<br>再补充一些东西，类似于黑白名单机制，比如我想根据来源ip来分配不同的域规则，则相关命令如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --list-sources</span><br><span class="line">firewall-cmd --permanent --zone=public --add-source=192.168.100.0/24</span><br><span class="line">firewall-cmd --permanent --zone=public --add-source=192.168.222.123/32</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=1-22/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=1-22/udp</span><br></pre></td></tr></table></figure><p></p><p>有add-source、port自然就会有remove-source、port了，当你只想让某些指定的ip访问某些服务的话，就可以把这些ip放到相应的域内，加载规则如下:</p><ol><li>如果一个包的来源已经绑定在某个域内，则使用这个域的规则。</li><li>如果一个包的来源没绑定任何一个域，但来源访问的接口绑定了某个域（比如eth0），则使用端口绑定的域规则。</li><li>如果一个包的来源和来源接口都没绑定某个域，则使用默认域规则。<br>这里还要注意，一个ip地址只能属于一个域，否则会提示域冲突。</li></ol><p><a href="/2015/04/23/使用firewalld-cmd配置防火墙/#post-footer" class="postShorten-excerpt_link link">评论和分享</a></p></div></div></article><div class="pagination-bar"><ul class="pagination"><li class="pagination-next"><a class="btn btn--default btn--small" href="/source/all-categories/菜鸟翻译屋/page/2/"><span>下一页</span> <i class="fa fa-angle-right text-base icon-ml"></i></a></li><li class="pagination-number">第 1 页 共 2 页</li></ul></div></section><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2020 Roy. All Rights Reserved.</span></footer></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-remove"></i></div><img id="about-card-picture" src="/assets/images/my.jpg" alt="作者的图片"><h4 id="about-card-name">Roy</h4><div id="about-card-bio"><p>君以国士待我，我必以国士报君。</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>野生程序猿</p></div><div id="about-card-location"><i class="fa fa-map-marker"></i><br>China</div></div></div><div id="algolia-search-modal" class="modal-container"><div class="modal"><div class="modal-header"><span class="close-button"><i class="fa fa-close"></i></span> <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled"><span class="searchby-algolia-text text-color-light text-small">by</span> <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg"> </a><i class="search-icon fa fa-search"></i><form id="algolia-search-form"><input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search "></form></div><div class="modal-body"><div class="no-result text-color-light text-center">没有找到文章</div><div class="results"><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/02/12/Ubuntu下Gogant的简易破墙术/"><h3 class="media-heading">Ubuntu下Gogant的简易破墙术</h3></a><span class="media-meta"><span class="media-date text-small">2013年2月12日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/10/31/python常用第三方库-转载/"><h3 class="media-heading">Python常用第三方库(转载)</h3></a><span class="media-meta"><span class="media-date text-small">2013年10月31日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19安装ar8161网卡驱动/"><h3 class="media-heading">fedora19安装ar8161网卡驱动</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19源，rpmforge，fastestmirror/"><h3 class="media-heading">fedora19源，rpmforge，fastestmirror</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/python中如何自定义解析域名/"><h3 class="media-heading">python中如何自定义解析域名</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django版本更换/"><h3 class="media-heading">django版本更换</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django-groundwork个人1-5-3修改版/"><h3 class="media-heading">django-groundwork个人1.5.3修改版</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19美化/"><h3 class="media-heading">fedora19美化</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/装饰器/"><h3 class="media-heading">装饰器</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/SVN常用操作/"><h3 class="media-heading">SVN常用操作</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div></div></div><div class="modal-footer"><p class="results-count text-medium" data-message-zero="没有找到文章" data-message-one="找到 1 篇文章" data-message-other="找到 {n} 篇文章">找到 229 篇文章</p></div></div></div><div id="cover" style="background-image:url(/assets/images/cover.jpg)"></div><script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script><script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><script>var algoliaClient=algoliasearch("51U8PIBLP6","16909d9ce1780cda71113841864e7aa8"),algoliaIndex=algoliaClient.initIndex("my-blog")</script></body></html>