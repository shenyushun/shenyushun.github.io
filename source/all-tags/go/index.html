<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Hi!Roy!"><title>标签: go - Hi!Roy!</title><meta name="author" content="Roy"><link rel="icon" href="http://www.hi-roy.com/assets/images/favicon.ico"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><meta property="og:type" content="blog"><meta property="og:title" content="Hi!Roy!"><meta property="og:url" content="http://www.hi-roy.com/source/all-tags/go/index.html"><meta property="og:site_name" content="Hi!Roy!"><meta property="og:locale" content="zh-cn"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hi!Roy!"><meta property="og:image" content="http://www.hi-roy.com/assets/images/my.jpg"><link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?21513ec2bcd577b3297a1b16da82fa40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div id="blog"><header id="header" data-behavior="1"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/">Hi!Roy!</a></div><a class="header-right-icon" href="#about"><i class="fa fa-lg fa-question"></i></a></header><nav id="sidebar" data-behavior="1"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about"><img class="sidebar-profile-picture" src="/assets/images/my.jpg" alt="作者的图片"></a><h4 class="sidebar-profile-name">Roy</h4><h5 class="sidebar-profile-bio"><p>君以国士待我，我必以国士报君。</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/"><i class="sidebar-button-icon fa fa-lg fa-home"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories"><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags"><i class="sidebar-button-icon fa fa-lg fa-tags"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives"><i class="sidebar-button-icon fa fa-lg fa-archive"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link open-algolia-search" href="#search"><i class="sidebar-button-icon fa fa-lg fa-search"></i> <span class="sidebar-button-desc">搜索</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about"><i class="sidebar-button-icon fa fa-lg fa-question"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/shenyushun" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-github"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:darkcooking@gmail.com" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml"><i class="sidebar-button-icon fa fa-lg fa-rss"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div id="main" data-behavior="1" class="hasCoverMetaIn"><section class="postShorten-group main-content-wrap"><article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2020/12/16/golang小技巧/">golang小技巧</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2020-12-16T21:32:59+08:00">12月 16, 2020 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a></div></div><div class="postShorten-content" itemprop="articleBody"><h2 id="下划线的妙用"><a href="#下划线的妙用" class="headerlink" title="下划线的妙用"></a>下划线的妙用</h2><p>大多数情况下，下划线<code>_</code>都用于忽略函数返回值的情况。最近查看<code>authboss</code>这个开源库的代码时，发现<a href="https://github.com/volatiletech/authboss-sample/blob/c13bdabe709387b66806bf12dbe12ad71bb17d17/storer.go#L63" target="_blank" rel="noopener">这样</a>一种用法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> User &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    assertUser   = &amp;User&#123;&#125;</span><br><span class="line">    assertStorer = &amp;MemStorer&#123;&#125;</span><br><span class="line">    _ authboss.User            = assertUser</span><br><span class="line">    _ authboss.AuthableUser    = assertUser</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中<code>authboss.User</code>是一个接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetPID() (pid <span class="keyword">string</span>)</span><br><span class="line">    PutPID(pid <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里下划线的作用就是在<strong>编译时进行检查</strong>，确保<code>User</code>完全实现了<code>authboss.User</code>接口。</p><p>此外还可以在声明结构体时使用这个技巧:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    _ <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a := User&#123;"bob",20&#125;  // 这种会报错too few values in SomeSturct literal</span></span><br><span class="line">b := User&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>,<span class="string">"age"</span>:<span class="number">20</span>&#125; <span class="comment">// 通过检查</span></span><br></pre></td></tr></table></figure><p>比如当开发阶段，接口定义、结构体定义还会经常变动时可以使用这个技巧，在编译阶段就发现问题。</p><h2 id="关于errors"><a href="#关于errors" class="headerlink" title="关于errors"></a>关于errors</h2><p>使用<code>github.com/pkg/errors</code>替换原生的<code>errors</code>包，这个包有3个关键函数：</p><ol><li><code>Warp</code>用于对底层错误进行包装，添加上下文以及调用栈信息。通常建议用这个包装其他人的三方库或者标准库错误。</li><li><code>WithMessage</code>这个函数只用于对<strong>包装过</strong>的错误添加信息，注意不要重复<code>Warp</code>。</li><li><code>WithStack</code>这个函数只用于添加调用栈而不用附加额外信息的情况。</li><li><code>Cause</code>用于获取底层错误。</li></ol><p>借用个别人的<a href="https://itnext.io/golang-error-handling-best-practice-a36f47b0b94c" target="_blank" rel="noopener">例子</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.Wrap(sql.ErrNoRows, <span class="string">"foo failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.WithMessage(foo(), <span class="string">"bar failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := bar()</span><br><span class="line">   <span class="keyword">if</span> errors.Cause(err) == sql.ErrNoRows &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"data not found, %v\n"</span>, err)</span><br><span class="line">      fmt.Printf(<span class="string">"%+v\n"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// unknown error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">data not found, bar failed: foo failed: sql: no rows in result set</span></span><br><span class="line"><span class="comment">sql: no rows in result set</span></span><br><span class="line"><span class="comment">foo failed</span></span><br><span class="line"><span class="comment">main.foo</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:11</span></span><br><span class="line"><span class="comment">main.bar</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:15</span></span><br><span class="line"><span class="comment">main.main</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:19</span></span><br><span class="line"><span class="comment">runtime.main</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="优雅结束任务"><a href="#优雅结束任务" class="headerlink" title="优雅结束任务"></a>优雅结束任务</h2><p>对外提供API服务时很重要的一点就是处理完当前链接后再退出程序，这里就可以使用信号机制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gracefulStop = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(gracefulStop, syscall.SIGTERM) <span class="comment">// kill</span></span><br><span class="line">signal.Notify(gracefulStop, syscall.SIGINT) <span class="comment">// ctrl+c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是命令行</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       sig := &lt;-gracefulStop</span><br><span class="line">       <span class="comment">// 一些清理工作</span></span><br><span class="line">       os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是http server</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       sig := &lt;-gracefulStop</span><br><span class="line">       server.Shutdown(ctx)</span><br><span class="line">       <span class="comment">// 一些清理工作</span></span><br><span class="line">       os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>那么问题就是，怎么知道清理完成可以退出了呢？最简单的直接<code>sleep</code>几秒钟，但这个时间设定多久合适呢？</p><p>这里其实可以结合<code>channel</code>来实现，比如官网给的[例子](<a href="https://golang.org/pkg/net/http/#Server.Shutdown，这里就不贴代码了。" target="_blank" rel="noopener">https://golang.org/pkg/net/http/#Server.Shutdown，这里就不贴代码了。</a></p><h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><p>关于接口，如果只需要有一种实现的话就别用接口了。另外定义接口时尽量分割成小的部分，保持<code>最小知识原则LOD</code>，或者叫迪米特法则。</p><p><a href="/2020/12/16/golang小技巧/#post-footer" class="postShorten-excerpt_link link">评论和分享</a></p></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2020/09/28/集成gin和casbin/">集成go和casbin</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2020-09-28T21:32:59+08:00">9月 28, 2020 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://dev.to/maxwellhertz/tutorial-integrate-gin-with-cabsin-56m0" target="_blank" rel="noopener">原文</a>，省略了一些无关的内容。</p><p>如果你搜到这篇文章，那么什么是gin以及casbin应该不用过多解释了。</p><a href="/2020/09/28/集成gin和casbin/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/02/11/如何对Go代码解偶/">如何对Go代码解偶</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-02-11T11:05:03+08:00">2月 11, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://www.sage42.org/2019/01/30/how-to-fix-tightly-coupled-go-code/" target="_blank" rel="noopener">原文</a>，文章作者也是《Hands-On Dependency Injection in Go》的作者，向原作者表示感谢。</p><hr><p>你是否曾经由于添加某个新功能却导致另一个功能出问题？修复好这个，另一个又出问题，就好象打地鼠一般。</p><p>你是否曾经花费大量的时间调试Bug，最后却发现问题潜伏在另一个、甚至毫不相关的模块中？</p><p>这些问题都是由于高耦合引起的。</p><p>在这篇文章中，我们来使用解偶的方式来让代码更加易于理解、维护、测试。</p><a href="/2019/02/11/如何对Go代码解偶/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2018/10/12/go-get命令使用socket代理/">go get命令使用socket代理</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2018-10-12T13:57:35+08:00">10月 12, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>由于某些不可描述的原因，国内使用<code>go get</code>命令安装某些包的时候会超时导致失败，比如<code>net</code>包、<code>sys</code>包、<code>tools</code>包等。第一种解决办法就是自己从git上下载后添加链接到<code>GOPATH</code>中，比如：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/golang/net.git <span class="variable">$GOPATH</span>/src/github.com/golang/net</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/sys.git <span class="variable">$GOPATH</span>/src/github.com/golang/sys</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git <span class="variable">$GOPATH</span>/src/github.com/golang/tools</span><br><span class="line"></span><br><span class="line">ln -s <span class="variable">$GOPATH</span>/src/github.com/golang <span class="variable">$GOPATH</span>/src/golang.org/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/  &amp;&amp; mv golang x</span><br></pre></td></tr></table></figure><p></p><a href="/2018/10/12/go-get命令使用socket代理/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2018/07/30/墨卡托坐标转经纬度/">墨卡托坐标转经纬度</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2018-07-30T15:52:40+08:00">7月 30, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>今天获取百度地图数据时候发现其坐标都是类似<code>12945050.96,4826978.52</code>这种而非常见的经纬度，之前获取百度外面商家信息时就发现了这个问题但没深入研究，搜索后发现这种表示方法叫做<code>墨卡托坐标</code>。不得不说，关于坐标的标准还真是挺多的，根据经纬度查询位置可以使用<a href="http://www.gpsspg.com/maps.htm" target="_blank" rel="noopener">这个网站</a>。</p><a href="/2018/07/30/墨卡托坐标转经纬度/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2018/06/22/200行GO代码实现区块链3/">200行GO代码实现区块链3</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2018-06-22T17:35:36+08:00">6月 22, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/区块链/">区块链</a>, <a class="category-link" href="/source/all-categories/区块链/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/区块链/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-mining-algorithm-in-go-82c6a71aba1f" target="_blank" rel="noopener">原文</a>，阅读之前请先看<a href="http://www.hi-roy.com/2018/05/18/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE1/">200行GO代码实现区块链1</a> 和 <a href="http://www.hi-roy.com/2018/05/21/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE2/">200行GO代码实现区块链2</a>。</p><p>如果看到这了相信你已经知道什么是加密算法等背景了，所以忽略关于这部分的翻译，直接从编码开始。这篇文章在前两篇的文章基础上添加了工作量证明(POW)挖矿算法。</p><a href="/2018/06/22/200行GO代码实现区块链3/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2018/06/07/GO语言学习笔记-互斥锁/">GO语言学习笔记-互斥锁</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2018-06-07T17:42:11+08:00">6月 07, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://golangbot.com/mutex/" target="_blank" rel="noopener">原文</a>，互斥锁(Mutex)也是go并发系列最后一篇文章。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>在说互斥锁前，理解并发编程中的临界区(Critical section)是十分重要的。当一个程序并发执行时，共享资源不应该在同一时刻被多个goroutine修改。这段修改共享资源的代码就叫做临界区。举个例子，我们有一个代码片段用于修改变量x自增１。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x+1</span><br></pre></td></tr></table></figure><p></p><p>如果上面的代码在唯一的goroutine中执行，不会有任何问题。</p><a href="/2018/06/07/GO语言学习笔记-互斥锁/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2018/06/07/GO语言学习笔记-Select/">GO语言学习笔记-Select</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2018-06-07T16:54:28+08:00">6月 07, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://golangbot.com/select/" target="_blank" rel="noopener">原文</a></p><h2 id="什么是Select"><a href="#什么是Select" class="headerlink" title="什么是Select"></a>什么是Select</h2><p><code>select</code>语法用来从多个读／写的channel中选择一个，如果没有任何channel就绪select语句将被阻塞。如果多个就绪，则随机选择一个。语法和<code>switch</code>类似，除了case后面跟随的是channel。</p><a href="/2018/06/07/GO语言学习笔记-Select/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2018/06/04/GO语言学习笔记-缓冲区Channels和线程池/">GO语言学习笔记-缓冲区Channels和线程池</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2018-06-04T22:11:55+08:00">6月 04, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://golangbot.com/buffered-channels-worker-pools/" target="_blank" rel="noopener">原文</a>，这里为了方便理解我把worker pools翻译成线程池。</p><h2 id="什么是缓冲区Channel"><a href="#什么是缓冲区Channel" class="headerlink" title="什么是缓冲区Channel"></a>什么是缓冲区Channel</h2><p>之前讨论的所有channel都是不带缓冲区的，因此读取和写入都会被阻塞。创建一个带缓冲区的channel也是可能的，这种channel只有在缓冲区满后再写入或者读取一个空的channel时才会被阻塞。</p><p>创建一个带缓冲区的channel需要一个额外的参数容量来表明缓冲区大小：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, capacity)</span><br></pre></td></tr></table></figure><p></p><p>上面代码中的 <em>capacity</em>　需要大于０，如果等于０的话则是之前学习的无缓冲区channel。</p><a href="/2018/06/04/GO语言学习笔记-缓冲区Channels和线程池/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2018/06/04/GO语言学习笔记-Channels/">GO语言学习笔记-Channels</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2018-06-04T14:24:51+08:00">6月 04, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://golangbot.com/channels/" target="_blank" rel="noopener">原文</a>，建议先看完goroutine部分再看这篇。</p><h2 id="什么是channels"><a href="#什么是channels" class="headerlink" title="什么是channels"></a>什么是channels</h2><p>channels可以理解成是goroutine之间通信的管道，和水流从管道的一端到另一端类似，数据也可以从管道的一端发送另一端接收。</p><a href="/2018/06/04/GO语言学习笔记-Channels/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><div class="pagination-bar"><ul class="pagination"><li class="pagination-next"><a class="btn btn--default btn--small" href="/source/all-tags/go/page/2/"><span>下一页</span> <i class="fa fa-angle-right text-base icon-ml"></i></a></li><li class="pagination-number">第 1 页 共 2 页</li></ul></div></section><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2020 Roy. All Rights Reserved.</span></footer></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-remove"></i></div><img id="about-card-picture" src="/assets/images/my.jpg" alt="作者的图片"><h4 id="about-card-name">Roy</h4><div id="about-card-bio"><p>君以国士待我，我必以国士报君。</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>野生程序猿</p></div><div id="about-card-location"><i class="fa fa-map-marker"></i><br>China</div></div></div><div id="algolia-search-modal" class="modal-container"><div class="modal"><div class="modal-header"><span class="close-button"><i class="fa fa-close"></i></span> <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled"><span class="searchby-algolia-text text-color-light text-small">by</span> <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg"> </a><i class="search-icon fa fa-search"></i><form id="algolia-search-form"><input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search "></form></div><div class="modal-body"><div class="no-result text-color-light text-center">没有找到文章</div><div class="results"><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/02/12/Ubuntu下Gogant的简易破墙术/"><h3 class="media-heading">Ubuntu下Gogant的简易破墙术</h3></a><span class="media-meta"><span class="media-date text-small">2013年2月12日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/10/31/python常用第三方库-转载/"><h3 class="media-heading">Python常用第三方库(转载)</h3></a><span class="media-meta"><span class="media-date text-small">2013年10月31日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19安装ar8161网卡驱动/"><h3 class="media-heading">fedora19安装ar8161网卡驱动</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19源，rpmforge，fastestmirror/"><h3 class="media-heading">fedora19源，rpmforge，fastestmirror</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/python中如何自定义解析域名/"><h3 class="media-heading">python中如何自定义解析域名</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django版本更换/"><h3 class="media-heading">django版本更换</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django-groundwork个人1-5-3修改版/"><h3 class="media-heading">django-groundwork个人1.5.3修改版</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19美化/"><h3 class="media-heading">fedora19美化</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/装饰器/"><h3 class="media-heading">装饰器</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/SVN常用操作/"><h3 class="media-heading">SVN常用操作</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div></div></div><div class="modal-footer"><p class="results-count text-medium" data-message-zero="没有找到文章" data-message-one="找到 1 篇文章" data-message-other="找到 {n} 篇文章">找到 233 篇文章</p></div></div></div><div id="cover" style="background-image:url(/assets/images/cover.jpg)"></div><script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script><script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><script>var algoliaClient=algoliasearch("51U8PIBLP6","16909d9ce1780cda71113841864e7aa8"),algoliaIndex=algoliaClient.initIndex("my-blog")</script></body></html>