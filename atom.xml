<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi!Roy!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.hi-roy.com/"/>
  <updated>2019-10-15T03:26:00.175Z</updated>
  <id>http://www.hi-roy.com/</id>
  
  <author>
    <name>Roy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="http://www.hi-roy.com/2019/10/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/10/14/设计模式-原型模式/</id>
    <published>2019-10-14T09:58:08.000Z</published>
    <updated>2019-10-15T03:26:00.175Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式(Prototype Pattern)：使用原型实例创建指定创建对象的种类，并通过拷贝这些原型创建新对象。这个模式很好理解，就是<code>ctrl+c，ctrl+v</code>后做一些小修改。</p><p>这里面涉及一个知识点就是深拷贝和浅拷贝的问题，但我相信任何python开发人员都知道<code>copy()</code>和<code>deepcopy()</code>的区别，这里就不多说了（有兴趣的可以去看python中这2个函数的实现）。</p><p>个人理解当需要多个类对象时，如果要进行很多复杂的、消耗时间的初始化操作，而这些对象之间又仅有少量不同时，可以考虑使用原型模式。</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">food []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Cat&#123;name: <span class="string">"tom"</span>, age: <span class="number">3</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a == b) <span class="comment">// true a和b的值相同</span></span><br><span class="line">fmt.Println(&amp;b == &amp;a) <span class="comment">// false  a和b的内存地址不同</span></span><br><span class="line">b.name = <span class="string">"roy"</span></span><br><span class="line">fmt.Printf(<span class="string">"a:%v \nb:%v \n"</span>,a,b)</span><br><span class="line">fmt.Println(a == b) <span class="comment">// false a和b的值不同</span></span><br><span class="line"></span><br><span class="line">c := Dog&#123;name: <span class="string">"cola"</span>,age:<span class="number">1</span>,food:[]<span class="keyword">string</span>&#123;<span class="string">"beef"</span>,<span class="string">"chicken"</span>&#125;&#125;</span><br><span class="line">d := c</span><br><span class="line">d.food[<span class="number">0</span>] = <span class="string">"poke"</span> <span class="comment">// 修改d的food会影响到c</span></span><br><span class="line">fmt.Printf(<span class="string">"struct c.food:%p\nstruct d.food:%p\n"</span>,&amp;c.food,&amp;d.food)</span><br><span class="line">fmt.Printf(<span class="string">"struct c.food[0]:%p\nstruct d.food[0]:%p\n"</span>,&amp;c.food[<span class="number">0</span>],&amp;d.food[<span class="number">0</span>]) <span class="comment">// 从这里可以看出最终内存地址是一样的</span></span><br><span class="line"></span><br><span class="line">e := c</span><br><span class="line">e.food = <span class="built_in">append</span>(e.food,<span class="string">"poke"</span>) <span class="comment">// append方法返回了一个新对象</span></span><br><span class="line">fmt.Printf(<span class="string">"struct e.food:%p\n"</span>,&amp;e.food)</span><br><span class="line">fmt.Printf(<span class="string">"struct e.food[0]:%p\n"</span>,&amp;e.food[<span class="number">0</span>]) <span class="comment">// 这里可以看出e的第一个元素已经和c、d不一样了</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"c:%v"</span>,c)</span><br><span class="line">fmt.Printf(<span class="string">"d:%v"</span>,d)</span><br><span class="line">fmt.Printf(<span class="string">"e:%v"</span>,e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cat</code>这个类中不包含引用类型，所以直接将a赋值给b后，对b的修改不会影响a。但是<code>Dog</code>类中包含了引用类型，赋值后修改c、d任何一个的food值都会影响另一个。但是如果通过<code>append()</code>方法则是返回了一个新的slice，修改<code>e.food</code>就不会影响c和d了。</p><p>常见的引用类型：slice，pointers，maps，functions和channels，所以如果结构中包含这些将一个对象赋值给另一个对象时候要小心。</p><p>这里再多说一句关于golang中<code>new</code>，<code>make</code>创建对象的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%p\n"</span>,b,&amp;b)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%p\n"</span>,c,&amp;c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0 0 0],0x40a0f0</span><br><span class="line">&amp;[],0x40c138</span><br></pre></td></tr></table></figure><p>可以看出，<code>new</code>返回的是指针并且没有初始值，而<code>make</code>则返回的是引用而且有默认值。此外，<code>make</code>只能创建<code>slice、map、channel</code>而<code>new</code>可以用于所有类型的内存分配。</p><p>原型模式代码思路如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="built_in">copy</span> <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="built_in">copy</span>() Dog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">food []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">copy</span><span class="params">()</span> <span class="title">Dog</span></span> &#123;</span><br><span class="line">obj := d</span><br><span class="line">food := <span class="built_in">new</span>([]<span class="keyword">string</span>)</span><br><span class="line">bytes, _ := json.Marshal(d.food)</span><br><span class="line">_ = json.Unmarshal(bytes, food)</span><br><span class="line">obj.food = *food</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Dog&#123;name: <span class="string">"tom"</span>, age: <span class="number">3</span>, food: []<span class="keyword">string</span>&#123;<span class="string">"beef"</span>,<span class="string">"poke"</span>&#125;&#125;</span><br><span class="line">b := a.<span class="built_in">copy</span>()</span><br><span class="line">b.food[<span class="number">0</span>] = <span class="string">"chicken"</span></span><br><span class="line">fmt.Printf(<span class="string">"a:%v,%p,%p\n"</span>,a,&amp;a,&amp;a.food[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"b:%v,%p,%p\n"</span>,b,&amp;b,&amp;b.food[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用了<code>json</code>包里的序列化函数来模拟deepcopy仅仅为了演示，生产环境下请使用其他方法实现。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>当产生对象过程比较复杂，初始化需要许多资源时。</li><li>希望框架原型和产生对象分开时。</li><li>同一个对象可能会供其他调用者同时调用时。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型模式(Prototype Pattern)：使用原型实例创建指定创建对象的种类，并通过拷贝这些原型创建新对象。这个模式很好理解，就是&lt;code&gt;ctrl+c，ctrl+v&lt;/code&gt;后做一些小修改。&lt;/p&gt;&lt;p&gt;这里面涉及一个知识点就是深拷贝和浅拷贝的问题，但我相信任何python开发人员都知道&lt;code&gt;copy()&lt;/code&gt;和&lt;code&gt;deepcopy()&lt;/code&gt;的区别，这里就不多说了（有兴趣的可以去看python中这2个函数的实现）。&lt;/p&gt;&lt;p&gt;个人理解当需要多个类对象时，如果要进行很多复杂的、消耗时间的初始化操作，而这些对象之间又仅有少量不同时，可以考虑使用原型模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://www.hi-roy.com/2019/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/10/12/设计模式-建造者模式/</id>
    <published>2019-10-12T08:58:08.000Z</published>
    <updated>2019-10-12T09:23:24.646Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式(Builder Pattern)：将复杂对象的创建和表示分离，使同样的构建过程可以创建不同的表示。</p><p>进一步说，建造者隐藏了产品是如何组装的，使建造代码和表示代码分离。建造对象时 <strong>构件顺序稳定</strong> 的情况下，不管每一步具体怎么变都可以适用。</p><p>简单说，建造者模式将需要一系列动作才能完成的事固化下来，并定义了一个Director给客户端使用。还是很抽象的话，想想如何把大象装进冰箱：</p><ol><li>打开冰箱门</li><li>把大象装进去</li><li>关上冰箱门</li></ol><p>这个步骤比较简单，但如果细化一下：买冰箱、接通电源、买大象、清洗大象……很可能就会有300个步骤。建造者模式则提供了一系列行为的集合，保证以后有把山羊装进冰箱这样的需求时候不会遗漏某个步骤（想想KFC、麦当劳生产食品的步骤，其实是建造者模式不错的例子）。</p><a id="more"></a><p>代码实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把xx装进冰箱</span></span><br><span class="line"><span class="keyword">type</span> inFridge <span class="keyword">interface</span> &#123;</span><br><span class="line">openDoor()</span><br><span class="line">putInFridge()</span><br><span class="line">closeDoor()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> meat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m meat)</span> <span class="title">openDoor</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"Open the Door!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m meat)</span> <span class="title">closeDoor</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"Close the Door!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pig <span class="keyword">struct</span> &#123;</span><br><span class="line">meat</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pig)</span> <span class="title">putInFridge</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Put %s in fridge \n"</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chicken <span class="keyword">struct</span> &#123;</span><br><span class="line">meat</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c chicken)</span> <span class="title">putInFridge</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Kill the %s \n"</span>,c.name)</span><br><span class="line">fmt.Printf(<span class="string">"Put %s in fridge \n"</span>,c.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> director <span class="keyword">struct</span> &#123;</span><br><span class="line">i inFridge</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d director)</span> <span class="title">createMeat</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.i.openDoor()</span><br><span class="line">d.i.putInFridge()</span><br><span class="line">d.i.closeDoor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := pig&#123;meat:meat&#123;name:<span class="string">"pig"</span>&#125;&#125;</span><br><span class="line">c := chicken&#123;meat:meat&#123;name:<span class="string">"chicken"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">d := director&#123;i:p&#125;</span><br><span class="line">d.createMeat()</span><br><span class="line"></span><br><span class="line">d2 := director&#123;i:c&#125;</span><br><span class="line">d2.createMeat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，定义了<code>meat</code>基类和<code>inFridge</code>接口，并在<code>pig</code>以及<code>chicken</code>实现。把猪肉放进冰箱和把鸡肉放进冰箱步骤是一样的，而放鸡肉时候要多进行一步“杀鸡”，所以使用建造者模式时，到底将步骤抽象提取出多少步则是需要权衡的。然后客户端通过使用<code>director</code>来创建产品(这里我偷懒了，并没返回冻肉这个产品，而仅仅是输出)，无需关心具体实现步骤，实现代码解耦。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>当生成的对象内部结构复杂时（需要很多步骤时）</li><li>需要向客户隐藏产品内部实现步骤时</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建造者模式(Builder Pattern)：将复杂对象的创建和表示分离，使同样的构建过程可以创建不同的表示。&lt;/p&gt;&lt;p&gt;进一步说，建造者隐藏了产品是如何组装的，使建造代码和表示代码分离。建造对象时 &lt;strong&gt;构件顺序稳定&lt;/strong&gt; 的情况下，不管每一步具体怎么变都可以适用。&lt;/p&gt;&lt;p&gt;简单说，建造者模式将需要一系列动作才能完成的事固化下来，并定义了一个Director给客户端使用。还是很抽象的话，想想如何把大象装进冰箱：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;打开冰箱门&lt;/li&gt;&lt;li&gt;把大象装进去&lt;/li&gt;&lt;li&gt;关上冰箱门&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个步骤比较简单，但如果细化一下：买冰箱、接通电源、买大象、清洗大象……很可能就会有300个步骤。建造者模式则提供了一系列行为的集合，保证以后有把山羊装进冰箱这样的需求时候不会遗漏某个步骤（想想KFC、麦当劳生产食品的步骤，其实是建造者模式不错的例子）。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://www.hi-roy.com/2019/10/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/10/09/设计模式-工厂模式/</id>
    <published>2019-10-09T08:58:08.000Z</published>
    <updated>2019-10-14T06:52:41.350Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式又可以分为工厂方法模式和抽象工厂模式。</p><h2 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式(Factory Method Pattern)"></a>工厂方法模式(Factory Method Pattern)</h2><p>工厂模式是指：定义一个接口用户创建对象，让子类决定实例化哪一个类。</p><p>工厂模式中存在4个角色：</p><ol><li>抽象工厂</li><li>具体工厂</li><li>抽象产品</li><li>具体产品</li></ol><p><strong>抽象工厂产生抽象产品，具体工厂生产具体产品。</strong> 这句话很重要，理解了这句话就理解了工厂方法模式。</p><a id="more"></a><p>看定义还是略微抽象，这里我们以客户购买汽水为例，初学编程的人很有可能出现类似下面的代码段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line"><span class="keyword">if</span> require == <span class="string">"cola"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is cola"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> require == <span class="string">"sprite"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is sprite"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> require == <span class="string">"fanta"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is fanta"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"What you want?"</span>)        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很好理解，用户输入他想要购买的汽水，然后程序返回他的选择，如果用户输入的不在上述3个选择内就报错<code>What you want?</code>。但基本上没有可维护性、扩展性，也不能方便的进行复用。为了实现高内聚低耦合的目标，我们做一些修改：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> showname <span class="keyword">interface</span> &#123;</span><br><span class="line">    show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cola <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is cola"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sprite <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is sprite"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fanta <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is fanta"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> factory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e factory)</span> <span class="title">showname</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">showname</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> name &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cola"</span>:</span><br><span class="line"><span class="keyword">return</span> cola&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sprite"</span>:</span><br><span class="line"><span class="keyword">return</span> sprite&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"fanta"</span>:</span><br><span class="line"><span class="keyword">return</span> fanta&#123;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"What you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line">fac := factory&#123;&#125;</span><br><span class="line">fac.showname(require).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于golang中没有类、继承相关的概念，所以这里使用struct和interface来实现。采用上面这种修改后，看上去更复杂了，但却提高了代码的复用率。如果以后有其他地方也要用到这个功能，直接调用factory即可，而不是把那堆<code>if...else</code>复制过去。这种写法还有个学名叫做 <strong>简单工厂模式</strong> ，这个模式优点是工厂类中包含了逻辑判断，根据调用方传入的参数动态实例化相关的类，如果需要修改功能不需要修改调用方的代码。但问题也在这里，如果要新增一个类，那么是要修改<code>case</code>分支条件的，修改原有的类<strong>违反了开闭原则</strong>,这时候就该工厂方法模式出场了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">type</span> showFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">info() saleinfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">type</span> showColaFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s showColaFactory)</span> <span class="title">info</span><span class="params">()</span> <span class="title">saleinfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cola&#123;soda:soda&#123;name:<span class="string">"cola"</span>,price:<span class="number">5</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">type</span> showSpriteFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s showSpriteFactory)</span> <span class="title">info</span><span class="params">()</span> <span class="title">saleinfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cola&#123;soda:soda&#123;name:<span class="string">"sprite"</span>,price:<span class="number">5</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">type</span> showFantaFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s showFantaFactory)</span> <span class="title">info</span><span class="params">()</span> <span class="title">saleinfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fanta&#123;soda:soda&#123;name:<span class="string">"fanta"</span>,price:<span class="number">5</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">type</span> saleinfo <span class="keyword">interface</span> &#123;</span><br><span class="line">getname()</span><br><span class="line">getprice()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> soda <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品</span></span><br><span class="line"><span class="keyword">type</span> cola <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">getname</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s"</span>, e.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">getprice</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"price is %d"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品</span></span><br><span class="line"><span class="keyword">type</span> sprite <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">getname</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s"</span>, e.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">getprice</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"price is %d"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品</span></span><br><span class="line"><span class="keyword">type</span> fanta <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">getname</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s"</span>, e.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">getprice</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"price is %d"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line"><span class="keyword">var</span> s saleinfo</span><br><span class="line"><span class="keyword">switch</span> require &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cola"</span>:</span><br><span class="line">s = showColaFactory&#123;&#125;.info()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sprite"</span>:</span><br><span class="line">s = showSpriteFactory&#123;&#125;.info()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"fanta"</span>:</span><br><span class="line">s = showFantaFactory&#123;&#125;.info()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"what you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.getname()</span><br><span class="line">s.getprice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WoW，代码更复杂了，但这样修改后，如果以后需要新增一个新的<code>juice</code>，只需新增相关的具体工厂和具体产品即可，不用修改原来的工厂类，符合了开闭原则。不过，这种方法把判断逻辑又丢给了调用方，有没有什么办法更进一步呢？答案就是抽象工厂模式，这个下面再说。</p><h3 id="工厂方法模式应用场景"><a href="#工厂方法模式应用场景" class="headerlink" title="工厂方法模式应用场景"></a>工厂方法模式应用场景</h3><ol><li>当子类型有很多，以后需要不断添加不同子类实现时。</li><li>一个系统在框架设计阶段，还不知道将来需要实例化哪些具体子类时。</li><li>系统设计之初不需要具体对象的概念或没有具体对象的概念。</li></ol><h2 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式(Abstract Factory Pattern)"></a>抽象工厂模式(Abstract Factory Pattern)</h2><p>抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体实现类。</p><p>进一步说，抽象工厂模式中调用方使用抽象接口来创建一组相关产品，实现了与工厂类的解耦。我们将卖汽水的例子复杂化一点，可以在汽水中加冰，那么用抽象工厂模式写法就变成了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象汽水基类</span></span><br><span class="line"><span class="keyword">type</span> soda <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sodaInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">buy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象可乐基类，继承soda并实现sodaInfo接口</span></span><br><span class="line"><span class="keyword">type</span> cola <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">buy</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s \n"</span>, e.name)</span><br><span class="line">fmt.Printf(<span class="string">"price is %d \n"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体可乐类，加冰</span></span><br><span class="line"><span class="keyword">type</span> colaIce <span class="keyword">struct</span> &#123;</span><br><span class="line">cola</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象雪碧基类，继承soda并实现sodaInfo接口</span></span><br><span class="line"><span class="keyword">type</span> sprite <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">buy</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s \n"</span>, e.name)</span><br><span class="line">fmt.Printf(<span class="string">"price is %d \n"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体雪碧类，加冰</span></span><br><span class="line"><span class="keyword">type</span> spriteIce <span class="keyword">struct</span> &#123;</span><br><span class="line">sprite</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象芬达基类，继承soda并实现sodaInfo接口</span></span><br><span class="line"><span class="keyword">type</span> fanta <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">buy</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s \n"</span>, e.name)</span><br><span class="line">fmt.Printf(<span class="string">"price is %d \n"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体芬达类，加冰</span></span><br><span class="line"><span class="keyword">type</span> fantaIce <span class="keyword">struct</span> &#123;</span><br><span class="line">fanta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象汽水工厂，注意里面都是生产抽象汽水</span></span><br><span class="line"><span class="keyword">type</span> sodaAbsFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">createCola() sodaInfo</span><br><span class="line">createSprite() sodaInfo</span><br><span class="line">createFanta() sodaInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体汽水工厂，生产具体汽水，实现抽象汽水工厂接口</span></span><br><span class="line"><span class="keyword">type</span> sodaFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sodaFactory)</span> <span class="title">createCola</span><span class="params">()</span> <span class="title">sodaInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> colaIce&#123;</span><br><span class="line">cola:cola&#123;</span><br><span class="line">soda:soda&#123;name:<span class="string">"cola_with_ice"</span>,price: <span class="number">10</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sodaFactory)</span> <span class="title">createSprite</span><span class="params">()</span> <span class="title">sodaInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> colaIce&#123;</span><br><span class="line">cola:cola&#123;</span><br><span class="line">soda:soda&#123;name:<span class="string">"sprice_with_ice"</span>,price: <span class="number">12</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sodaFactory)</span> <span class="title">createFanta</span><span class="params">()</span> <span class="title">sodaInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> colaIce&#123;</span><br><span class="line">cola:cola&#123;</span><br><span class="line">soda:soda&#123;name:<span class="string">"fanta_with_ice"</span>,price: <span class="number">8</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者类，需要买汽水时候向汽水工厂请求</span></span><br><span class="line"><span class="keyword">type</span> customer <span class="keyword">struct</span> &#123;</span><br><span class="line">sodafac sodaAbsFactory</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customer)</span> <span class="title">Buycola</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.sodafac.createCola().buy()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customer)</span> <span class="title">Buysprite</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.sodafac.createSprite().buy()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customer)</span> <span class="title">Buyfanta</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.sodafac.createFanta().buy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := customer&#123;sodafac: sodaFactory&#123;&#125;&#125; <span class="comment">// 创建消费者，并把汽水工厂传递进去</span></span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line"><span class="keyword">switch</span> require &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cola"</span>:</span><br><span class="line">c.buyCola()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sprite"</span>:</span><br><span class="line">c.buySprite()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"fanta"</span>:</span><br><span class="line">c.buyFanta()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"what you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎更更更复杂了，但假设突然需要更换另一家卖汽水的，调用方仅仅修改创建消费者那行代码就可以了。（这里别陷入误区：改1行代码和改100行代码可不是一回事，减少修改!=不修改。）至于判断逻辑的问题，可以使用反射来解决：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line">methodName := fmt.Sprintf(<span class="string">"Buy%s"</span>,require)</span><br><span class="line">c := customer&#123;sodafac: sodaFactory&#123;&#125;&#125; <span class="comment">// 创建消费者，并把汽水工厂传递进去</span></span><br><span class="line">getValue := reflect.ValueOf(c)</span><br><span class="line">methodValue := getValue.MethodByName(methodName) <span class="comment">// 注意所有的函数名都要大写开头，否则reflect找不到对应的函数会报错！</span></span><br><span class="line"><span class="keyword">if</span> methodValue.String() != <span class="string">"&lt;invalid Value&gt;"</span> &#123;</span><br><span class="line">    args := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>)</span><br><span class="line">    methodValue.Call(args)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"what you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>千万注意使用反射机制来调用函数时候的名称问题，非大写字母开头的函数<code>MethodbyName</code>是找不到的。虽然使用反射可以解决判断逻辑的问题，但是要不要在项目中这么使用则是见仁见智了。另外补充一句，这个反射行为在python中使用使用<code>getattr()</code>即可实现，或许这也是使用python时候并没怎么想到设计模式的原因之一吧。</p><h3 id="抽象工厂模式应用场景"><a href="#抽象工厂模式应用场景" class="headerlink" title="抽象工厂模式应用场景"></a>抽象工厂模式应用场景</h3><ol><li>创建产品家族，相关产品集合在一起使用的时候。</li><li>提供一个产品类库，并只想显示其接口而不是实现的时候。</li><li>通过组合的方使使用工厂时。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>工厂方法模式通过继承的方式来解耦，抽象工厂模式则通过组合的方式实现解耦。</li><li>工厂方法模式用来创建一个抽象产品，具体工厂实现工厂方法来创建具体产品，抽象工厂模式用组合来创建一个产品家族的抽象类型。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式又可以分为工厂方法模式和抽象工厂模式。&lt;/p&gt;&lt;h2 id=&quot;工厂方法模式-Factory-Method-Pattern&quot;&gt;&lt;a href=&quot;#工厂方法模式-Factory-Method-Pattern&quot; class=&quot;headerlink&quot; title=&quot;工厂方法模式(Factory Method Pattern)&quot;&gt;&lt;/a&gt;工厂方法模式(Factory Method Pattern)&lt;/h2&gt;&lt;p&gt;工厂模式是指：定义一个接口用户创建对象，让子类决定实例化哪一个类。&lt;/p&gt;&lt;p&gt;工厂模式中存在4个角色：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;抽象工厂&lt;/li&gt;&lt;li&gt;具体工厂&lt;/li&gt;&lt;li&gt;抽象产品&lt;/li&gt;&lt;li&gt;具体产品&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;抽象工厂产生抽象产品，具体工厂生产具体产品。&lt;/strong&gt; 这句话很重要，理解了这句话就理解了工厂方法模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-总览</title>
    <link href="http://www.hi-roy.com/2019/10/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/"/>
    <id>http://www.hi-roy.com/2019/10/08/设计模式-总览/</id>
    <published>2019-10-08T08:58:08.000Z</published>
    <updated>2019-10-09T09:32:09.233Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前，忘记从哪看到一句话——设计模式是对编程语言缺陷的弥补。</p><p>年轻的我并没意识到这句话背后的真实含义以及所处语境，外加之后主要开发语言是Python这个动态语言，设计模式真的没怎么用到——比如装饰模式不就是Python中的装饰器嘛，一个语法糖能解决的事居然还弄出个模式来？</p><p>直到我开始学习openstack的源码，发现里面用到了大量的设计模式，才明白自己是多么无知可笑。</p><p>这里借用一位大佬的话：</p><blockquote><p>如果你觉得设计模式在某程度上没用，说明两个问题：<br>1.你的系统还不足以复杂到要用设计模式的程度<br>2.你的经验还没强到能熟练应用设计模式的程度。</p></blockquote><p>能找到这篇文章的，应该都知道面向过程、面向对象、封装继承多态、高内聚低耦合（包含程序级别以及架构级别）、开闭原则(对扩展开放、对修改关闭)、依赖倒置原则(尽量使用抽象类型作为对象实例变量类型，用于实现开闭原则)、单一责任原则(一个模块只负责一个功能)等一堆的名词，以及“组合优于继承”(这里略有争议，我个人对此赞同，最近看一些继承过多的代码总是要向上找好几层父类，还要仔细看子类中有没有重写父类方法，术语叫做类膨胀)。</p><a id="more"></a><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>设计模式(Design Pattern)简单说就是经验的总结，大佬们将其分为了23种。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>通过使用设计模式来提高软件质量，降低开发人员之间的沟通成本。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>先学基础，知道每种设计模式的优缺点以及应用场景，然后灵活应用。</p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>《软件秘籍——设计模式那点事》这本书将设计模式分为了三类：</p><ol><li>创建型<ul><li>工厂方法模式(Factory Method Pattern)</li><li>抽象工厂模式(Abstract Factory Pattern)</li><li>建造者模式(Builder Pattern)</li><li>原型模式(Prototype Pattern)</li><li>单例模式(Singleton Pattern)</li></ul></li><li>结构型<ul><li>适配器模式(Adapter Pattern)</li><li>桥接模式(Bridge Pattern)</li><li>组合模式(Composite Pattern)</li><li>装饰者模式(Decorator Pattern)</li><li>外观模式(Facade Pattern)</li><li>享元模式(Flyweight Pattern)</li><li>代理模式(Proxy Pattern)</li></ul></li><li>行为型<ul><li>责任链模式(Chain of Responsibility Pattern)</li><li>命令模式(Command Pattern)</li><li>解释器模式(Interpreter Pattern)</li><li>迭代器模式(Iterator Pattern)</li><li>中介者模式(Mediator Pattern)</li><li>备忘录模式(Memento Pattern)</li><li>观察者模式(Observer Pattern)</li><li>状态模式(State Pattern)</li><li>策略模式(Strategy Pattern)</li><li>模板方法模式(Template Method Pattern)</li><li>访问者模式(Visitor Pattern)</li></ul></li></ol><blockquote><p>学习设计模式不是目的，真正的目的是学习这种思想，并在实践中应用，学会归纳和总结。</p></blockquote><p>另外这本书是一本被书名耽误了的书，我个人是以这本书为主要脉络，结合《大话设计模式》来进行复习，有兴趣的小伙伴可以翻翻这2本书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久很久以前，忘记从哪看到一句话——设计模式是对编程语言缺陷的弥补。&lt;/p&gt;&lt;p&gt;年轻的我并没意识到这句话背后的真实含义以及所处语境，外加之后主要开发语言是Python这个动态语言，设计模式真的没怎么用到——比如装饰模式不就是Python中的装饰器嘛，一个语法糖能解决的事居然还弄出个模式来？&lt;/p&gt;&lt;p&gt;直到我开始学习openstack的源码，发现里面用到了大量的设计模式，才明白自己是多么无知可笑。&lt;/p&gt;&lt;p&gt;这里借用一位大佬的话：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果你觉得设计模式在某程度上没用，说明两个问题：&lt;br&gt;1.你的系统还不足以复杂到要用设计模式的程度&lt;br&gt;2.你的经验还没强到能熟练应用设计模式的程度。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;能找到这篇文章的，应该都知道面向过程、面向对象、封装继承多态、高内聚低耦合（包含程序级别以及架构级别）、开闭原则(对扩展开放、对修改关闭)、依赖倒置原则(尽量使用抽象类型作为对象实例变量类型，用于实现开闭原则)、单一责任原则(一个模块只负责一个功能)等一堆的名词，以及“组合优于继承”(这里略有争议，我个人对此赞同，最近看一些继承过多的代码总是要向上找好几层父类，还要仔细看子类中有没有重写父类方法，术语叫做类膨胀)。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码学习笔记2</title>
    <link href="http://www.hi-roy.com/2019/09/18/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://www.hi-roy.com/2019/09/18/OpenStack源码学习笔记2/</id>
    <published>2019-09-18T04:46:29.000Z</published>
    <updated>2019-09-18T11:04:59.410Z</updated>
    
    <content type="html"><![CDATA[<p>上次学习了Nova创建虚拟机的过程，这次来看一下Glance是如何上传镜像的。相比于Nova，Glance源码使用了大量的代理模式和装饰器模式，阅读代码时候一个不仔细就会一脸懵X。根据上次说的Openstack套路，我们通过<code>setup.cfg</code>直奔主题——<code>glance/cmd/api.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        config.parse_args()</span><br><span class="line">        config.set_config_defaults()</span><br><span class="line">        wsgi.set_eventlet_hub()</span><br><span class="line">        logging.setup(CONF, <span class="string">'glance'</span>)</span><br><span class="line">        notifier.set_defaults()</span><br><span class="line">        <span class="keyword">if</span> cfg.CONF.profiler.enabled:</span><br><span class="line">            _notifier = osprofiler.notifier.create(<span class="string">"Messaging"</span>,</span><br><span class="line">                                                   oslo_messaging, &#123;&#125;,</span><br><span class="line">                                                   notifier.get_transport(),</span><br><span class="line">                                                   <span class="string">"glance"</span>, <span class="string">"api"</span>,</span><br><span class="line">                                                   cfg.CONF.bind_host)</span><br><span class="line">            osprofiler.notifier.set(_notifier)</span><br><span class="line">            osprofiler.web.enable(cfg.CONF.profiler.hmac_keys)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            osprofiler.web.disable()</span><br><span class="line">        server = wsgi.Server(initialize_glance_store=<span class="literal">True</span>)</span><br><span class="line">        server.start(config.load_paste_app(<span class="string">'glance-api'</span>), default_port=<span class="number">9292</span>)</span><br><span class="line">        server.wait()</span><br><span class="line">    <span class="keyword">except</span> KNOWN_EXCEPTIONS <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        fail(e)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="配置加载与路由绑定"><a href="#配置加载与路由绑定" class="headerlink" title="配置加载与路由绑定"></a>配置加载与路由绑定</h2><p>和Nova一样，这个文件主要作用就是加载配置、创建WSGI Server并运行，这里我们注意一下<code>initialize_glance_store=True</code>这里，新版中关于存储的部分已经独立出项目叫做<a href="https://github.com/openstack/glance_store" target="_blank" rel="noopener">glance_store</a>，这里还对这部分进行了初始化，我们跟进<code>glance/common/wsgi.py</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_glance_store</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Initialize glance store."""</span></span><br><span class="line">    glance_store.register_opts(CONF)</span><br><span class="line">    glance_store.create_stores(CONF)</span><br><span class="line">    glance_store.verify_default_store()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span><span class="params">(object)</span>:</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threads=<span class="number">1000</span>, initialize_glance_store=False)</span>:</span></span><br><span class="line">        ......    </span><br><span class="line">        self.initialize_glance_store = initialize_glance_store</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self, application, default_port)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line">        self.default_port = default_port</span><br><span class="line">        self.configure()</span><br><span class="line">        self.start_wsgi()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(self, old_conf=None, has_changed=None)</span>:</span></span><br><span class="line">        eventlet.wsgi.MAX_HEADER_LINE = CONF.max_header_line</span><br><span class="line">        self.client_socket_timeout = CONF.client_socket_timeout <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line">        self.configure_socket(old_conf, has_changed)</span><br><span class="line">        <span class="keyword">if</span> self.initialize_glance_store:</span><br><span class="line">            initialize_glance_store()</span><br></pre></td></tr></table></figure><p>这里我们跟进<code>glance_store/backend.py</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_stores</span><span class="params">(conf=CONF)</span>:</span></span><br><span class="line">    store_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (store_entry, store_instance) <span class="keyword">in</span> _load_stores(conf):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            schemes = store_instance.get_schemes()</span><br><span class="line">            store_instance.configure(re_raise_bsc=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">except</span> NotImplementedError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> schemes:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.BackendException(<span class="string">'Unable to register store %s. '</span></span><br><span class="line">                                              <span class="string">'No schemes associated with it.'</span></span><br><span class="line">                                              % store_entry)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            LOG.debug(<span class="string">"Registering store %s with schemes %s"</span>,</span><br><span class="line">                      store_entry, schemes)</span><br><span class="line">            scheme_map = &#123;&#125;</span><br><span class="line">            loc_cls = store_instance.get_store_location_class()</span><br><span class="line">            <span class="keyword">for</span> scheme <span class="keyword">in</span> schemes:</span><br><span class="line">                scheme_map[scheme] = &#123;</span><br><span class="line">                    <span class="string">'store'</span>: store_instance,</span><br><span class="line">                    <span class="string">'location_class'</span>: loc_cls,</span><br><span class="line">                    <span class="string">'store_entry'</span>: store_entry</span><br><span class="line">                &#125;</span><br><span class="line">            location.register_scheme_map(scheme_map)</span><br><span class="line">            store_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> store_count</span><br></pre></td></tr></table></figure><p>在这里会根据<code>/etc/glance/glance_api.conf</code>中的配置信息找到对应的driver(位于<code>glance_store/_drivers</code>目录)并配置，然后调用<code>register_scheme_map()</code>进行绑定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SCHEME_TO_CLS_MAP = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_scheme_map</span><span class="params">(scheme_map)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> (k, v) <span class="keyword">in</span> scheme_map.items():</span><br><span class="line">        LOG.debug(<span class="string">"Registering scheme %s with %s"</span>, k, v)</span><br><span class="line">        SCHEME_TO_CLS_MAP[k] = v</span><br></pre></td></tr></table></figure><p>这样就完成了所需的准备工作。</p><h2 id="镜像上传"><a href="#镜像上传" class="headerlink" title="镜像上传"></a>镜像上传</h2><p>glance镜像上传分为2个步骤，首先在数据库中创建一条记录，并返回相关信息，此时使用<code>glance image-list</code>命令可以查看到一个空镜像，状态为<code>queued</code>。然后再上传镜像数据，上传完成后进入<code>active</code>状态，代码均来源于rocky版。</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>根据<a href="https://docs.openstack.org/api-ref/image/v2/index.html?expanded=create-image-detail#create-image" target="_blank" rel="noopener">文档</a>创建镜像是向<code>/v2/images</code>发送POST请求，然后再结合<code>glance-api-paste.ini</code>中的定义：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[pipeline:glance-api]</span></span><br><span class="line"><span class="attr">pipeline</span> = cors healthcheck http_proxy_to_wsgi versionnegotiation osprofiler unauthenticated-context rootapp</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:rootapp]</span></span><br><span class="line"><span class="attr">paste.composite_factory</span> = glance.api:root_app_factory</span><br><span class="line">/: apiversions</span><br><span class="line">/v1: apiv1app</span><br><span class="line">/v2: apiv2app</span><br><span class="line"></span><br><span class="line"><span class="section">[app:apiversions]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = glance.api.versions:create_resource</span><br><span class="line"></span><br><span class="line"><span class="section">[app:apiv1app]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = glance.api.v1.router:API.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[app:apiv2app]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = glance.api.v2.router:API.factory</span><br></pre></td></tr></table></figure><p>根据<code>glance/api/v2/router.py</code>中的<code>API()</code>定义，找到实际处理post请求的函数为<code>glance/api/v2/images.py</code>中的<code>ImagesController</code>类的<code>create</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, req, image, extra_properties, tags)</span>:</span></span><br><span class="line">        image_factory = self.gateway.get_image_factory(req.context)</span><br><span class="line">        image_repo = self.gateway.get_repo(req.context)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            image = image_factory.new_image(extra_properties=extra_properties,</span><br><span class="line">                                            tags=tags, **image)</span><br><span class="line">            image_repo.add(image)</span><br><span class="line">        <span class="keyword">except</span> (exception.DuplicateLocation,</span><br><span class="line">                exception.Invalid) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPBadRequest(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> (exception.ReservedProperty,</span><br><span class="line">                exception.ReadonlyProperty) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPForbidden(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> exception.Forbidden <span class="keyword">as</span> e:</span><br><span class="line">            LOG.debug(<span class="string">"User not permitted to create image"</span>)</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPForbidden(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> exception.LimitExceeded <span class="keyword">as</span> e:</span><br><span class="line">            LOG.warn(encodeutils.exception_to_unicode(e))</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPRequestEntityTooLarge(</span><br><span class="line">                explanation=e.msg, request=req, content_type=<span class="string">'text/plain'</span>)</span><br><span class="line">        <span class="keyword">except</span> exception.Duplicate <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPConflict(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> exception.NotAuthenticated <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPUnauthorized(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">            LOG.debug(encodeutils.exception_to_unicode(e))</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPBadRequest(explanation=e)</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><p>这段代码看上简单，实际内含玄机，如果跟进<code>gateway.get_image_factory</code>和<code>gateway.get_repo</code>函数，会发现作者用了大量的装饰器模式和代理模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glance/gateway.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_image_factory</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    image_factory = glance.domain.ImageFactory()</span><br><span class="line">    store_image_factory = glance.location.ImageFactoryProxy(</span><br><span class="line">        image_factory, context, self.store_api, self.store_utils)</span><br><span class="line">    quota_image_factory = glance.quota.ImageFactoryProxy(</span><br><span class="line">        store_image_factory, context, self.db_api, self.store_utils)</span><br><span class="line">    policy_image_factory = policy.ImageFactoryProxy(</span><br><span class="line">        quota_image_factory, context, self.policy)</span><br><span class="line">    notifier_image_factory = glance.notifier.ImageFactoryProxy(</span><br><span class="line">        policy_image_factory, context, self.notifier)</span><br><span class="line">    <span class="keyword">if</span> property_utils.is_property_protection_enabled():</span><br><span class="line">        property_rules = property_utils.PropertyRules(self.policy)</span><br><span class="line">        pif = property_protections.ProtectedImageFactoryProxy(</span><br><span class="line">            notifier_image_factory, context, property_rules)</span><br><span class="line">        authorized_image_factory = authorization.ImageFactoryProxy(</span><br><span class="line">            pif, context)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        authorized_image_factory = authorization.ImageFactoryProxy(</span><br><span class="line">            notifier_image_factory, context)</span><br><span class="line">    <span class="keyword">return</span> authorized_image_factory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_repo</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    image_repo = glance.db.ImageRepo(context, self.db_api)</span><br><span class="line">    store_image_repo = glance.location.ImageRepoProxy(</span><br><span class="line">        image_repo, context, self.store_api, self.store_utils)</span><br><span class="line">    quota_image_repo = glance.quota.ImageRepoProxy(</span><br><span class="line">        store_image_repo, context, self.db_api, self.store_utils)</span><br><span class="line">    policy_image_repo = policy.ImageRepoProxy(</span><br><span class="line">        quota_image_repo, context, self.policy)</span><br><span class="line">    notifier_image_repo = glance.notifier.ImageRepoProxy(</span><br><span class="line">        policy_image_repo, context, self.notifier)</span><br><span class="line">    <span class="keyword">if</span> property_utils.is_property_protection_enabled():</span><br><span class="line">        property_rules = property_utils.PropertyRules(self.policy)</span><br><span class="line">        pir = property_protections.ProtectedImageRepoProxy(</span><br><span class="line">            notifier_image_repo, context, property_rules)</span><br><span class="line">        authorized_image_repo = authorization.ImageRepoProxy(</span><br><span class="line">            pir, context)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        authorized_image_repo = authorization.ImageRepoProxy(</span><br><span class="line">            notifier_image_repo, context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> authorized_image_repo</span><br></pre></td></tr></table></figure><p>阅读这里的时候一个不仔细逻辑就断了，要像剥洋葱一样，一层一层剥开它的心。这里我就不记录追踪细节了，经过一层层判断后，<code>image_factory.new_image</code>函数最终进入<code>glance/domain/__init__.py</code>中并返回了一个<code>Image</code>类型实例。</p><p>然后将这个实例传递给<code>image_repo.add</code>函数，这个函数再经过一层层判断，进入<code>glance/db/__init__.py</code>中调用<code>ImageRepo</code>的<code>add()</code>方法，在这个方法中最终调用了<code>glance/db/sqlalchemy/api.py</code>中的<code>image_create()</code>函数来在数据库中创建新记录。</p><p>如果没有发生错误，则返回创建的空镜像信息给客户端。</p><h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><p><a href="https://docs.openstack.org/api-ref/image/v2/?expanded=upload-binary-image-data-detail#upload-binary-image-data" target="_blank" rel="noopener">文档</a>中定义，上传数据行为是向<code>/v2/images/{image_id}/file</code>发送PUT请求，实际处理函数为<code>glance/api/v2/image_data.py</code>中的<code>ImageDataController</code>类的<code>upload</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">@utils.mutating</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(self, req, image_id, data, size)</span>:</span></span><br><span class="line">    backend = <span class="literal">None</span></span><br><span class="line">    image_repo = self.gateway.get_repo(req.context)</span><br><span class="line">    image = <span class="literal">None</span></span><br><span class="line">    refresher = <span class="literal">None</span></span><br><span class="line">    cxt = req.context</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.policy.enforce(cxt, <span class="string">'upload_image'</span>, &#123;&#125;)</span><br><span class="line">        image = image_repo.get(image_id)</span><br><span class="line">        image.status = <span class="string">'saving'</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            image_repo.save(image, from_state=<span class="string">'queued'</span>)</span><br><span class="line">            image.set_data(data, size, backend=backend)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                image_repo.save(image, from_state=<span class="string">'saving'</span>)</span><br><span class="line">            <span class="keyword">except</span> exception.NotAuthenticated:</span><br><span class="line">                <span class="keyword">if</span> refresher <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># request a new token to update an image in database</span></span><br><span class="line">                    cxt.auth_token = refresher.refresh_token()</span><br><span class="line">                    image_repo = self.gateway.get_repo(req.context)</span><br><span class="line">                    image_repo.save(image, from_state=<span class="string">'saving'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>新版本中glance已经可以支持多后端的配置，但还不是稳定版。这里以单后端为例，首先将状态改为saving，然后调用<code>set_data</code>函数。由于某些不可描述的原因，我没法启动程序进行单步调试，只能使用IDE的跳转功能，结果这里兜兜转转饶了很久。这里我就直接给出答案吧，最终调用的是<code>glance/location.py</code>的<code>ImageProxy</code>类中的方法。这里面的关键点在于image其实是由<code>ImageProxy</code>实例代理的，转换发生在初始化对象时候创建的<code>Helper</code>类，这个类有一个<code>proxy</code>方法用来将原始<code>Image</code>类型转换成<code>ImageProxy</code>类型。这里具体就不再详细说明了，回到<code>set_data</code>函数定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_data</span><span class="params">(self, data, size=None, backend=None)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    hashing_algo = CONF[<span class="string">'hashing_algorithm'</span>]</span><br><span class="line">    <span class="keyword">if</span> CONF.enabled_backends:</span><br><span class="line">        (location, size, checksum,</span><br><span class="line">            multihash, loc_meta) = self.store_api.add_with_multihash(</span><br><span class="line">            CONF,</span><br><span class="line">            self.image.image_id,</span><br><span class="line">            utils.LimitingReader(utils.CooperativeReader(data),</span><br><span class="line">                                    CONF.image_size_cap),</span><br><span class="line">            size,</span><br><span class="line">            backend,</span><br><span class="line">            hashing_algo,</span><br><span class="line">            context=self.context,</span><br><span class="line">            verifier=verifier)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        (location, size, checksum,</span><br><span class="line">            multihash, loc_meta) = self.store_api.add_to_backend_with_multihash(</span><br><span class="line">            CONF,</span><br><span class="line">            self.image.image_id,</span><br><span class="line">            utils.LimitingReader(utils.CooperativeReader(data),</span><br><span class="line">                                    CONF.image_size_cap),</span><br><span class="line">            size,</span><br><span class="line">            hashing_algo,</span><br><span class="line">            context=self.context,</span><br><span class="line">            verifier=verifier)</span><br><span class="line"></span><br><span class="line">    self.image.locations = [&#123;<span class="string">'url'</span>: location, <span class="string">'metadata'</span>: loc_meta, <span class="string">'status'</span>: <span class="string">'active'</span>&#125;]</span><br><span class="line">    self.image.size = size</span><br><span class="line">    self.image.checksum = checksum</span><br><span class="line">    self.image.os_hash_value = multihash</span><br><span class="line">    self.image.os_hash_algo = hashing_algo</span><br><span class="line">    self.image.status = <span class="string">'active'</span></span><br></pre></td></tr></table></figure><p>这里的<code>store_api</code>默认就是<code>glance_store</code>了，其中<code>add_with_multihash</code>是启用多后端时候调用，<code>add_to_backend_with_multihash</code>启用单后端时候调用。这里以单后端为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to_backend_with_multihash</span><span class="params">(conf, image_id, data, size, hashing_algo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  scheme=None, context=None, verifier=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> scheme <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        scheme = conf[<span class="string">'glance_store'</span>][<span class="string">'default_store'</span>]</span><br><span class="line">    store = get_store_from_scheme(scheme)</span><br><span class="line">    <span class="keyword">return</span> store_add_to_backend_with_multihash(</span><br><span class="line">        image_id, data, size, hashing_algo, store, context, verifier)</span><br></pre></td></tr></table></figure><p>其中<code>get_store_from_scheme</code>函数作用是获取到文章开头所说的绑定到<code>SCHEME_TO_CLS_MAP</code>中的对应的<code>driver</code>，然后经过<code>store_add_to_backend_with_multihash</code>函数进入相应的<code>driver</code>的<code>add</code>方法，这里以Ceph的块存储RBD(RADOS Block Device)为例，函数位于<code>glance_store/_drivers/rbd.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@driver.back_compat_add</span></span><br><span class="line"><span class="meta">@capabilities.check</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, image_id, image_file, image_size, hashing_algo, context=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        verifier=None)</span>:</span></span><br><span class="line">    checksum = hashlib.md5()</span><br><span class="line">    os_hash_value = hashlib.new(str(hashing_algo))</span><br><span class="line">    image_name = str(image_id)</span><br><span class="line">    <span class="keyword">with</span> self.get_connection(conffile=self.conf_file,</span><br><span class="line">                             rados_id=self.user) <span class="keyword">as</span> conn:</span><br><span class="line">        fsid = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(conn, <span class="string">'get_fsid'</span>):</span><br><span class="line">            fsid = encodeutils.safe_decode(conn.get_fsid())</span><br><span class="line">        <span class="keyword">with</span> conn.open_ioctx(self.pool) <span class="keyword">as</span> ioctx:</span><br><span class="line">            order = int(math.log(self.WRITE_CHUNKSIZE, <span class="number">2</span>))</span><br><span class="line">            LOG.debug(<span class="string">'creating image %s with order %d and size %d'</span>,</span><br><span class="line">                      image_name, order, image_size)</span><br><span class="line">            <span class="keyword">if</span> image_size == <span class="number">0</span>:</span><br><span class="line">                LOG.warning(_(<span class="string">"since image size is zero we will be doing "</span></span><br><span class="line">                              <span class="string">"resize-before-write for each chunk which "</span></span><br><span class="line">                              <span class="string">"will be considerably slower than normal"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                loc = self._create_image(fsid, conn, ioctx, image_name,</span><br><span class="line">                                         image_size, order)</span><br><span class="line">            <span class="keyword">except</span> rbd.ImageExists:</span><br><span class="line">                msg = _(<span class="string">'RBD image %s already exists'</span>) % image_id</span><br><span class="line">                <span class="keyword">raise</span> exceptions.Duplicate(message=msg)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> rbd.Image(ioctx, image_name) <span class="keyword">as</span> image:</span><br><span class="line">                    bytes_written = <span class="number">0</span></span><br><span class="line">                    offset = <span class="number">0</span></span><br><span class="line">                    chunks = utils.chunkreadable(image_file,</span><br><span class="line">                                                 self.WRITE_CHUNKSIZE)</span><br><span class="line">                    <span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">                        <span class="comment"># If the image size provided is zero we need to do</span></span><br><span class="line">                        <span class="comment"># a resize for the amount we are writing. This will</span></span><br><span class="line">                        <span class="comment"># be slower so setting a higher chunk size may</span></span><br><span class="line">                        <span class="comment"># speed things up a bit.</span></span><br><span class="line">                        <span class="keyword">if</span> image_size == <span class="number">0</span>:</span><br><span class="line">                            chunk_length = len(chunk)</span><br><span class="line">                            length = offset + chunk_length</span><br><span class="line">                            bytes_written += chunk_length</span><br><span class="line">                            LOG.debug(_(<span class="string">"resizing image to %s KiB"</span>) %</span><br><span class="line">                                      (length / units.Ki))</span><br><span class="line">                            image.resize(length)</span><br><span class="line">                        LOG.debug(_(<span class="string">"writing chunk at offset %s"</span>) %</span><br><span class="line">                                  (offset))</span><br><span class="line">                        offset += image.write(chunk, offset)</span><br><span class="line">                        os_hash_value.update(chunk)</span><br><span class="line">                        checksum.update(chunk)</span><br><span class="line">                        <span class="keyword">if</span> verifier:</span><br><span class="line">                            verifier.update(chunk)</span><br><span class="line">                    <span class="keyword">if</span> loc.snapshot:</span><br><span class="line">                        image.create_snap(loc.snapshot)</span><br><span class="line">                        image.protect_snap(loc.snapshot)</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> image_size == <span class="number">0</span>:</span><br><span class="line">        image_size = bytes_written</span><br><span class="line">    metadata = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> self.backend_group:</span><br><span class="line">        metadata[<span class="string">'store'</span>] = <span class="string">u"%s"</span> % self.backend_group</span><br><span class="line">    <span class="keyword">return</span> (loc.get_uri(),</span><br><span class="line">            image_size,</span><br><span class="line">            checksum.hexdigest(),</span><br><span class="line">            os_hash_value.hexdigest(),</span><br><span class="line">            metadata)</span><br></pre></td></tr></table></figure><p>这个函数首先计算hash值，然后创建连接，再判断镜像是否存在，不存在则上传，然后将数据返回给调用者。最后glance中修改状态为active，整个镜像上传过程就结束了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次学习了Nova创建虚拟机的过程，这次来看一下Glance是如何上传镜像的。相比于Nova，Glance源码使用了大量的代理模式和装饰器模式，阅读代码时候一个不仔细就会一脸懵X。根据上次说的Openstack套路，我们通过&lt;code&gt;setup.cfg&lt;/code&gt;直奔主题——&lt;code&gt;glance/cmd/api.py&lt;/code&gt;:&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        config.parse_args()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        config.set_config_defaults()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wsgi.set_eventlet_hub()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        logging.setup(CONF, &lt;span class=&quot;string&quot;&gt;&#39;glance&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        notifier.set_defaults()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cfg.CONF.profiler.enabled:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            _notifier = osprofiler.notifier.create(&lt;span class=&quot;string&quot;&gt;&quot;Messaging&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   oslo_messaging, &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   notifier.get_transport(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   &lt;span class=&quot;string&quot;&gt;&quot;glance&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;api&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   cfg.CONF.bind_host)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            osprofiler.notifier.set(_notifier)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            osprofiler.web.enable(cfg.CONF.profiler.hmac_keys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            osprofiler.web.disable()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        server = wsgi.Server(initialize_glance_store=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        server.start(config.load_paste_app(&lt;span class=&quot;string&quot;&gt;&#39;glance-api&#39;&lt;/span&gt;), default_port=&lt;span class=&quot;number&quot;&gt;9292&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        server.wait()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; KNOWN_EXCEPTIONS &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fail(e)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Glance" scheme="http://www.hi-roy.com/source/all-tags/Glance/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码学习笔记1</title>
    <link href="http://www.hi-roy.com/2019/09/16/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://www.hi-roy.com/2019/09/16/OpenStack源码学习笔记1/</id>
    <published>2019-09-16T09:46:29.000Z</published>
    <updated>2019-09-17T09:52:54.381Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%84%e5%a4%87%e7%9f%a5%e8%af%86">预备知识</a><ul><li><a href="#%e8%99%9a%e6%8b%9f%e5%8c%96">虚拟化</a></li><li><a href="#wsgi">WSGI</a></li><li><a href="#paste-deployment">Paste Deployment</a></li></ul></li><li><a href="#%e9%80%9a%e7%94%a8%e5%a5%97%e8%b7%af">通用套路</a></li><li><a href="#%e9%85%8d%e7%bd%ae%e5%8a%a0%e8%bd%bd%e4%b8%8e%e8%b7%af%e7%94%b1%e7%bb%91%e5%ae%9a">配置加载与路由绑定</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e6%9c%ba">创建虚拟机</a><ul><li><a href="#nova-api">Nova-Api</a></li><li><a href="#nova-conductor-1">Nova-Conductor-1</a></li><li><a href="#nova-scheduler">Nova-Scheduler</a></li><li><a href="#nova-conductor-2">Nova-Conductor-2</a></li><li><a href="#nova-compute">Nova-Compute</a></li></ul></li></ul><p>作为已经比较成熟的IAAS开源解决方案，OpenStack已经发布了19个版本，目前稳定版是Stein，并且下一个版本Train也预计在10月发布。可以说，从代码架构角度来说对于初学者来说已经略微复杂，但最核心的组件有以下几个：</p><ol><li>Nova：负责虚拟机相关。</li><li>Glance：负责镜像相关。</li><li>Cinder：负责存储相关。</li><li>Neutron：负责网络相关。</li><li>Keystone：负责鉴权以及服务注册。</li></ol><p>大体架构如下图：</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/opstack/openstack-arch-kilo-logical-v1.png" alt="all.png"></p><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>正式开始学习Openstack源码前，需要一些预备知识，不用特别深入但要知道是做什么的。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>虚拟化本身就是一门比较复杂的学问，涉及硬件、操作系统、软件等多个层面知识。这里至少要知道4个名词：</p><ol><li>KVM</li><li>Qemu</li><li>Qemu-KVM</li><li>Libvert</li></ol><p>其中KVM在负责对CPU和内存进行虚拟化，Qemu负责对IO进行虚拟化，而Qemu-KVM则是整合了这2者。而Libvert则是提供了一个更加方便的封装，通过Libvertd服务以及virt-*、virsh命令来方便的管理虚拟机。而OpenStack则在此基础上更进一步的封装，通过各种driver插件来管理不同类型的虚拟机。</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/opstack/qemu-kvm.png" alt="qemu-kvm-libvert"></p><h3 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h3><p>OpenStack的哲学是各个组件通过API以及消息队列建立联系，既然要对外暴露端口，那么其中自然少不了WSGI的存在。<br>简单来说，WSGI解耦了Web Server和Web Application，可以让开发人员专注于功能实现而不是网络协议的处理上。</p><h3 id="Paste-Deployment"><a href="#Paste-Deployment" class="headerlink" title="Paste Deployment"></a>Paste Deployment</h3><p><a href="https://pastedeploy.readthedocs.io/en/latest/" target="_blank" rel="noopener">pastedeploy</a>，这个我也是开始阅读Openstack才学到的新知识，用来建立Server和Application之间的联系。<br>简单来说就是提供服务发现功能，并且隐藏Application的实现细节的，等开始查看Nova代码时候再详细说明。</p><h2 id="通用套路"><a href="#通用套路" class="headerlink" title="通用套路"></a>通用套路</h2><p><a href="https://github.com/openstack" target="_blank" rel="noopener">Openstack</a>的Github主页已经将各个组件拆分，但基本全部遵循着一个相似的结构，比较需要重点关注的文件有3个：</p><ol><li><code>api.py</code>提供对外访问的接口，可以从这开始入手跟踪各个功能实现。</li><li><code>rpcapi.py</code>封装RPC请求调用，大多数是异步调用。</li><li><code>manager.py</code>各种RPC调用的实现，基本和<code>rpcapi.py</code>中调用的名称一一对应。</li></ol><p>另外需要关注的就是根目录中的<code>setup.cfg</code>文件，特别是其中的<code>console_scripts</code>，可以说安装完Openstack后提供的各种命令对应的函数都在这里了，可以说是学习Openstack源码的路标。</p><p>此外还有一点，Openstack的目录结构是根据功能划分的，比如Nova中compute目录不一定都是在<code>nova-compute</code>节点上运行，而是所有和虚拟机创建相关的功能都在这里。</p><h2 id="配置加载与路由绑定"><a href="#配置加载与路由绑定" class="headerlink" title="配置加载与路由绑定"></a>配置加载与路由绑定</h2><p>这里以stein版的Nova为例，根据架构图，Nova-api是所有虚拟机相关请求的入口，首先看Nova中<code>setup.cfg</code>文件定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">……省略……</span><br><span class="line"></span><br><span class="line">nova.compute.monitors.cpu =</span><br><span class="line">    virt_driver = nova.compute.monitors.cpu.virt_driver:Monitor</span><br><span class="line"></span><br><span class="line">console_scripts =</span><br><span class="line">    nova-api = nova.cmd.api:main</span><br><span class="line">    nova-api-metadata = nova.cmd.api_metadata:main</span><br><span class="line">    nova-compute = nova.cmd.compute:main</span><br><span class="line">    nova-conductor = nova.cmd.conductor:main</span><br><span class="line">    nova-console = nova.cmd.console:main</span><br><span class="line">    nova-manage = nova.cmd.manage:main</span><br><span class="line">    nova-network = nova.cmd.network:main</span><br><span class="line">    nova-scheduler = nova.cmd.scheduler:main</span><br><span class="line"></span><br><span class="line">nova.scheduler.driver =</span><br><span class="line">    filter_scheduler = nova.scheduler.filter_scheduler:FilterScheduler</span><br><span class="line">    fake_scheduler = nova.tests.unit.scheduler.fakes:FakeScheduler</span><br><span class="line">……省略……</span><br></pre></td></tr></table></figure><p>从配置文件可以明显的看出，nova-api对应的文件是<code>nova/cmd/api.py</code>的<code>main()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, <span class="string">"nova"</span>)</span><br><span class="line">    objects.register_all()</span><br><span class="line">    gmr_opts.set_defaults(CONF)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'osapi_compute'</span> <span class="keyword">in</span> CONF.enabled_apis:</span><br><span class="line">        <span class="comment"># NOTE(mriedem): This is needed for caching the nova-compute service</span></span><br><span class="line">        <span class="comment"># version.</span></span><br><span class="line">        objects.Service.enable_min_version_cache()</span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line">    launcher = service.process_launcher()</span><br><span class="line">    started = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> api <span class="keyword">in</span> CONF.enabled_apis:</span><br><span class="line">        should_use_ssl = api <span class="keyword">in</span> CONF.enabled_ssl_apis</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server = service.WSGIService(api, use_ssl=should_use_ssl)</span><br><span class="line">            launcher.launch_service(server, workers=server.workers <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line">            started += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> exception.PasteAppNotFound <span class="keyword">as</span> ex:</span><br><span class="line">            log.warning(<span class="string">"%s. ``enabled_apis`` includes bad values. "</span></span><br><span class="line">                        <span class="string">"Fix to remove this warning."</span>, ex)</span><br><span class="line">    <span class="keyword">if</span> started == <span class="number">0</span>:</span><br><span class="line">        log.error(<span class="string">'No APIs were started. '</span></span><br><span class="line">                  <span class="string">'Check the enabled_apis config option.'</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure><p><code>main</code>函数其实就做了一件事，启动配置文件中设定的WSGI服务，默认情况下配置文件位于<code>/etc/nova/nova.conf</code>，配置文件中定义了启用哪些服务、Glance、Cinder、Keystone、Libvert、数据库等信息。说到这里简单提一下 <a href="https://github.com/openstack/oslo.config" target="_blank" rel="noopener">oslo_config</a>这个项目，是从Openstack独立出来的专门处理配置文件的基础功能库。</p><p>查看<code>WSGIService</code>的定义，位于<code>nova/service.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIService</span><span class="params">(service.Service)</span>:</span></span><br><span class="line">    <span class="string">"""Provides ability to launch API from a 'paste' configuration."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, loader=None, use_ssl=False, max_url_len=None)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize, but do not start the WSGI server.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: The name of the WSGI server given to the loader.</span></span><br><span class="line"><span class="string">        :param loader: Loads the WSGI application using the given name.</span></span><br><span class="line"><span class="string">        :returns: None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># NOTE(danms): Name can be metadata, osapi_compute, per</span></span><br><span class="line">        <span class="comment"># nova.service's enabled_apis</span></span><br><span class="line">        self.binary = <span class="string">'nova-%s'</span> % name</span><br><span class="line"></span><br><span class="line">        LOG.warning(<span class="string">'Running %s using eventlet is deprecated. Deploy with '</span></span><br><span class="line">                    <span class="string">'a WSGI server such as uwsgi or mod_wsgi.'</span>, self.binary)</span><br><span class="line"></span><br><span class="line">        self.topic = <span class="literal">None</span></span><br><span class="line">        self.manager = self._get_manager()</span><br><span class="line">        self.loader = loader <span class="keyword">or</span> api_wsgi.Loader()</span><br><span class="line">        self.app = self.loader.load_app(name)</span><br><span class="line">        <span class="comment"># inherit all compute_api worker counts from osapi_compute</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'openstack_compute_api'</span>):</span><br><span class="line">            wname = <span class="string">'osapi_compute'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            wname = name</span><br><span class="line">        self.host = getattr(CONF, <span class="string">'%s_listen'</span> % name, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">        self.port = getattr(CONF, <span class="string">'%s_listen_port'</span> % name, <span class="number">0</span>)</span><br><span class="line">        self.workers = (getattr(CONF, <span class="string">'%s_workers'</span> % wname, <span class="literal">None</span>) <span class="keyword">or</span></span><br><span class="line">                        processutils.get_worker_count())</span><br><span class="line">        <span class="keyword">if</span> self.workers <span class="keyword">and</span> self.workers &lt; <span class="number">1</span>:</span><br><span class="line">            worker_name = <span class="string">'%s_workers'</span> % name</span><br><span class="line">            msg = (_(<span class="string">"%(worker_name)s value of %(workers)s is invalid, "</span></span><br><span class="line">                     <span class="string">"must be greater than 0"</span>) %</span><br><span class="line">                   &#123;<span class="string">'worker_name'</span>: worker_name,</span><br><span class="line">                    <span class="string">'workers'</span>: str(self.workers)&#125;)</span><br><span class="line">            <span class="keyword">raise</span> exception.InvalidInput(msg)</span><br><span class="line">        self.use_ssl = use_ssl</span><br><span class="line">        self.server = wsgi.Server(name,</span><br><span class="line">                                  self.app,</span><br><span class="line">                                  host=self.host,</span><br><span class="line">                                  port=self.port,</span><br><span class="line">                                  use_ssl=self.use_ssl,</span><br><span class="line">                                  max_url_len=max_url_len)</span><br><span class="line">        <span class="comment"># Pull back actual port used</span></span><br><span class="line">        self.port = self.server.port</span><br><span class="line">        self.backdoor_port = <span class="literal">None</span></span><br><span class="line">        setup_profiler(name, self.host)</span><br></pre></td></tr></table></figure><p>其中，<code>self.app = self.loader.load_app(name)</code>就是上面所说的使用Paste Deployment来建立连接的部分，相关代码位于<code>nova/api/wsgi.py</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Used to load WSGI applications from paste configurations."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config_path=None)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize the loader, and attempt to find the config.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param config_path: Full or relative path to the paste config.</span></span><br><span class="line"><span class="string">        :returns: None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.config_path = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        config_path = config_path <span class="keyword">or</span> CONF.wsgi.api_paste_config</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isabs(config_path):</span><br><span class="line">            self.config_path = CONF.find_file(config_path)</span><br><span class="line">        <span class="keyword">elif</span> os.path.exists(config_path):</span><br><span class="line">            self.config_path = config_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config_path:</span><br><span class="line">            <span class="keyword">raise</span> exception.ConfigNotFound(path=config_path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_app</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""Return the paste URLMap wrapped WSGI application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: Name of the application to load.</span></span><br><span class="line"><span class="string">        :returns: Paste URLMap object wrapping the requested application.</span></span><br><span class="line"><span class="string">        :raises: `nova.exception.PasteAppNotFound`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            LOG.debug(<span class="string">"Loading app %(name)s from %(path)s"</span>,</span><br><span class="line">                      &#123;<span class="string">'name'</span>: name, <span class="string">'path'</span>: self.config_path&#125;)</span><br><span class="line">            <span class="keyword">return</span> deploy.loadapp(<span class="string">"config:%s"</span> % self.config_path, name=name)</span><br><span class="line">        <span class="keyword">except</span> LookupError:</span><br><span class="line">            LOG.exception(_LE(<span class="string">"Couldn't lookup app: %s"</span>), name)</span><br><span class="line">            <span class="keyword">raise</span> exception.PasteAppNotFound(name=name, path=self.config_path)</span><br></pre></td></tr></table></figure><p>默认情况下，配置文件位于<code>/etc/nova/api-paste.ini</code>，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Metadata #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="section">[composite:metadata]</span></span><br><span class="line"><span class="attr">use</span> = egg:Paste<span class="comment">#urlmap</span></span><br><span class="line">/: meta</span><br><span class="line"></span><br><span class="line"><span class="section">[pipeline:meta]</span></span><br><span class="line"><span class="attr">pipeline</span> = cors metaapp</span><br><span class="line"></span><br><span class="line"><span class="section">[app:metaapp]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = nova.api.metadata.handler:MetadataRequestHandler.factory</span><br><span class="line"></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># OpenStack #</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line"><span class="section">[composite:osapi_compute]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.openstack.urlmap:urlmap_factory</span><br><span class="line">/: oscomputeversions</span><br><span class="line"><span class="comment"># v21 is an exactly feature match for v2, except it has more stringent</span></span><br><span class="line"><span class="comment"># input validation on the wsgi surface (prevents fuzzing early on the</span></span><br><span class="line"><span class="comment"># API). It also provides new features via API microversions which are</span></span><br><span class="line"><span class="comment"># opt into for clients. Unaware clients will receive the same frozen</span></span><br><span class="line"><span class="comment"># v2 API feature set, but with some relaxed validation</span></span><br><span class="line">/v2: openstack_compute_api_v21_legacy_v2_compatible</span><br><span class="line">/v2.1: openstack_compute_api_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:openstack_compute_api_v21]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.auth:pipeline_factory_v21</span><br><span class="line"><span class="attr">noauth2</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler noauth2 osapi_compute_app_v21</span><br><span class="line"><span class="attr">keystone</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler authtoken keystonecontext osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:openstack_compute_api_v21_legacy_v2_compatible]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.auth:pipeline_factory_v21</span><br><span class="line"><span class="attr">noauth2</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler noauth2 legacy_v2_compatible osapi_compute_app_v21</span><br><span class="line"><span class="attr">keystone</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler authtoken keystonecontext legacy_v2_compatible osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:request_log]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack.requestlog:RequestLog.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:compute_req_id]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.compute_req_id:ComputeReqIdMiddleware.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:faultwrap]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack:FaultWrapper.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:noauth2]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack.auth:NoAuthMiddleware.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:osprofiler]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.profiler:WsgiMiddleware.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:sizelimit]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = oslo_middleware:RequestBodySizeLimiter.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:http_proxy_to_wsgi]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = oslo_middleware.http_proxy_to_wsgi:HTTPProxyToWSGI.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:legacy_v2_compatible]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack:LegacyV2CompatibleWrapper.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[app:osapi_compute_app_v21]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = nova.api.openstack.compute:APIRouterV21.factory</span><br></pre></td></tr></table></figure><p>PasteDeploy的配置文件可以包括多个段。每个段包含一个名称和多个键值对。名称由type和name组成，使用冒号分隔。每个键值对占一行，键名和值使用等号分隔。比较常用的type有：</p><ul><li>composite:用来分发请求到其它应用去。其下的键值对use = egg:Paste#urlmap表示使用Paste中的urlmap应用。urlmap是使用路径的前缀来将请求映射到不同的应用去。</li><li>app:基本的WSGI应用,通常的用法是paste.app_factory = &lt;模块名&gt;:&lt;类名&gt;.&lt;类方法&gt;。</li><li>filter-app:过滤器，通过next可以指定下一步交给谁处理，next指定的可以是一个普通的WSGI应用，也可以是另一个过滤器。</li><li>filter:过滤器，与filter-app用法上不同，其他应用中使用filter-with来指定使用此filter。</li><li>pipeline:管道，可以将多个filter和最后一个WSGI应用串联起来。</li></ul><p>比如对于<code>metadata</code>，就直接使用了Paste中的路由，而对于<code>osapi_compute</code>，则使用nova自己的<code>urlmap_factory</code>处理。这里以V2版本接口为例，当程序收到请求后转交给了<code>openstack_compute_api_v21_legacy_v2_compatible</code>，然后经过pipeline定义的各种filter处理后由<code>osapi_compute_app_v21</code>接手，而这个程序对应的代码就是<code>nova/api/openstack/compute/routes.py</code>中的<code>APIRouterV21</code>类的<code>factory</code>方法，而这个方法本质上就是创建了一个类实例并建立路由和函数之间的映射关系。</p><p>这些操作完成后通过使用eventlet创建<code>wsgi.Server</code>、绑定监听IP和端口，位于<code>nova/wsgi.py</code>的<code>Server</code>类中，这里就不贴出代码了。</p><h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><h3 id="Nova-Api"><a href="#Nova-Api" class="headerlink" title="Nova-Api"></a>Nova-Api</h3><p>根据<a href="https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#create-server" target="_blank" rel="noopener">文档</a>，创建虚拟机的行为其实就是向<code>/servers</code>发送POST请求而已。而上面已经知道在<code>nova/api/openstack/compute/routes.py</code>中定义了对应的函数是：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'/servers'</span>, &#123;</span><br><span class="line">        <span class="string">'GET'</span>: [server_controller, <span class="string">'index'</span>],</span><br><span class="line">        <span class="string">'POST'</span>: [server_controller, <span class="string">'create'</span>]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p></p><p>而这个<code>server_controller</code>是位于<code>nova/api/openstack/compute/servers.py</code>的<code>ServersController</code>类，其<code>create</code>方法定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, req, body)</span>:</span></span><br><span class="line">    <span class="string">"""Creates a new server for a given user."""</span></span><br><span class="line">    context = req.environ[<span class="string">'nova.context'</span>]</span><br><span class="line">    server_dict = body[<span class="string">'server'</span>]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[<span class="string">'name'</span>])</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    availability_zone = server_dict.pop(<span class="string">"availability_zone"</span>, <span class="literal">None</span>)</span><br><span class="line">    image_uuid = self._image_from_req_data(server_dict, create_kwargs)</span><br><span class="line">    self._process_networks_for_create(</span><br><span class="line">        context, target, server_dict, create_kwargs)</span><br><span class="line">    flavor_id = self._flavor_id_from_req_data(body)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        inst_type = flavors.get_flavor_by_flavor_id(</span><br><span class="line">                flavor_id, ctxt=context, read_deleted=<span class="string">"no"</span>)</span><br><span class="line">        supports_multiattach = common.supports_multiattach_volume(req)</span><br><span class="line">        supports_port_resource_request = \</span><br><span class="line">            common.supports_port_resource_request(req)</span><br><span class="line">        (instances, resv_id) = self.compute_api.create(context,</span><br><span class="line">            inst_type,</span><br><span class="line">            image_uuid,</span><br><span class="line">            display_name=name,</span><br><span class="line">            display_description=description,</span><br><span class="line">            availability_zone=availability_zone,</span><br><span class="line">            forced_host=host, forced_node=node,</span><br><span class="line">            metadata=server_dict.get(<span class="string">'metadata'</span>, &#123;&#125;),</span><br><span class="line">            admin_password=password,</span><br><span class="line">            check_server_group_quota=<span class="literal">True</span>,</span><br><span class="line">            supports_multiattach=supports_multiattach,</span><br><span class="line">            supports_port_resource_request=supports_port_resource_request,</span><br><span class="line">            **create_kwargs)</span><br><span class="line">    <span class="keyword">except</span> (exception.QuotaError,</span><br><span class="line">            exception.PortLimitExceeded) <span class="keyword">as</span> error:</span><br><span class="line">        <span class="keyword">raise</span> exc.HTTPForbidden(</span><br><span class="line">            explanation=error.format_message())</span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>经过一些获取、验证操作后，调用了<code>self.compute_api.create()</code>方法，这个<code>compute_api</code>就是<code>nova/compute/api.py</code>中定义的<code>API</code>类，<code>create</code>函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@hooks.add_hook("create_instance")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, context, instance_type,</span></span></span><br><span class="line"><span class="function"><span class="params">            image_href, kernel_id=None, ramdisk_id=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            min_count=None, max_count=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            display_name=None, display_description=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            key_name=None, key_data=None, security_groups=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            availability_zone=None, forced_host=None, forced_node=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            user_data=None, metadata=None, injected_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            admin_password=None, block_device_mapping=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            access_ip_v4=None, access_ip_v6=None, requested_networks=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            config_drive=None, auto_disk_config=None, scheduler_hints=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            legacy_bdm=True, shutdown_terminate=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            check_server_group_quota=False, tags=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            supports_multiattach=False, trusted_certs=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            supports_port_resource_request=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            requested_host=None, requested_hypervisor_hostname=None)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> self._create_instance(</span><br><span class="line">        context, instance_type,</span><br><span class="line">        image_href, kernel_id, ramdisk_id,</span><br><span class="line">        min_count, max_count,</span><br><span class="line">        display_name, display_description,</span><br><span class="line">        key_name, key_data, security_groups,</span><br><span class="line">        availability_zone, user_data, metadata,</span><br><span class="line">        injected_files, admin_password,</span><br><span class="line">        access_ip_v4, access_ip_v6,</span><br><span class="line">        requested_networks, config_drive,</span><br><span class="line">        block_device_mapping, auto_disk_config,</span><br><span class="line">        filter_properties=filter_properties,</span><br><span class="line">        legacy_bdm=legacy_bdm,</span><br><span class="line">        shutdown_terminate=shutdown_terminate,</span><br><span class="line">        check_server_group_quota=check_server_group_quota,</span><br><span class="line">        tags=tags, supports_multiattach=supports_multiattach,</span><br><span class="line">        trusted_certs=trusted_certs,</span><br><span class="line">        supports_port_resource_request=supports_port_resource_request,</span><br><span class="line">        requested_host=requested_host,</span><br><span class="line">        requested_hypervisor_hostname=requested_hypervisor_hostname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_instance</span><span class="params">(self, context, instance_type,</span></span></span><br><span class="line"><span class="function"><span class="params">               image_href, kernel_id, ramdisk_id,</span></span></span><br><span class="line"><span class="function"><span class="params">               min_count, max_count,</span></span></span><br><span class="line"><span class="function"><span class="params">               display_name, display_description,</span></span></span><br><span class="line"><span class="function"><span class="params">               key_name, key_data, security_groups,</span></span></span><br><span class="line"><span class="function"><span class="params">               availability_zone, user_data, metadata, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">               admin_password, access_ip_v4, access_ip_v6,</span></span></span><br><span class="line"><span class="function"><span class="params">               requested_networks, config_drive,</span></span></span><br><span class="line"><span class="function"><span class="params">               block_device_mapping, auto_disk_config, filter_properties,</span></span></span><br><span class="line"><span class="function"><span class="params">               reservation_id=None, legacy_bdm=True, shutdown_terminate=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               check_server_group_quota=False, tags=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               supports_multiattach=False, trusted_certs=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               supports_port_resource_request=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               requested_host=None, requested_hypervisor_hostname=None)</span>:</span></span><br><span class="line">    <span class="comment"># Normalize and setup some parameters</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> image_href:</span><br><span class="line">        image_id, boot_meta = self._get_image(context, image_href)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># This is similar to the logic in _retrieve_trusted_certs_object.</span></span><br><span class="line">        <span class="keyword">if</span> (trusted_certs <span class="keyword">or</span></span><br><span class="line">            (CONF.glance.verify_glance_signatures <span class="keyword">and</span></span><br><span class="line">                CONF.glance.enable_certificate_validation <span class="keyword">and</span></span><br><span class="line">                CONF.glance.default_trusted_certificate_ids)):</span><br><span class="line">            msg = _(<span class="string">"Image certificate validation is not supported "</span></span><br><span class="line">                    <span class="string">"when booting from volume"</span>)</span><br><span class="line">            <span class="keyword">raise</span> exception.CertificateValidationFailed(message=msg)</span><br><span class="line">        image_id = <span class="literal">None</span></span><br><span class="line">        boot_meta = self._get_bdm_image_metadata(</span><br><span class="line">            context, block_device_mapping, legacy_bdm)</span><br><span class="line"></span><br><span class="line">    self._check_auto_disk_config(image=boot_meta,</span><br><span class="line">                                    auto_disk_config=auto_disk_config)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    self.compute_task_api.schedule_and_build_instances(</span><br><span class="line">        context,</span><br><span class="line">        build_requests=build_requests,</span><br><span class="line">        request_spec=request_specs,</span><br><span class="line">        image=boot_meta,</span><br><span class="line">        admin_password=admin_password,</span><br><span class="line">        injected_files=injected_files,</span><br><span class="line">        requested_networks=requested_networks,</span><br><span class="line">        block_device_mapping=block_device_mapping,</span><br><span class="line">        tags=tags)</span><br><span class="line">    <span class="keyword">return</span> instances, reservation_id</span><br></pre></td></tr></table></figure><p>最终，这个函数又调用了<code>self.compute_task_api.schedule_and_build_instances</code>方法，而这个<code>compute_task_api</code>就是<code>nova/conductor/api.py</code>中定义的<code>ComputeTaskAPI</code>类，方法定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                request_spec, image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                requested_networks, block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                tags=None)</span>:</span></span><br><span class="line">    self.conductor_compute_rpcapi.schedule_and_build_instances(</span><br><span class="line">        context, build_requests, request_spec, image,</span><br><span class="line">        admin_password, injected_files, requested_networks,</span><br><span class="line">        block_device_mapping, tags)</span><br></pre></td></tr></table></figure><p>这个函数很简单，就是调用了<code>nova/conductor/rpcapi.py</code>中<code>ComputeTaskAPI</code>类的<code>schedule_and_build_instances</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                request_specs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                image, admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                requested_networks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                tags=None)</span>:</span></span><br><span class="line">    version = <span class="string">'1.17'</span></span><br><span class="line">    kw = &#123;<span class="string">'build_requests'</span>: build_requests,</span><br><span class="line">            <span class="string">'request_specs'</span>: request_specs,</span><br><span class="line">            <span class="string">'image'</span>: jsonutils.to_primitive(image),</span><br><span class="line">            <span class="string">'admin_password'</span>: admin_password,</span><br><span class="line">            <span class="string">'injected_files'</span>: injected_files,</span><br><span class="line">            <span class="string">'requested_networks'</span>: requested_networks,</span><br><span class="line">            <span class="string">'block_device_mapping'</span>: block_device_mapping,</span><br><span class="line">            <span class="string">'tags'</span>: tags&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.client.can_send_version(version):</span><br><span class="line">        version = <span class="string">'1.16'</span></span><br><span class="line">        <span class="keyword">del</span> kw[<span class="string">'tags'</span>]</span><br><span class="line"></span><br><span class="line">    cctxt = self.client.prepare(version=version)</span><br><span class="line">    cctxt.cast(context, <span class="string">'schedule_and_build_instances'</span>, **kw)</span><br></pre></td></tr></table></figure><p><code>cast</code>代表这个是一个异步调用，<code>schedule_and_build_instances</code>是调用的方法名。虽然目录从api到compute到conductor`，但上面的所有过程都是在nova-api管控下的。一直到发出这个异步请求为止，nova-api阶段结束，返回响应，虚拟机状态为building。</p><h3 id="Nova-Conductor-1"><a href="#Nova-Conductor-1" class="headerlink" title="Nova-Conductor-1"></a>Nova-Conductor-1</h3><p>上面说过，<code>manager.py</code>是对应rpc调用方法的实现，所以在<code>nova/conductor/manager.py</code>中找到函数定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     request_specs, image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     requested_networks, block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     tags=None)</span>:</span></span><br><span class="line">    <span class="comment"># Add all the UUIDs for the instances</span></span><br><span class="line">    instance_uuids = [spec.instance_uuid <span class="keyword">for</span> spec <span class="keyword">in</span> request_specs]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        host_lists = self._schedule_instances(context, request_specs[<span class="number">0</span>],</span><br><span class="line">                instance_uuids, return_alternates=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        LOG.exception(<span class="string">'Failed to schedule instances'</span>)</span><br><span class="line">        self._bury_in_cell0(context, request_specs[<span class="number">0</span>], exc,</span><br><span class="line">                            build_requests=build_requests,</span><br><span class="line">                            block_device_mapping=block_device_mapping,</span><br><span class="line">                            tags=tags)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_schedule_instances</span><span class="params">(self, context, request_spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                        instance_uuids=None, return_alternates=False)</span>:</span></span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec)</span><br><span class="line">    <span class="keyword">with</span> timeutils.StopWatch() <span class="keyword">as</span> timer:</span><br><span class="line">        host_lists = self.query_client.select_destinations(</span><br><span class="line">            context, request_spec, instance_uuids, return_objects=<span class="literal">True</span>,</span><br><span class="line">            return_alternates=return_alternates)</span><br><span class="line">    LOG.debug(<span class="string">'Took %0.2f seconds to select destinations for %s '</span></span><br><span class="line">                <span class="string">'instance(s).'</span>, timer.elapsed(), len(instance_uuids))</span><br><span class="line">    <span class="keyword">return</span> host_lists</span><br></pre></td></tr></table></figure><p></p><p>首先这函数调用<code>_schedule_instances</code>方法，这个方法中又调用了<code>select_destinations</code>，而<code>self.query_client</code>其实是一个<code>SchedulerQueryClient</code>类实例，位于<code>nova/scheduler/query.py</code>中，代码很耿直:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_destinations</span><span class="params">(self, context, spec_obj, instance_uuids,</span></span></span><br><span class="line"><span class="function"><span class="params">        return_objects=False, return_alternates=False)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.scheduler_rpcapi.select_destinations(context, spec_obj,</span><br><span class="line">            instance_uuids, return_objects, return_alternates)</span><br></pre></td></tr></table></figure><p>一看到rpcapi，果不其然在<code>nova/scheduler/rpcapi.py</code>中找到对应的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_destinations</span><span class="params">(self, ctxt, spec_obj, instance_uuids,</span></span></span><br><span class="line"><span class="function"><span class="params">            return_objects=False, return_alternates=False)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    cctxt = self.client.prepare(</span><br><span class="line">        version=version, call_monitor_timeout=CONF.rpc_response_timeout,</span><br><span class="line">        timeout=CONF.long_rpc_timeout)</span><br><span class="line">    <span class="keyword">return</span> cctxt.call(ctxt, <span class="string">'select_destinations'</span>, **msg_args)</span><br></pre></td></tr></table></figure><p>注意这里使用的<code>call</code>而不是<code>cast</code>，所以是一个同步调用，此时nova-conductor会堵塞等待直到nova-scheduler返回。</p><h3 id="Nova-Scheduler"><a href="#Nova-Scheduler" class="headerlink" title="Nova-Scheduler"></a>Nova-Scheduler</h3><p>根据套路，在<code>nova/scheduler/manager.py</code>中找到函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@messaging.expected_exceptions(exception.NoValidHost)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_destinations</span><span class="params">(self, ctxt, request_spec=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        filter_properties=None, spec_obj=_sentinel, instance_uuids=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        return_objects=False, return_alternates=False)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    selections = self.driver.select_destinations(ctxt, spec_obj,</span><br><span class="line">            instance_uuids, alloc_reqs_by_rp_uuid, provider_summaries,</span><br><span class="line">            allocation_request_version, return_alternates)</span><br><span class="line">    <span class="comment"># If `return_objects` is False, we need to convert the selections to</span></span><br><span class="line">    <span class="comment"># the older format, which is a list of host state dicts.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> return_objects:</span><br><span class="line">        selection_dicts = [sel[<span class="number">0</span>].to_dict() <span class="keyword">for</span> sel <span class="keyword">in</span> selections]</span><br><span class="line">        <span class="keyword">return</span> jsonutils.to_primitive(selection_dicts)</span><br><span class="line">    <span class="keyword">return</span> selections</span><br></pre></td></tr></table></figure><p>这个函数本质上又是一层封装，最终调用的是<code>nova-api.conf</code>文件中定义的<code>scheduler.driver</code>，这里以自带的<code>FilterScheduler</code>为例，位于<code>nova/scheduler/filter_scheduler.py</code>，入口函数是<code>_schedule</code>，在这里首先获取全部的host，然后经过<code>_get_sorted_hosts</code>函数的筛选和权重计算，返回满足条件的主机给nova-conductor。</p><h3 id="Nova-Conductor-2"><a href="#Nova-Conductor-2" class="headerlink" title="Nova-Conductor-2"></a>Nova-Conductor-2</h3><p>回到<code>nova/conductor/manager.py</code>的<code>schedule_and_build_instances</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     request_specs, image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     requested_networks, block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     tags=None)</span>:</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    zipped = six.moves.zip(build_requests, request_specs, host_lists,</span><br><span class="line">                            instances)</span><br><span class="line">    <span class="keyword">for</span> (build_request, request_spec, host_list, instance) <span class="keyword">in</span> zipped:</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> obj_target_cell(instance, cell) <span class="keyword">as</span> cctxt:</span><br><span class="line">            <span class="comment"># send a state update notification for the initial create to</span></span><br><span class="line">            <span class="comment"># show it going from non-existent to BUILDING</span></span><br><span class="line">            <span class="comment"># This can lazy-load attributes on instance.</span></span><br><span class="line">            notifications.send_update_with_states(cctxt, instance, <span class="literal">None</span>,</span><br><span class="line">                    vm_states.BUILDING, <span class="literal">None</span>, <span class="literal">None</span>, service=<span class="string">"conductor"</span>)</span><br><span class="line">            objects.InstanceAction.action_start(</span><br><span class="line">                cctxt, instance.uuid, instance_actions.CREATE,</span><br><span class="line">                want_result=<span class="literal">False</span>)</span><br><span class="line">            instance_bdms = self._create_block_device_mapping(</span><br><span class="line">                cell, instance.flavor, instance.uuid, block_device_mapping)</span><br><span class="line">            instance_tags = self._create_tags(cctxt, instance.uuid, tags)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update mapping for instance. Normally this check is guarded by</span></span><br><span class="line">        <span class="comment"># a try/except but if we're here we know that a newer nova-api</span></span><br><span class="line">        <span class="comment"># handled the build process and would have created the mapping</span></span><br><span class="line">        inst_mapping = objects.InstanceMapping.get_by_instance_uuid(</span><br><span class="line">            context, instance.uuid)</span><br><span class="line">        inst_mapping.cell_mapping = cell</span><br><span class="line">        inst_mapping.save()</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        legacy_secgroups = [s.identifier</span><br><span class="line">                            <span class="keyword">for</span> s <span class="keyword">in</span> request_spec.security_groups]</span><br><span class="line">        <span class="keyword">with</span> obj_target_cell(instance, cell) <span class="keyword">as</span> cctxt:</span><br><span class="line">            self.compute_rpcapi.build_and_run_instance(</span><br><span class="line">                cctxt, instance=instance, image=image,</span><br><span class="line">                request_spec=request_spec,</span><br><span class="line">                filter_properties=filter_props,</span><br><span class="line">                admin_password=admin_password,</span><br><span class="line">                injected_files=injected_files,</span><br><span class="line">                requested_networks=requested_networks,</span><br><span class="line">                security_groups=legacy_secgroups,</span><br><span class="line">                block_device_mapping=instance_bdms,</span><br><span class="line">                host=host.service_host, node=host.nodename,</span><br><span class="line">                limits=host.limits, host_list=host_list)</span><br></pre></td></tr></table></figure><p>拿到主机列表后，由于可能同时创建多台主机，所以使用for循环，进行了一些数据库操作后，进行rpc调用，位于<code>nova/compute/rpcapi.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_and_run_instance</span><span class="params">(self, ctxt, instance, host, image, request_spec,</span></span></span><br><span class="line"><span class="function"><span class="params">        filter_properties, admin_password=None, injected_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        requested_networks=None, security_groups=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        block_device_mapping=None, node=None, limits=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        host_list=None)</span>:</span></span><br><span class="line">    ......    </span><br><span class="line">    cctxt.cast(ctxt, <span class="string">'build_and_run_instance'</span>, **kwargs)</span><br></pre></td></tr></table></figure><h3 id="Nova-Compute"><a href="#Nova-Compute" class="headerlink" title="Nova-Compute"></a>Nova-Compute</h3><p>套路都熟悉了，直接看<code>nova/compute/manager.py</code>吧，其实最核心函数是<code>_build_and_run_instance</code>，这里进行镜像、网络资源的准备以及各种验证、状态修改、发送通知等。最后调用对应driver的spawn方法，这里以libvert为例，对应文件是<code>nova/virt/libvirt/driver.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(self, context, instance, image_meta, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">            admin_password, allocations, network_info=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            block_device_info=None, power_on=True)</span>:</span></span><br><span class="line">    disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,</span><br><span class="line">                                        instance,</span><br><span class="line">                                        image_meta,</span><br><span class="line">                                        block_device_info)</span><br><span class="line">    injection_info = InjectionInfo(network_info=network_info,</span><br><span class="line">                                    files=injected_files,</span><br><span class="line">                                    admin_pass=admin_password)</span><br><span class="line">    gen_confdrive = functools.partial(self._create_configdrive,</span><br><span class="line">                                        context, instance,</span><br><span class="line">                                        injection_info)</span><br><span class="line">    self._create_image(context, instance, disk_info[<span class="string">'mapping'</span>],</span><br><span class="line">                        injection_info=injection_info,</span><br><span class="line">                        block_device_info=block_device_info)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required by Quobyte CI</span></span><br><span class="line">    self._ensure_console_log_for_instance(instance)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Does the guest need to be assigned some vGPU mediated devices ?</span></span><br><span class="line">    mdevs = self._allocate_mdevs(allocations)</span><br><span class="line"></span><br><span class="line">    xml = self._get_guest_xml(context, instance, network_info,</span><br><span class="line">                                disk_info, image_meta,</span><br><span class="line">                                block_device_info=block_device_info,</span><br><span class="line">                                mdevs=mdevs)</span><br><span class="line">    self._create_domain_and_network(</span><br><span class="line">        context, xml, instance, network_info,</span><br><span class="line">        block_device_info=block_device_info,</span><br><span class="line">        post_xml_callback=gen_confdrive,</span><br><span class="line">        destroy_disks_on_failure=<span class="literal">True</span>,</span><br><span class="line">        power_on=power_on)</span><br><span class="line">    LOG.debug(<span class="string">"Guest created on hypervisor"</span>, instance=instance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_wait_for_boot</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""Called at an interval until the VM is running."""</span></span><br><span class="line">        state = self.get_info(instance).state</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> state == power_state.RUNNING:</span><br><span class="line">            LOG.info(<span class="string">"Instance spawned successfully."</span>, instance=instance)</span><br><span class="line">            <span class="keyword">raise</span> loopingcall.LoopingCallDone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> power_on:</span><br><span class="line">        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_boot)</span><br><span class="line">        timer.start(interval=<span class="number">0.5</span>).wait()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LOG.info(<span class="string">"Instance spawned successfully."</span>, instance=instance)</span><br></pre></td></tr></table></figure><p>在这里拉取镜像创建根目录，生成XML(默认在/etc/libvert/qemu目录)，定义网络和domain并启动，然后虚拟机状态为running。到此为止，创建虚拟机完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#%e9%a2%84%e5%a4%87%e7%9f%a5%e8%af%86&quot;&gt;预备知识&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#%e8%99%9a%e6%8b%9f%e5%8c%96&quot;&gt;虚拟化&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#wsgi&quot;&gt;WSGI&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#paste-deployment&quot;&gt;Paste Deployment&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#%e9%80%9a%e7%94%a8%e5%a5%97%e8%b7%af&quot;&gt;通用套路&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#%e9%85%8d%e7%bd%ae%e5%8a%a0%e8%bd%bd%e4%b8%8e%e8%b7%af%e7%94%b1%e7%bb%91%e5%ae%9a&quot;&gt;配置加载与路由绑定&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e6%9c%ba&quot;&gt;创建虚拟机&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#nova-api&quot;&gt;Nova-Api&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-conductor-1&quot;&gt;Nova-Conductor-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-scheduler&quot;&gt;Nova-Scheduler&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-conductor-2&quot;&gt;Nova-Conductor-2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-compute&quot;&gt;Nova-Compute&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;作为已经比较成熟的IAAS开源解决方案，OpenStack已经发布了19个版本，目前稳定版是Stein，并且下一个版本Train也预计在10月发布。可以说，从代码架构角度来说对于初学者来说已经略微复杂，但最核心的组件有以下几个：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Nova：负责虚拟机相关。&lt;/li&gt;&lt;li&gt;Glance：负责镜像相关。&lt;/li&gt;&lt;li&gt;Cinder：负责存储相关。&lt;/li&gt;&lt;li&gt;Neutron：负责网络相关。&lt;/li&gt;&lt;li&gt;Keystone：负责鉴权以及服务注册。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;大体架构如下图：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/opstack/openstack-arch-kilo-logical-v1.png&quot; alt=&quot;all.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Nova" scheme="http://www.hi-roy.com/source/all-tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy-Redis结合POST请求获取数据</title>
    <link href="http://www.hi-roy.com/2019/05/06/Scrapy-Redis%E7%BB%93%E5%90%88POST%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.hi-roy.com/2019/05/06/Scrapy-Redis结合POST请求获取数据/</id>
    <published>2019-05-06T08:31:37.000Z</published>
    <updated>2019-09-16T08:11:51.470Z</updated>
    
    <content type="html"><![CDATA[<p>能看到这篇文章的小伙伴肯定已经知道什么是Scrapy以及Scrapy-Redis了，基础概念这里就不再介绍。默认情况下Scrapy-Redis是发送GET请求获取数据的，对于某些使用POST请求的情况需要重写<code>make_request_from_data</code>函数即可，但奇怪的是居然没在网上搜到简洁明了的答案，或许是太简单了？</p><p>这里我以<code>httpbin.org</code>这个网站为例，首先在<code>settings.py</code>中添加所需配置，这里需要根据实际情况进行修改：<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SCHEDULER = <span class="string">"scrapy_redis.scheduler.Scheduler"</span>  <span class="comment">#启用Redis调度存储请求队列</span></span><br><span class="line">SCHEDULER_PERSIST = <span class="literal">True</span>    <span class="comment">#不清除Redis队列、这样可以暂停/恢复 爬取</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">"scrapy_redis.dupefilter.RFPDupeFilter"</span>  <span class="comment">#确保所有的爬虫通过Redis去重</span></span><br><span class="line">SCHEDULER_QUEUE_CLASS = <span class="string">'scrapy_redis.queue.SpiderPriorityQueue'</span></span><br><span class="line">REDIS_URL = <span class="string">"redis://127.0.0.1:6379"</span></span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>爬虫代码如下：<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy_redis.spiders <span class="keyword">import</span> RedisSpider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HpbSpider</span><span class="params">(RedisSpider)</span>:</span></span><br><span class="line">    name = <span class="string">'hpb'</span></span><br><span class="line">    redis_key = <span class="string">'test_post_data'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_request_from_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Returns a Request instance from data coming from Redis.</span></span><br><span class="line"><span class="string">        By default, ``data`` is an encoded URL. You can override this method to</span></span><br><span class="line"><span class="string">        provide your own message decoding.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        data : bytes</span></span><br><span class="line"><span class="string">            Message from redis.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> scrapy.FormRequest(<span class="string">"https://www.httpbin.org/post"</span>,</span><br><span class="line">                                  formdata=&#123;<span class="string">"data"</span>:data&#125;,callback=self.parse)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        print(response.body)</span><br></pre></td></tr></table></figure><p></p><p>这里为了简单直接进行输出，真实使用时可以结合pipeline写数据库等。</p><p>然后启动爬虫程序<code>scrapy crawl hpb</code>，由于我们还没向<code>test_post_data</code>中写数据，所以启动后程序进入等待状态。然后模拟向队列写数据：<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">rd = redis.Redis(<span class="string">'127.0.0.1'</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    rd.lpush(<span class="string">'test_post_data'</span>,_)</span><br></pre></td></tr></table></figure><p></p><p>此时可以看到爬虫已经开始获取程序了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2019-05-06 16:30:21 [hpb] DEBUG: Read 8 requests from &apos;test_post_data&apos;</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;0&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;1&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;3&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;2&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;4&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;5&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;6&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;7&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">2019-05-06 16:31:09 [scrapy.extensions.logstats] INFO: Crawled 1001 pages (at 280 pages/min), scraped 0 items (at 0 items/min)</span><br><span class="line">2019-05-06 16:32:09 [scrapy.extensions.logstats] INFO: Crawled 1001 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br><span class="line">2019-05-06 16:33:09 [scrapy.extensions.logstats] INFO: Crawled 1001 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br></pre></td></tr></table></figure><p></p><p>至于数据重复的问题，如果POST的数据重复，这个请求就不会发送出去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能看到这篇文章的小伙伴肯定已经知道什么是Scrapy以及Scrapy-Redis了，基础概念这里就不再介绍。默认情况下Scrapy-Redis是发送GET请求获取数据的，对于某些使用POST请求的情况需要重写&lt;code&gt;make_request_from_data&lt;/code&gt;函数即可，但奇怪的是居然没在网上搜到简洁明了的答案，或许是太简单了？&lt;/p&gt;&lt;p&gt;这里我以&lt;code&gt;httpbin.org&lt;/code&gt;这个网站为例，首先在&lt;code&gt;settings.py&lt;/code&gt;中添加所需配置，这里需要根据实际情况进行修改：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SCHEDULER = &lt;span class=&quot;string&quot;&gt;&quot;scrapy_redis.scheduler.Scheduler&quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#启用Redis调度存储请求队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SCHEDULER_PERSIST = &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#不清除Redis队列、这样可以暂停/恢复 爬取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DUPEFILTER_CLASS = &lt;span class=&quot;string&quot;&gt;&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#确保所有的爬虫通过Redis去重&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SCHEDULER_QUEUE_CLASS = &lt;span class=&quot;string&quot;&gt;&#39;scrapy_redis.queue.SpiderPriorityQueue&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;REDIS_URL = &lt;span class=&quot;string&quot;&gt;&quot;redis://127.0.0.1:6379&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
    
      <category term="python" scheme="http://www.hi-roy.com/source/all-tags/python/"/>
    
  </entry>
  
  <entry>
    <title>提升keras准确率和速度的小tips</title>
    <link href="http://www.hi-roy.com/2019/03/14/%E6%8F%90%E5%8D%87keras%E5%87%86%E7%A1%AE%E7%8E%87%E5%92%8C%E9%80%9F%E5%BA%A6%E7%9A%84tips/"/>
    <id>http://www.hi-roy.com/2019/03/14/提升keras准确率和速度的tips/</id>
    <published>2019-03-14T09:27:14.000Z</published>
    <updated>2019-09-16T08:11:51.526Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下对于新手(对,说的就是本人)学习kears框架时用来提升准确率的一些tip,但这里都是”术”的层面,而对于”道”,还是要看数学.全文以深度学习界的”hello world”-<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">手写数字识别</a>为例.</p><a id="more"></a><p>首先载入所需要的库:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers.core <span class="keyword">import</span> Dense,Dropout,Activation</span><br></pre></td></tr></table></figure><p></p><p>然后编写函数加载数据:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">  (x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line">  number = <span class="number">10000</span></span><br><span class="line">  x_train = x_train[:number] <span class="comment"># 完整训练数据有6w,这里取前1w</span></span><br><span class="line">  y_train = y_train[:number]  </span><br><span class="line">  x_train = x_train.reshape(number,<span class="number">28</span>*<span class="number">28</span>) <span class="comment"># 原始数据是3维,这里变成2维</span></span><br><span class="line">  x_test=x_test.reshape(x_test.shape[<span class="number">0</span>],<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">  x_train = x_train.astype(<span class="string">'float32'</span>)</span><br><span class="line">  x_test = x_test.astype(<span class="string">'float32'</span>)</span><br><span class="line">  y_train = np_utils.to_categorical(y_train,<span class="number">10</span>) <span class="comment"># 原始数据是1,2...9这样的数字,to_categorical将其变成向量,对应的数字位置为1,其余为0</span></span><br><span class="line">  y_test = np_utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line">  x_train = x_train / <span class="number">255</span></span><br><span class="line">  x_test = x_test / <span class="number">255</span></span><br><span class="line">  <span class="keyword">return</span> (x_train,y_train),(x_test,y_test)</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test) = load_data()</span><br></pre></td></tr></table></figure><p></p><h2 id="选择合适的loss函数"><a href="#选择合适的loss函数" class="headerlink" title="选择合适的loss函数"></a>选择合适的loss函数</h2><p>对于loss函数,如果之前有学过经典机器学习的小伙伴一定最熟悉MSE(均方误差),所以先用这个实现一个版本:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'mse'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p></p><p>这里activation函数使用<code>sigmoid</code>,optimizer使用SGD(随机梯度下降),loss选择MSE,2个隐藏层,隐藏层节点数量689,程序输出如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.12860000133514404</span><br><span class="line">Test Accc: 0.1362999975681305</span><br></pre></td></tr></table></figure><p></p><p>这里可以看出,基本凉凉.不论是在测试集还是训练集准确度都很低.但是,如果把loss函数换成<code>categorical_crossentropy</code>,输出就变成:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.8550000190734863</span><br><span class="line">Test Accc: 0.8374000191688538</span><br></pre></td></tr></table></figure><p></p><p>很明显的提升,这也说明,MSE对于分类问题不是很有好.</p><h2 id="合适的隐藏层数量"><a href="#合适的隐藏层数量" class="headerlink" title="合适的隐藏层数量"></a>合适的隐藏层数量</h2><p>对于初学者有种幻想,层数越多精度就会越高.这里增加一下层数试试:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.09910000115633011</span><br><span class="line">Test Accc: 0.10320000350475311</span><br></pre></td></tr></table></figure><p></p><p>WTF?!准确度反而降低了??这里其实和<code>sigmoid</code>这个函数有关,这个函数会导致vanish gradient problem.简言之就是使用这个函数进行训练时层数越多,每次参数变化引起结果变化的程度就越小,因为<code>sigmoid</code>函数会把不论大小的输入都转化到0-1这个区间中,具体看其<a href="https://baike.baidu.com/item/Sigmoid%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">函数图像</a>就可以明白了.</p><h2 id="合适的激活函数"><a href="#合适的激活函数" class="headerlink" title="合适的激活函数"></a>合适的激活函数</h2><p><code>sigmoid</code>函数其实比较少用了,现在更常用的是<code>relu</code><a href="https://baike.baidu.com/item/ReLU%20%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">函数</a>,可以避免vanish gradient problem.此外,<code>relu</code>其实是<code>Maxout</code>的一个特例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>结果如下,可以看到增加10层使用<code>relu</code>函数不受影响.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9959999918937683</span><br><span class="line">Test Accc: 0.9541000127792358</span><br></pre></td></tr></table></figure><p></p><h2 id="合适的batch-size"><a href="#合适的batch-size" class="headerlink" title="合适的batch_size"></a>合适的batch_size</h2><p>batch_size影响每次训练使用的数据量,比如极端情况下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">10000</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这里把batch_size的值改成和整个训练集一样大,结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.2732999920845032</span><br><span class="line">Test Accc: 0.26249998807907104</span><br></pre></td></tr></table></figure><p></p><p>又凉凉了,所以 <strong>batch_size</strong> 过大速度快,但会影响精度.而过小则速度会慢,特别是使用GPU的时候,如果这个值设定的过小不能完全发挥GPU的加速功能.</p><h2 id="合适的optimizer"><a href="#合适的optimizer" class="headerlink" title="合适的optimizer"></a>合适的optimizer</h2><p>目前最常用的优化函数是<code>adam</code>,<code>adam=RMSProp+Momentum</code>,这里替换掉SGD:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出如下,精度差不多但是训练的速度提升了很多:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9906999754905701</span><br><span class="line">Test Accc: 0.9217000007629395</span><br></pre></td></tr></table></figure><p></p><h2 id="Dropout层"><a href="#Dropout层" class="headerlink" title="Dropout层"></a>Dropout层</h2><p>当训练样本过少时候,往往会出现过拟合的现象,这时可以使用Dropout层来”限制学习能力”.这个方法原理是在每次更新参数之前根据概率丢掉某些neuron,使整个网络结构发生了改变,在每一个mini-batch上重复这个行为,得到不同的结果,相当于训练出了很多个不同的网络,然后再把结果平均得到最终结果(ensemble的理念).这个方法会降低在训练集上的精准度.</p><p>为了模拟过拟合,我们在处理数据集时候添加噪声:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">  (x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line">  number = <span class="number">10000</span></span><br><span class="line">  x_train = x_train[:number] <span class="comment"># 完整训练数据有6w,这里取前1w</span></span><br><span class="line">  y_train = y_train[:number]  </span><br><span class="line">  x_train = x_train.reshape(number,<span class="number">28</span>*<span class="number">28</span>) <span class="comment"># 原始数据是3维,这里变成2维</span></span><br><span class="line">  x_test=x_test.reshape(x_test.shape[<span class="number">0</span>],<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">  x_train = x_train.astype(<span class="string">'float32'</span>)</span><br><span class="line">  x_test = x_test.astype(<span class="string">'float32'</span>)</span><br><span class="line">  y_train = np_utils.to_categorical(y_train,<span class="number">10</span>) <span class="comment"># 原始数据是1,2...9这样的数字,to_categorical将其变成向量,对应的数字位置为1,其余为0</span></span><br><span class="line">  y_test = np_utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line">  x_train = x_train / <span class="number">255</span></span><br><span class="line">  x_test = x_test / <span class="number">255</span></span><br><span class="line">  x_test=np.random.normal(x_test) <span class="comment"># 加噪声</span></span><br><span class="line">  <span class="keyword">return</span> (x_train,y_train),(x_test,y_test)</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test) = load_data()</span><br></pre></td></tr></table></figure><p>然后经过2层<code>relu</code>+<code>adam</code>+<code>categorical_crossentropy</code>+<code>batch_size=100</code>结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9894000291824341</span><br><span class="line">Test Accc:  0.5034999847412109</span><br></pre></td></tr></table></figure><p></p><p>可以看到训练集精度很高而测试集准确度一般,添加Dropout层:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.7</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.7</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.7</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>其中Dropout层添加到每个隐藏层之间,常用的概率值是0.5左右,结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9824030212854031</span><br><span class="line">Test Accc: 0.6224999713897705</span><br></pre></td></tr></table></figure><p></p><p>可以看到测试集精度提升了一些.当然,除了Dropout之外可以<a href="https://keras.io/getting-started/faq/#how-can-i-interrupt-training-when-the-validation-loss-isnt-decreasing-anymore" target="_blank" rel="noopener">Early Stopping</a>和Regularization(正则化,简单说就是使用某种方法使结果越来越接近0,Weight Decay,但这个帮助并不显著.)</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程!"></a>特征工程!</h2><p>在上面的测试准确率可以达到90%以上,但细心的小伙伴应该发现了,在加载数据时候有这样2行代码:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_train = x_train / <span class="number">255</span></span><br><span class="line">x_test = x_test / <span class="number">255</span></span><br></pre></td></tr></table></figure><p>这两行代码就是对原始数据进行了缩放,将原始值在0-255之间的数据转化到0-1这个区间.如果没有这个处理,那么依然使用2层<code>relu</code>+<code>adam</code>+<code>categorical_crossentropy</code>+<code>batch_size=100</code>结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.10010000318288803</span><br><span class="line">Test Accc: 0.09799999743700027</span><br></pre></td></tr></table></figure><p>准确度居然降到和<code>sigmoid</code>+<code>SGD</code>+<code>mse</code>差不多的程度.所以,如果当程序在训练集上的准确度都很低的话,除了调整参数还需要进一步考虑特征工程是否合理合适了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下对于新手(对,说的就是本人)学习kears框架时用来提升准确率的一些tip,但这里都是”术”的层面,而对于”道”,还是要看数学.全文以深度学习界的”hello world”-&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手写数字识别&lt;/a&gt;为例.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="机器学习" scheme="http://www.hi-roy.com/source/all-categories/Python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://www.hi-roy.com/source/all-tags/python/"/>
    
      <category term="kears" scheme="http://www.hi-roy.com/source/all-tags/kears/"/>
    
  </entry>
  
  <entry>
    <title>如何对Go代码解偶</title>
    <link href="http://www.hi-roy.com/2019/02/11/%E5%A6%82%E4%BD%95%E5%AF%B9Go%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%81%B6/"/>
    <id>http://www.hi-roy.com/2019/02/11/如何对Go代码解偶/</id>
    <published>2019-02-11T03:05:03.000Z</published>
    <updated>2019-09-16T08:11:51.524Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sage42.org/2019/01/30/how-to-fix-tightly-coupled-go-code/" target="_blank" rel="noopener">原文</a>，文章作者也是《Hands-On Dependency Injection in Go》的作者，向原作者表示感谢。</p><hr><p>你是否曾经由于添加某个新功能却导致另一个功能出问题？修复好这个，另一个又出问题，就好象打地鼠一般。</p><p>你是否曾经花费大量的时间调试Bug，最后却发现问题潜伏在另一个、甚至毫不相关的模块中？</p><p>这些问题都是由于高耦合引起的。</p><p>在这篇文章中，我们来使用解偶的方式来让代码更加易于理解、维护、测试。</p><a id="more"></a><h1 id="什么是耦合？"><a href="#什么是耦合？" class="headerlink" title="什么是耦合？"></a>什么是耦合？</h1><p>在软件开发中，耦合是用来测量2个部分（对象、包、函数）之间相互依赖程度的指标。参考下面的例子：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">DSN            <span class="keyword">string</span></span><br><span class="line">MaxConnections <span class="keyword">int</span></span><br><span class="line">Timeout        time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonLoader <span class="keyword">struct</span> &#123;</span><br><span class="line">Config *Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这2个对象不能离开另一个单独存在(Roy个人理解：虽然可以单独声明Config对象，但单独这个对象是什么也做不了的。)，所以说这2者是高耦合的(tightly coupled)。</p><h1 id="为什么高耦合的代码是个问题？"><a href="#为什么高耦合的代码是个问题？" class="headerlink" title="为什么高耦合的代码是个问题？"></a>为什么高耦合的代码是个问题？</h1><p>高耦合代码会带来很多问题，但最明显的一个就是会导致散弹式修改(shotgun surgery)。散弹式修改是一个术语，用来描述那种修改一个地方的代码导致要修改很多其他地方代码的情况。</p><p>考虑下面的代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserEndpoint</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// get and check inputs</span></span><br><span class="line">ID, err := getRequestedID(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">resp.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load requested data</span></span><br><span class="line">user, err := loadUser(ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// technical error</span></span><br><span class="line">resp.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> user == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// user not found</span></span><br><span class="line">resp.WriteHeader(http.StatusNoContent)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare output</span></span><br><span class="line"><span class="keyword">switch</span> req.Header.Get(<span class="string">"Accept"</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"text/csv"</span>:</span><br><span class="line">outputAsCSV(resp, user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"application/xml"</span>:</span><br><span class="line">outputAsXML(resp, user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"application/json"</span>:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">outputAsJSON(resp, user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在假设我们要在User对象中添加一个Password字段，但我们不想让这个字段出现在API返回数据中，我们不得不同时修改<code>outputAsCSV()</code>， <code>outputAsXML()</code>和<code>outputAsJSON()</code>这3个函数。</p><p>这看上去似乎没什么问题，但试想如果我们还有其他的接口(endpoint)也将User作为输出的一部分，比如”GetAllUsers”，我们不得不做同样的工作。这一切都是由于”GetUser”接口和User类型输出的形式是高耦合的。</p><p>换言之，我们把渲染逻辑从”GetUserHandler”接口转移到User类型中，这样我们修改一个地方就可以了。更重要的是，如果我们需要添加新的字段，User类显然更加明显和容易找到，这样也提高了整体代码的可维护性。</p><p>在我们深入讨论如何解偶之前，我们还需要讨论一下依赖倒置原则(Dependency Inversion Principle)。</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则(DIP)由Robert C. Martin在1996年在 <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener">Dependency Inversion Principle</a>中提出，他对此定义如下:</p><blockquote><p>顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。<br>High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions<br>Robert C. Martin</p></blockquote><p>(Roy注：为了统一下面把modules、packages都翻译成模块。)</p><p>正如Robert所言，大智慧往往浓缩成非常精炼的句子。下面是我的理解并且翻译成Go代码：</p><p>1) <strong>顶层模块不应该依赖底层模块</strong> - 当我们编写Go程序时，一些包被<code>main()</code>函数调用，这些可以认为是顶层模块。相反的，一些和外部资源交互的模块，比如数据库，典型的不由<code>main()</code>调用而是由逻辑层调用，这就要低1-2级。</p><p>顶层模块应该依赖于抽象而不是这些实现细节的模块，这有助于解偶。</p><p>2) <strong>结构体不应该依赖于结构体</strong> - 当一个结构体接受另一个结构体作为方法参数或成员变量时:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PizzaMaker <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PizzaMaker)</span> <span class="title">MakePizza</span><span class="params">(oven *SuperPizaOven5000)</span></span> &#123;</span><br><span class="line">pizza := p.buildPizza()</span><br><span class="line">oven.Bake(pizza)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样的代码耦合度很高导致及其不灵活，让我们考虑一个实际情况：我走进一家旅行社并说:”我想购买一张澳洲航空在星期四3点30分飞往悉尼的15D座位机票。”这种说法旅行社是很难满足我的要求的。</p><p>但如果我放松要求，就好像我们将输入的参数由结构体类型改成接口类型一般:”我想购买一张星期四飞往悉尼的机票。”这样旅行社可以更加灵活处理我的请求，也就更可能买到机票。</p><p>修改代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PizzaMaker <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PizzaMaker)</span> <span class="title">MakePizza</span><span class="params">(oven Oven)</span></span> &#123;</span><br><span class="line">pizza := p.buildPizza()</span><br><span class="line">oven.Bake(pizza)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Oven <span class="keyword">interface</span> &#123;</span><br><span class="line">Bake(pizza Pizza)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用任何类型来实现<code>Bake()</code>方法。</p><p>3) <strong>接口不应该依赖结构体</strong> - 和前文类似，根据特定的情况，我们定义接口：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">DSN            <span class="keyword">string</span></span><br><span class="line">MaxConnections <span class="keyword">int</span></span><br><span class="line">Timeout        time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonLoader <span class="keyword">interface</span> &#123;</span><br><span class="line">Load(cfg *Config, ID <span class="keyword">int</span>) *Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们将<code>PersonLoader</code>和<code>Config</code>这个特定的额结构体绑定到了一起，也就是说想在其他项目中复用<code>PersonLoader</code>将需要修改代码，而这些修改可能导致Bug。换句话说，如果我们像下面这样定义<code>PersonLoader</code>：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonLoaderConfig <span class="keyword">interface</span> &#123;</span><br><span class="line">DSN() <span class="keyword">string</span></span><br><span class="line">MaxConnections() <span class="keyword">int</span></span><br><span class="line">Timeout() time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonLoader <span class="keyword">interface</span> &#123;</span><br><span class="line">Load(cfg PersonLoaderConfig, ID <span class="keyword">int</span>) *Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样我们就可以在其他地方复用<code>PersonLoader</code>了。</p><p>上面的结构体应该用作提供逻辑实现接口而不是用作传递数据。（原文’Structs above should be taken to mean structs that provide logic and/or implement interfaces and does not include structs that are used as Data Transfer Objects’，翻译的有点别扭。）</p><h1 id="解偶"><a href="#解偶" class="headerlink" title="解偶"></a>解偶</h1><p>了解背景后，我们来深入了解一下如何解偶。这个例子中我们有2个对象，<code>Person</code>和<code>BlueShoes</code>分别在2个不同的包中：</p><p><img src="https://i0.wp.com/www.sage42.org/wp-content/uploads/2019/01/step1.png?w=579&amp;ssl=1" alt="img1"></p><p>正如图中所示，它们是高耦合的，<code>Person</code>没法离开<code>BlueShoes</code>单独存在。</p><p>如果你之前使用Java/C++，本能的解偶方法是在<code>shoes</code>包中定义一个接口：<br><img src="https://i1.wp.com/www.sage42.org/wp-content/uploads/2019/01/step2.png?w=609&amp;ssl=1" alt="img2"></p><p>在大多数语言中到此为止了，然而在Go中，我们可以更进一步。</p><p>在我们这么做之前，需要注意一个问题。</p><p>你也许注意到了，<code>Person</code>结构只实现了一个<code>Walk()</code>方法，而在<code>Footwear</code>中实现了<code>Walk()</code>和<code>Run()</code>。这种差异导致了<code>Person</code>和 <code>Footwear</code>之间的关系有些不明确并且违反了Robert C. Martin提出的另一个原则: <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener">接口隔离原则(Interface Segregation Principle ,ISP)</a>。</p><blockquote><p>使用者不应该被强迫依赖那些它们不使用的方法。<br>Clients should not be forced to depend on methods they do not use.<br>Robert C. Martin</p></blockquote><p>幸运的是，我们可以同过在<code>people</code>包中而非<code>shoes</code>包中定义接口来解决这些问题：</p><p><img src="https://i2.wp.com/www.sage42.org/wp-content/uploads/2019/01/step3-1.png?w=582&amp;ssl=1" alt="img3"></p><p>这也许看起来是个小事，不值得为此花费时间，但实际上这是意义深远的。在上面这个例子中2个包完全解偶了，<code>people</code>再也不需要依赖或使用<code>shoes</code>包了。</p><p>通过这种改变，<code>people</code>包更加简洁明了易于发现，而且以后修改<code>shoes</code>包不会影响到<code>people</code>包。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>正如我在《Hands-On Dependency Injection in Go》中写的，Go语言中一个流行的概念和<a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="noopener">Unix哲学</a>相似：</p><blockquote><p>Write programs that do one thing and do it well. Write programs to work together</p></blockquote><p>(这句就不翻译了，翻译的没意境。)</p><p>这个概念充满在Go标准库中，甚至影响到了Go语言的设计。像隐式实现接口（即没有“implements”关键字）使我们（该语言的用户）能够实现解耦代码，这些代码可以用于单一目标并且易于编写。</p><p>低耦合的代码更易于理解，因为你需要的所有信息都在一个地方，反过来说使代码更容易测试和扩展。</p><p>所以下次你看到一个具体的对象作为函数参数或者成员变量，问问自己”这真的必要吗？”，”如果把这个改成接口类型，会不会更加灵活、易于理解和维护？”</p><p>Happy Coding!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.sage42.org/2019/01/30/how-to-fix-tightly-coupled-go-code/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，文章作者也是《Hands-On Dependency Injection in Go》的作者，向原作者表示感谢。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;你是否曾经由于添加某个新功能却导致另一个功能出问题？修复好这个，另一个又出问题，就好象打地鼠一般。&lt;/p&gt;&lt;p&gt;你是否曾经花费大量的时间调试Bug，最后却发现问题潜伏在另一个、甚至毫不相关的模块中？&lt;/p&gt;&lt;p&gt;这些问题都是由于高耦合引起的。&lt;/p&gt;&lt;p&gt;在这篇文章中，我们来使用解偶的方式来让代码更加易于理解、维护、测试。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go get命令使用socket代理</title>
    <link href="http://www.hi-roy.com/2018/10/12/go-get%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8socket%E4%BB%A3%E7%90%86/"/>
    <id>http://www.hi-roy.com/2018/10/12/go-get命令使用socket代理/</id>
    <published>2018-10-12T05:57:35.000Z</published>
    <updated>2019-09-16T08:11:51.490Z</updated>
    
    <content type="html"><![CDATA[<p>由于某些不可描述的原因，国内使用<code>go get</code>命令安装某些包的时候会超时导致失败，比如<code>net</code>包、<code>sys</code>包、<code>tools</code>包等。第一种解决办法就是自己从git上下载后添加链接到<code>GOPATH</code>中，比如：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/golang/net.git <span class="variable">$GOPATH</span>/src/github.com/golang/net</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/sys.git <span class="variable">$GOPATH</span>/src/github.com/golang/sys</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git <span class="variable">$GOPATH</span>/src/github.com/golang/tools</span><br><span class="line"></span><br><span class="line">ln -s <span class="variable">$GOPATH</span>/src/github.com/golang <span class="variable">$GOPATH</span>/src/golang.org/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/  &amp;&amp; mv golang x</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>另外就是使用代理，网上大多是使用http代理，这里记录下如何使用socket代理。<code>go get</code>命令其实也是利用了<code>git</code>命令进行下载，不过下载后会自动编译安装，所以首先设置git的代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:7070</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=socks5://127.0.0.1:7070 go get xxxx</span><br></pre></td></tr></table></figure><p>就可以了。</p><p>恢复的话可以重置git配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于某些不可描述的原因，国内使用&lt;code&gt;go get&lt;/code&gt;命令安装某些包的时候会超时导致失败，比如&lt;code&gt;net&lt;/code&gt;包、&lt;code&gt;sys&lt;/code&gt;包、&lt;code&gt;tools&lt;/code&gt;包等。第一种解决办法就是自己从git上下载后添加链接到&lt;code&gt;GOPATH&lt;/code&gt;中，比如：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/golang/net.git &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang/net&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/golang/sys.git &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang/sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/golang/tools.git &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang/tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ln -s &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/golang.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/golang.org/  &amp;amp;&amp;amp; mv golang x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>IPFS初窥3</title>
    <link href="http://www.hi-roy.com/2018/10/10/IPFS%E5%88%9D%E7%AA%A53/"/>
    <id>http://www.hi-roy.com/2018/10/10/IPFS初窥3/</id>
    <published>2018-10-10T07:26:16.000Z</published>
    <updated>2019-09-16T08:11:51.460Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><p>在<a href="http://www.hi-roy.com/2018/09/19/IPFS%E5%88%9D%E7%AA%A52/">上一篇文章</a>中记录到了IPFS的<code>BitSwap</code>协议，今天接着往下看关于<code>Object</code>的部分。</p><h2 id="Merkle-DAG"><a href="#Merkle-DAG" class="headerlink" title="Merkle DAG"></a>Merkle DAG</h2><p>Merkle DAG是IPFS核心概念之一，在Git的数据结构上进行了改造。理解Merkle DAG之前先来了解下<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener">Merkle Tree</a>。</p><a id="more"></a><p>简单说，Merkle Tree是一种特殊的树结构，其叶子节点的值为包含记录的哈希值，而非叶子节点的值为子节点哈希值合并后的哈希结果，一图胜千言：</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/ipfs3-1.png" alt="ipfs3-1"></p><p>Merkle Tree最常见的一个应用就是数据验证领域了，这种数据结构可以大量减少验证所需传输的数据量，在<code>Top Hash</code>已知的情况下想验证L3中的数据是否被篡改过，只需要向一个可信任的中心请求获取<code>Hash0</code>和<code>Hash1-1</code>即可。</p><p>正由于比特币中将Merkle Tree的根哈希值包含在了区块头中，所以各种轻钱包(SPV)才得以出现。</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/ipfs3-2.png" alt="ipfs3-2"></p><p>而Merkle DAG则是一种　<strong>有向无环图</strong>　结构，而且和Merkle Tree有个很重要的区别就是Merkle DAG中准许非叶节点存储数据。IPFS中数据结构定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IPFSLink <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Hash Multihash</span><br><span class="line">  Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPFSObject <span class="keyword">struct</span>&#123;</span><br><span class="line">  links []IPFSLink</span><br><span class="line">  data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先我们有这样一个目录结构：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipfs</span><br><span class="line">├── imgs</span><br><span class="line">│   └── 1.jpg</span><br><span class="line">├── test.txt</span><br><span class="line">└── video</span><br><span class="line">    └── paxos和分布式系统.mp4</span><br></pre></td></tr></table></figure><p></p><p>然后执行<code>add</code>命令添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipfs add -r ipfs</span><br><span class="line">added QmTBGNDfodpscKje46wyTmzsPsJ6REWebionWK9dVc2Cms ipfs/imgs/1.jpg</span><br><span class="line">added QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ ipfs/test.txt</span><br><span class="line">added Qme5oV4uKLA2BDVjFtqiCfFqv74LZXTqG1oiuu5gshqvk7 ipfs/video/paxos和分布式系统.mp4</span><br><span class="line">added QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK ipfs/imgs</span><br><span class="line">added QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb ipfs/video</span><br><span class="line">added QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4 ipfs</span><br><span class="line"> 53.15 MiB / 53.16 MiB [=============================================================================================================================================================]  99.98%</span><br></pre></td></tr></table></figure><p>这里插一句，在浏览器中访问<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/ipfs/QmTBGNDfodpscKje46wyTmzsPsJ6REWebionWK9dVc2Cms</span><br><span class="line"></span><br><span class="line">http://localhost:8080/ipfs/QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK/1.jpg</span><br><span class="line"></span><br><span class="line">http://localhost:8080/ipfs/QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4/imgs/1.jpg</span><br></pre></td></tr></table></figure><p></p><p>这3种访问路径都可以最终得到<code>1.jpg</code>这个图片。</p><p>可以使用<code>ls</code>命令查看文件切分情况：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipfs ls -v Qme5oV4uKLA2BDVjFtqiCfFqv74LZXTqG1oiuu5gshqvk7</span><br><span class="line">Hash                                           Size     Name</span><br><span class="line">QmexC2a5eSkVuoErKhAjxpMt6DJoQeS57T3yU1cxCpb3Tu 45623854</span><br><span class="line">QmR2GQi1DhvGzZ1Ra1fgpwKBTd9ubt9aPUSCvqMZPHB3cp 10103195</span><br></pre></td></tr></table></figure><p></p><p>可以看出，mp4文件被切分成了2部分。</p><p>再使用<code>object get</code>命令查看<code>ipfs</code>这个文件夹的DAG:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ipfs object get QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;Links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;imgs&quot;,</span><br><span class="line">      &quot;Hash&quot;: &quot;QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK&quot;,</span><br><span class="line">      &quot;Size&quot;: 18418</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;test.txt&quot;,</span><br><span class="line">      &quot;Hash&quot;: &quot;QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ&quot;,</span><br><span class="line">      &quot;Size&quot;: 18</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;video&quot;,</span><br><span class="line">      &quot;Hash&quot;: &quot;QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb&quot;,</span><br><span class="line">      &quot;Size&quot;: 55727234</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;Data&quot;: &quot;\u0008\u0001&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>也和上面给的数据结构定义一致。</p><p>还有更重要的一点，IPFS准许使用者使用<code>block</code>相关命令直接操作Merkle DAG中的数据，比如：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hi roy"</span> | ipfs block put</span><br><span class="line">QmUHW9uK8aKYHNSSJwS1AnnBt1dV6wbKmDWDr8tmRk9pXo</span><br><span class="line"></span><br><span class="line">ipfs block get QmUHW9uK8aKYHNSSJwS1AnnBt1dV6wbKmDWDr8tmRk9pXo</span><br><span class="line"></span><br><span class="line">hi roy</span><br></pre></td></tr></table></figure><p></p><p>有这个功能可玩性就很高了，白皮书中给出了几种结构：</p><ul><li>键值对存储（key-value stores）</li><li>关系型数据库（traditional relatioinal databases）</li><li>三元组存储（Linked Data triple stores）</li><li>文档发布系统（Linked document publishing systems）</li><li>通信平台（Linked communications platforms）</li><li>加密货币区块链（cryptocurrency blockchains）</li></ul><p>再插一句，很多小伙伴不知道如何向已经存在的文件夹中添加新文件，比如想向<code>ipfs</code>目录添加文件<code>test2.txt</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ipfs add test2.txt</span><br><span class="line">added QmUARAWmSHC3aiWhYFcGfQGEyfAKdUPWqFHxemY3iDJDRM test2.txt</span><br><span class="line"> 11 B / 11 B [=======================================================================================================================================================================] 100.00%</span><br><span class="line"></span><br><span class="line"> ipfs ls -v QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4</span><br><span class="line">Hash                                           Size     Name</span><br><span class="line">QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK 18418    imgs/</span><br><span class="line">QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ 18       test.txt</span><br><span class="line">QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb 55727234 video/</span><br></pre></td></tr></table></figure><p></p><p>可以发现文件并没有添加进文件夹中，而仅仅是获得了一个自己的哈希值。可以使用下面的命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipfs object patch add-link QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4 test21.txt QmUARAWmSHC3aiWhYFcGfQGEyfAKdUPWqFHxemY3iDJDRM</span><br><span class="line"></span><br><span class="line">QmZzY6fgW2ndjoAXpa2gMSaJ3c8h6hzq1TFusdF33u2jvy</span><br></pre></td></tr></table></figure><p></p><p>这里会返回一个新的哈希值，查看这个发现文件已经被添加进去了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipfs ls -v QmZzY6fgW2ndjoAXpa2gMSaJ3c8h6hzq1TFusdF33u2jvy</span><br><span class="line">Hash                                           Size     Name</span><br><span class="line">QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK 18418    imgs/</span><br><span class="line">QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ 18       test.txt</span><br><span class="line">QmUARAWmSHC3aiWhYFcGfQGEyfAKdUPWqFHxemY3iDJDRM 19       test21.txt</span><br><span class="line">QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb 55727234 video/</span><br></pre></td></tr></table></figure><p></p><p>注意存储后的文件名是<code>ipfs object patch add-link</code>中指定的值，而不是原文件名。再多说一句，这个命令需要的参数仅仅是哈希值，换言之如果你知道其他人的link地址也可以加到自己的文件下。</p><p>另外，最新的文件系统已经变成IPLD了，是Merkle DAG的一个变种。</p><h2 id="IPNS"><a href="#IPNS" class="headerlink" title="IPNS"></a>IPNS</h2><p>由上面的例子也可以看出来，在IPFS中每次新增、修改某个文件都会导致哈希值的变化，这对于实际应用中是十分不便的。为了处理这个问题，IPFS中引入了一个可变命名空间的概念——IPNS(InterPlanetary Name Space)，结合之前说的 <strong>路由系统</strong> 实现了”不可变的内容”和”可变的引用”的组合(可以结合编程语言中指针的概念)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routing.setValue(NodeId,&lt;ns-object-hash&gt;)</span><br></pre></td></tr></table></figure><p>之前说过每个节点的NodeID来源与其公钥的哈希值，那么给每个节点分配一个可变命名空间<code>/ipns/&lt;NodeID&gt;</code>，用户将私钥签名过的数据发布到这个路径上，别的用户下载这个数据时可以检查签名是否和公钥、NodeID匹配来验证真实性。</p>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;&lt;p&gt;在&lt;a href=&quot;http://www.hi-roy.com/2018/09/19/IPFS%E5%88%9D%E7%AA%A52/&quot;&gt;上一篇文章&lt;/a&gt;中记录到了IPFS的&lt;code&gt;BitSwap&lt;/code&gt;协议，今天接着往下看关于&lt;code&gt;Object&lt;/code&gt;的部分。&lt;/p&gt;&lt;h2 id=&quot;Merkle-DAG&quot;&gt;&lt;a href=&quot;#Merkle-DAG&quot; class=&quot;headerlink&quot; title=&quot;Merkle DAG&quot;&gt;&lt;/a&gt;Merkle DAG&lt;/h2&gt;&lt;p&gt;Merkle DAG是IPFS核心概念之一，在Git的数据结构上进行了改造。理解Merkle DAG之前先来了解下&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Merkle Tree&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPFS初窥2</title>
    <link href="http://www.hi-roy.com/2018/09/19/IPFS%E5%88%9D%E7%AA%A52/"/>
    <id>http://www.hi-roy.com/2018/09/19/IPFS初窥2/</id>
    <published>2018-09-19T02:52:06.000Z</published>
    <updated>2019-09-16T08:11:51.460Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><p>在<a href="http://www.hi-roy.com/2018/09/04/IPFS%E5%88%9D%E7%AA%A5/">上一篇文章</a>中初步介绍了IPFS的基本概念和使用方法，今天更深入一些了解IPFS的设计理念。</p><p>根据 <strong>第三版</strong> 白皮书，IPFS体系可以分为7层：</p><ol><li>身份：负责节点的身份生成和认证。</li><li>网络：负责节点间的网络连接，可以配置使用各种网络协议。</li><li>路由：维护路由信息来找出特定的节点和对象。默认使用DHT，可以替换。</li><li>交换：一个新型的块交换协议(BitSwap)来高效管理块分发。有点类似超市，对数据复制有激励。交易策略可以替换。</li><li>对象：带有链接的、内容寻址的不可变对象组成的Merkle DAG，可以代表任意数据结构。比如文件层级和通信系统。</li><li>文件：受到Git启发的版本控制文件层级系统。</li><li>命名：自验证的可变命名系统。</li></ol><a id="more"></a><h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><p>节点间通过<code>NodeID</code>来识别彼此之间的身份，而<code>NodeID</code>是根据公钥和<code>S/Kademlia</code>静态加密算法生成的，一个节点可以生成多个<code>NodeID</code>，但这种行为将失去某些“好处”，至于什么好处在BitSwap时候细说。</p><p>文中还给了生成<code>NodeID</code>的伪代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">difficulty = &lt;integet parameter&gt;</span><br><span class="line">n = Node&#123;&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">  n.PubKey,n.PrivKey = PKI.genKeyPair()</span><br><span class="line">  n.NodeID = hash(n.PubKey)</span><br><span class="line">  p = count_preceding_zero_bits((hash(n.NodeId)))</span><br><span class="line">&#125;while (p &lt; difficulty)</span><br></pre></td></tr></table></figure><p></p><p>代码比较好理解这里就不多解释，当节点间第一次建立链接时候会交换公钥，并且计算哈希值，如果不匹配则终止链接。另外IPFS更倾向于使用能自解释的哈希格式，比如使用了哪个哈希函数、摘要长度：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;function code&gt;&lt;digest length&gt;&lt;digest bytes&gt;</span><br></pre></td></tr></table></figure><p></p><p>这样做的好处有2个：</p><ol><li>可以根据实际情况选择合适的函数(安全性Vs高性能)</li><li>可以根据选择函数的不同而演变。自描述的值准许使用兼容的、不同的参数。</li></ol><h2 id="网络和路由"><a href="#网络和路由" class="headerlink" title="网络和路由"></a>网络和路由</h2><p>这两个相对好理解就放一起记录了。</p><p>IPFS可以使用任何传输协议，但最适合的是<code>WebRTC DataChannels</code>和<code>uTP</code>，同时基于<code>uTP</code>提供了可靠传输。并且支持<code>ICE NAT</code>穿透技术，还可以选择检查哈希值来保证消息完整性，并通过使用HAMC以及发送方的公钥来保证真实性。</p><p>正是因为可以使用各种传输协议，所以IPFS也可使用<code>覆盖网络(overlay networks)</code>。因此IPFS使用多层地址的格式来存储地址信息。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sctp/ipv4链接</span><br><span class="line"></span><br><span class="line">/ip4/10.20.30.40/sctp/1234/</span><br><span class="line"></span><br><span class="line"># 通过tcp/ipv4代理的sctp/ipv4链接</span><br><span class="line">/ipo/5.6.7.8/tcp/5678/ip4/1.3.4.5/sctp/1234/</span><br></pre></td></tr></table></figure><p>IPFS通过使用路由来寻找其他节点的网络地址和谁可以提供特定的对象。基于DSHT、Coral和S/Kademila。IPFS DHT根据大小来使用不同的存储方式，比如小文件(小于1KB)直接存在DHT中，而大文件则存储那些可以提供数据的节点的引用。</p><p>另外不同的场景可以使用不同的路由系统，比如DHT用于广域网，静态HT用于本地网络。所以根据不同场景路由系统是可以改变的，只要实现了相应的接口。</p><h2 id="块交换——BitSwap协议"><a href="#块交换——BitSwap协议" class="headerlink" title="块交换——BitSwap协议"></a>块交换——BitSwap协议</h2><p>BitSwap协议灵感来源于Bittorrent，使用<code>want_list</code>来记录自己想要什么，<code>have_list</code>来记录自己有什么。和Bittorrent不同的是BitSwap不关注数据块来源于哪个文件。为了解决“吸血节点”问题，IPFS引入了信用机制：</p><ol><li>节点通过账本记录和其他节点之间的收(负债)发(信用)字节长度。</li><li>根据不同的负债率，是否发送数据的概率不同。</li></ol><p>如果一个节点决定不发送数据给请求方，随后则会根据<code>ignore_cooldown</code>时间来忽略接下来这个节点的请求，以便防止DDos攻击。</p><p>负债率的计算公式为：</p><p>$$r=\frac{bytes sent}{bytes recv+1}$$</p><p>分母加1防止出现除以0的异常。已知r后，发送数据的概率P为：</p><p>$$P(send|r)=1-\frac{1}{1+\exp(6-3r)}$$</p><p>这里有个点要注意，节点A的负债(debt)就是节点B的信用(credit)，以<code>go-bitswap</code>中关于账本的代码为例，来源于<code>decision\ledger.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ledger <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Partner is the remote Peer.</span></span><br><span class="line">Partner peer.ID</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accounting tracks bytes sent and received.</span></span><br><span class="line">Accounting debtRatio</span><br><span class="line"></span><br><span class="line"><span class="comment">// lastExchange is the time of the last data exchange.</span></span><br><span class="line">lastExchange time.Time</span><br><span class="line"></span><br><span class="line"><span class="comment">// exchangeCount is the number of exchanges with this peer</span></span><br><span class="line">exchangeCount <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wantList is a (bounded, small) set of keys that Partner desires.</span></span><br><span class="line">wantList *wl.Wantlist</span><br><span class="line"></span><br><span class="line"><span class="comment">// sentToPeer is a set of keys to ensure we dont send duplicate blocks</span></span><br><span class="line"><span class="comment">// to a given peer</span></span><br><span class="line">sentToPeer <span class="keyword">map</span>[<span class="keyword">string</span>]time.Time</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref is the reference count for this ledger, its used to ensure we</span></span><br><span class="line"><span class="comment">// don't drop the reference to this ledger in multi-connection scenarios</span></span><br><span class="line">ref <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">lk sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> debtRatio <span class="keyword">struct</span> &#123;</span><br><span class="line">BytesSent <span class="keyword">uint64</span></span><br><span class="line">BytesRecv <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *debtRatio)</span> <span class="title">Value</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(dr.BytesSent) / <span class="keyword">float64</span>(dr.BytesRecv+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ledger)</span> <span class="title">SentBytes</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">l.exchangeCount++</span><br><span class="line">l.lastExchange = time.Now()</span><br><span class="line">l.Accounting.BytesSent += <span class="keyword">uint64</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ledger)</span> <span class="title">ReceivedBytes</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">l.exchangeCount++</span><br><span class="line">l.lastExchange = time.Now()</span><br><span class="line">l.Accounting.BytesRecv += <span class="keyword">uint64</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子方便理解：假设有A、B两个节点，目前A向B发送了60个字节的数据，从B接收了100字节数据，那么对于B来说则是向A发送100字节数据、接收60字节数据。当A再次向B请求下载数据时，B就会根据自己的账本计算负债率，并决定是否接受这次请求。</p><p>块交换生命周期大体分成4种：</p><ol><li>open：发送账本直到对方同意。</li><li>sending：交换want_list和数据块。</li><li>close：关闭链接。</li><li>ignore：这个只有在策略是避免发送时候才会出现。</li></ol><p>白皮书中说，在open阶段节点A会创建一个新账本或者使用旧账本发送给节点B，而B则在ignore_cooldown超时时间内概率性的决定忽略还是接受这次请求。(原文是:This should be done probabilistically with an ignore_cooldown timeout)。此外，如果决定了接受这次请求，则使用本地账本新建一个peer对象并修改账本的<code>last_seen</code>时间戳，然后比较接收到的账本和对方发来的账本是否一致，一致则建立链接，否则初始化一个空账本并发送。</p><blockquote><p>这里Roy我有个疑惑，在<code>go-ipfs</code>源码中找了很多地方都没找到这个”概率性忽略或接受请求”以及对比账本是否一致部分的代码，甚至上面计算概率的公式都没找到，希望知道这部分代码实现位置的大佬能够指点一下小弟，先谢谢了。</p></blockquote><p>建立链接后就可以开始交换数据了。在<code>go-ipfs</code>中，want_list是一个字典，定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wantlist <span class="keyword">struct</span> &#123;</span><br><span class="line">set <span class="keyword">map</span>[<span class="keyword">string</span>]*Entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">Cid      cid.Cid</span><br><span class="line">Priority <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">SesTrk <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>block则更简洁:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicBlock <span class="keyword">struct</span> &#123;</span><br><span class="line">cid  cid.Cid</span><br><span class="line">data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在IPFS中，文件被分为若干Blocks，Block使用一个叫做<code>CID</code>标识符来索引，这是一个自描述的索引结构体，用来唯一标识一个Block。所以要想从节点下载一个Block，只需在知道<code>CID</code>即可，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cid represents a self-describing content adressed</span></span><br><span class="line"><span class="comment">// identifier. It is formed by a Version, a Codec (which indicates</span></span><br><span class="line"><span class="comment">// a multicodec-packed content type) and a Multihash.</span></span><br><span class="line"><span class="keyword">type</span> Cid <span class="keyword">struct</span>&#123; str <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCidV0 returns a Cid-wrapped multihash.</span></span><br><span class="line"><span class="comment">// They exist to allow IPFS to work with Cids while keeping</span></span><br><span class="line"><span class="comment">// compatibility with the plain-multihash format used used in IPFS.</span></span><br><span class="line"><span class="comment">// NewCidV1 should be used preferentially.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCidV0</span><span class="params">(mhash mh.Multihash)</span> <span class="title">Cid</span></span> &#123;</span><br><span class="line"><span class="comment">// Need to make sure hash is valid for CidV0 otherwise we will</span></span><br><span class="line"><span class="comment">// incorrectly detect it as CidV1 in the Version() method</span></span><br><span class="line">dec, err := mh.Decode(mhash)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dec.Code != mh.SHA2_256 || dec.Length != <span class="number">32</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"invalid hash for cidv0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Cid&#123;<span class="keyword">string</span>(mhash)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCidV1 returns a new Cid using the given multicodec-packed</span></span><br><span class="line"><span class="comment">// content type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCidV1</span><span class="params">(codecType <span class="keyword">uint64</span>, mhash mh.Multihash)</span> <span class="title">Cid</span></span> &#123;</span><br><span class="line">hashlen := <span class="built_in">len</span>(mhash)</span><br><span class="line"><span class="comment">// two 8 bytes (max) numbers plus hash</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>*binary.MaxVarintLen64+hashlen)</span><br><span class="line">n := binary.PutUvarint(buf, <span class="number">1</span>)</span><br><span class="line">n += binary.PutUvarint(buf[n:], codecType)</span><br><span class="line">cn := <span class="built_in">copy</span>(buf[n:], mhash)</span><br><span class="line"><span class="keyword">if</span> cn != hashlen &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"copy hash length is inconsistent"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Cid&#123;<span class="keyword">string</span>(buf[:n+hashlen])&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>ipfs daemon</code>后，可以使用<code>ipfs bitswap stat</code>来查看整体的情况：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % ipfs bitswap stat</span><br><span class="line">bitswap status</span><br><span class="line">provides buffer: 0 / 256</span><br><span class="line">blocks received: 760</span><br><span class="line">blocks sent: 11</span><br><span class="line">data received: 195407444</span><br><span class="line">data sent: 2883738</span><br><span class="line">dup blocks received: 75</span><br><span class="line">dup data received: 18 MB</span><br><span class="line">wantlist [6 keys]</span><br><span class="line">QmeUUfUS4DMsKzMkTda3iunruYMvJEwDfGnF7KBAt2smwJ</span><br><span class="line">QmcQQyNtMy3Z1fekutzjwkZCPHXwVvs4ZqgiboMBbc2H3A</span><br><span class="line">Qmc4XdqSLbyjYGsaZihb1nGhNAWbU8hKmmUNeUjExsLQyi</span><br><span class="line">QmYxE2fXENrJvuzES3Tyive4o1zp9VoNJD5bft4soyv1H2</span><br><span class="line">QmPmLZxuK4hAk9kx6mipvXvUjbtMxTXXnbbahP2VicYLeu</span><br><span class="line">QmRtJugMr7yPPS7Kw5azRQaj3VB774ARSLJfw7gsKM1fzt</span><br><span class="line">partners [936]</span><br><span class="line">QmNMTsUaKTDdunSUN44TZuMPDpGTCLG8R2ooEo1ZmxJadq</span><br><span class="line">QmNPNDYybTYcZK2KBrrn24M4Lc7VcPnGDNX8ueur9TRCmK</span><br><span class="line">QmNQC6nB2LACt1h6nkJdFz1vaFRP5iTHeB1p9nsfpk4nnM</span><br><span class="line">QmNRPRpbgM1WTEUo4T4sadsASmBudPKqYupdtZcSoFkvSL</span><br><span class="line">QmNRSBnfjE6PMZ5AfnLccWpMjX2LtRFYedxQ2UqQxvozfV</span><br><span class="line">QmNRV7kyUxYaQ4KQxFXPYm8EfuzJbtGn1wSFenjXL6LD8y</span><br><span class="line">QmNUCfyL67rqBesyCLon9kRUpXtPEfVUzf7aGp1VXqGqW4</span><br><span class="line">QmNV721hfbzxuLdBvLaBpzmKtnPP4duf59SZ3AU1fV5CrK</span><br></pre></td></tr></table></figure><p></p><p>也可以使用<code>ipfs bitswap ledger NodeID</code>来具体查看和某个节点之间的债务关系。</p><p>本文最后来个彩蛋吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%ipfs get Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t                                                                                                                 </span><br><span class="line">Saving file(s) to Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t</span><br><span class="line">322.39 MiB / 322.39 MiB[====================================================================================================================================================] 100.00% 17m47s</span><br></pre></td></tr></table></figure><p>然后把下载好的文件后缀改成<code>mp4</code>，慢慢欣赏。</p>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;&lt;p&gt;在&lt;a href=&quot;http://www.hi-roy.com/2018/09/04/IPFS%E5%88%9D%E7%AA%A5/&quot;&gt;上一篇文章&lt;/a&gt;中初步介绍了IPFS的基本概念和使用方法，今天更深入一些了解IPFS的设计理念。&lt;/p&gt;&lt;p&gt;根据 &lt;strong&gt;第三版&lt;/strong&gt; 白皮书，IPFS体系可以分为7层：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;身份：负责节点的身份生成和认证。&lt;/li&gt;&lt;li&gt;网络：负责节点间的网络连接，可以配置使用各种网络协议。&lt;/li&gt;&lt;li&gt;路由：维护路由信息来找出特定的节点和对象。默认使用DHT，可以替换。&lt;/li&gt;&lt;li&gt;交换：一个新型的块交换协议(BitSwap)来高效管理块分发。有点类似超市，对数据复制有激励。交易策略可以替换。&lt;/li&gt;&lt;li&gt;对象：带有链接的、内容寻址的不可变对象组成的Merkle DAG，可以代表任意数据结构。比如文件层级和通信系统。&lt;/li&gt;&lt;li&gt;文件：受到Git启发的版本控制文件层级系统。&lt;/li&gt;&lt;li&gt;命名：自验证的可变命名系统。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPFS初窥</title>
    <link href="http://www.hi-roy.com/2018/09/04/IPFS%E5%88%9D%E7%AA%A5/"/>
    <id>http://www.hi-roy.com/2018/09/04/IPFS初窥/</id>
    <published>2018-09-04T02:41:30.000Z</published>
    <updated>2019-09-16T08:11:51.459Z</updated>
    
    <content type="html"><![CDATA[<p>虽然区块链有很多令人兴奋的特性，但是也有其固有的缺点。比如，文件或者长度较长的文本信息就不适合存储在链上。那么如何解决这个缺点呢？一个解决方案就是IPFS(Interplanetary File System)——星际文件系统。</p><p>本文作为简介篇不打算涉及网络及数据结构相关知识(比如什么是协议、什么是树、什么是图……)，不过我相信各位看官既然能找到本文网络基础应该不是问题。</p><a id="more"></a><h2 id="为什么需要IPFS"><a href="#为什么需要IPFS" class="headerlink" title="为什么需要IPFS?"></a>为什么需要IPFS?</h2><p>说这个之前，我们看看现在互联网基石 —— <a href="https://baike.baidu.com/link?url=OBnU342D_H3DsMIofgdDvKsuy42D6BIdvLtFH7Y62gaeTON6Znlw_9ADYFHI4qPR5u9Bdw4dfPI1VueLNQRnpq" target="_blank" rel="noopener">HTTP协议</a>，网址(URL)由几部份构成:</p><ol><li>协议</li><li>服务器地址（IP地址，或者域名)</li><li>端口</li><li>路径</li><li>参数</li></ol><p>HTTP是路径(位置)导向的、中心化的，而IPFS则是资源导向的、分布式的。以网站举例，如果某个网站服务器关闭，那么如果没有其他三方对其进行过快照的话，基本就是再也看不到上面的内容了。而IPFS则不然，只要IPFS网络中有对应的副本，则不会因为某个”人”删除资源而导致无法访问。(单点问题)</p><p>老司机应该觉得眼熟，这不就和BT种子类似么？是的，IPFS结合了Git版本系统、Bittorrent、DHT等技术。也正因如此，IPFS刚好可以用来弥补区块链不适合存储文件或长文本这个缺陷。</p><p>基于路径导向还会导致某些安全问题，假定你需要下载<code>http://www.aa.com/file.zip</code>这个文件，如果这个文件被替换成木马病毒一类的，客户端是无法判断数据是否被更改的。换言之，客户端只知道”在哪里”，而不知道”是什么”。</p><p>此外，随着媒体类资源如音频、视频越发流行，带宽资源也越发成为限制HTTP传输速度的瓶颈。而如果你需要的资源在IPFS存在，则会自动选择一个最近的下载，传输速度大大提升。</p><h2 id="什么是IPFS"><a href="#什么是IPFS" class="headerlink" title="什么是IPFS?"></a>什么是IPFS?</h2><p>官网原话:</p><blockquote><p>IPFS aims to replace HTTP and build a better web for all of us.</p></blockquote><p>翻译过来就是：IPFS是来干掉现有HTTP协议、带领农奴翻身的。所以咧，<a href="https://ipfs.io/" target="_blank" rel="noopener">官网</a>就被”墙”了。但从技术角度，更好的解释在<a href="https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf" target="_blank" rel="noopener">白皮书</a>中。</p><p>白皮书标题就3点：</p><ul><li>内容寻址：通过文件内容生成唯一哈希值来标识文件，而不是通过文件保存位置来标识。相同内容的文件在系统中只会存在一份，节约存储空间。</li><li>版本化：可追溯文件修改历史。（参照git、svn）</li><li>点对点文件系统：P2P保存各种各样类型的数据。</li></ul><p>涉及的技术点有5个:</p><ol><li>分布式哈希表(DHT)</li><li>块交换</li><li>Merkle DAG</li><li>版本控制系统</li><li>自验证文件系统(SFS)</li></ol><p>上面的技术点基本每个都能写一系列文章，这里就简单说一下，如果有时间以后再补充完善。(没错，我又开始挖坑了！)</p><p>DHT被广泛用于维护协调p2p网络的元数据，比如BitTorrent中的<code>MainlineDHT</code>就追踪了torrent网络中节点的集合。而IPFS中则是结合了<code>Coral DSHT</code>和<code>S/Kademlia DHT</code>，这两个都是<code>Kademlia DHT</code>的扩展。(再简单说就是用来查找节点的。)</p><p>块交换，IPFS在BitTorrent的基础上实现了更通用的版本——<code>BitSwap</code>，这也是<a href="https://filecoin.io/" target="_blank" rel="noopener">Filecoin</a>的基础。</p><p>Merkle DAG，如果涉及过轻钱包应用的应该知道Merkle Tree，在Merkle Tree中每个父节点的值都是其子节点值的哈希。Merkle DAG则是Merkle Tree和有向无环图(DAG)的结合体，广义上所有数据都在Merkle DAG进行建模，这是保证数据正确、安全传输的关键点。</p><p>版本控制，这个不用多说了吧？</p><p>自验证文件系统(Self-certifying File System,SFS)是一种不需要特殊权限的分布式文件系统，因为每个用户上传是生成的文件名已经是经过其私钥签名过的了。在这个基础上，又可以引出星际命名空间(InterPlanetary Name Space,IPNS)的概念。之前说过IPFS上的文件哈希后都是唯一识别的，推广开来，每个节点也有公钥、私钥和节点ID，节点ID是其公钥的哈希值，节点可以使用私钥来对其发布的数据签名，其他用户检索时，可以检查发送者的公钥来验证数据真实性。</p><h2 id="如何使用IPFS"><a href="#如何使用IPFS" class="headerlink" title="如何使用IPFS?"></a>如何使用IPFS?</h2><p>首先下载<a href="https://dist.ipfs.io/#go-ipfs" target="_blank" rel="noopener">go-ipfs</a>，我这里直接使用linux版本的，解压后执行:<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">go-ipfs❯ sudo sh install.sh</span><br><span class="line">[sudo] password <span class="keyword">for</span> roy:</span><br><span class="line">Moved ./ipfs to /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">go-ipfs❯ ipfs init</span><br><span class="line">initializing IPFS node at /home/roy/.ipfs</span><br><span class="line">generating 2048-bit RSA keypair...done</span><br><span class="line">peer identity: QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC</span><br><span class="line">to get started, enter:</span><br><span class="line"></span><br><span class="line">ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</span><br><span class="line"></span><br><span class="line">go-ipfs❯ ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</span><br><span class="line">Hello and Welcome to IPFS!</span><br><span class="line"></span><br><span class="line">██╗██████╗ ███████╗███████╗</span><br><span class="line">██║██╔══██╗██╔════╝██╔════╝</span><br><span class="line">██║██████╔╝█████╗  ███████╗</span><br><span class="line">██║██╔═══╝ ██╔══╝  ╚════██║</span><br><span class="line">██║██║     ██║     ███████║</span><br><span class="line">╚═╝╚═╝     ╚═╝     ╚══════╝</span><br><span class="line"></span><br><span class="line">If you seeing this, you have successfully installed</span><br><span class="line">IPFS and are now interfacing with the ipfs merkledag!</span><br><span class="line"></span><br><span class="line"> -------------------------------------------------------</span><br><span class="line">| Warning:                                              |</span><br><span class="line">|   This is alpha software. Use at your own discretion! |</span><br><span class="line">|   Much is missing or lacking polish. There are bugs.  |</span><br><span class="line">|   Not yet secure. Read the security notes <span class="keyword">for</span> more.   |</span><br><span class="line"> -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Check out some of the other files <span class="keyword">in</span> this directory:</span><br><span class="line"></span><br><span class="line">  ./about</span><br><span class="line">  ./<span class="built_in">help</span></span><br><span class="line">  ./quick-start     &lt;-- usage examples</span><br><span class="line">  ./readme          &lt;-- this file</span><br><span class="line">  ./security-notes</span><br></pre></td></tr></table></figure><p></p><p>建议使用提示中的哦命令看看<code>quick-start</code>，常用操作都在里面了。</p><p>然后启动ipfs服务：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">go-ipfs❯ ipfs daemon</span><br><span class="line">Initializing daemon...</span><br><span class="line">Successfully raised file descriptor limit to 2048.</span><br><span class="line"></span><br><span class="line">Swarm listening on /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/172.17.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/172.18.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.1.104/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.124.1/tcp/4001</span><br><span class="line">Swarm listening on /ip6/::1/tcp/4001</span><br><span class="line">Swarm listening on /p2p-circuit/ipfs/QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC</span><br><span class="line">Swarm announcing /ip4/100.64.109.213/tcp/12182</span><br><span class="line">Swarm announcing /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/172.17.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/172.18.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.1.104/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.124.1/tcp/4001</span><br><span class="line">Swarm announcing /ip6/::1/tcp/4001</span><br><span class="line">API server listening on /ip4/127.0.0.1/tcp/5001</span><br><span class="line">Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure><p></p><p>然后访问<code>http://localhost:5001/webui</code>可以查看系统信息、创建文件夹、添加文件等。</p><p>添加个文件：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ » mkdir roy_test</span><br><span class="line">~ » <span class="built_in">echo</span> <span class="string">"www.hi-roy.com"</span> &gt; roy_test/roy.txt</span><br><span class="line">~ » ipfs add -r roy_test</span><br><span class="line">added QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd roy_test/roy.txt</span><br><span class="line">added QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx roy_test</span><br></pre></td></tr></table></figure><p></p><p>然后测试下文件是否添加成功：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipfs ls QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx</span><br><span class="line">QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd 23 roy.txt</span><br><span class="line"></span><br><span class="line">ipfs cat /ipfs/QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd</span><br><span class="line">www.hi-roy.com</span><br></pre></td></tr></table></figure><p></p><p>也可以通过本地网关访问<code>http://localhost:8080/ipfs/QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd</code>。</p><p>然后我们来修改一下文件：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"www.hi-roy.com"</span> &gt;&gt; roy_test/roy.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"www.hi-roy.com"</span> &gt;&gt; roy_test/roy.txt</span><br><span class="line">ipfs add roy_test/roy.txt</span><br><span class="line">added QmUcwEGLBhLKYG7X1DrbMbbSKSJ3GbDHWibymwXqUG1PCK roy.txt</span><br></pre></td></tr></table></figure><p></p><p>注意，修改文件后哈希值发生了变化，原来的文件依然存在。但每次更新文件都有一个新哈希也太麻烦了，这时可以使用上面说的<code>IPNS</code>了:<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipfs name publish QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx</span><br><span class="line">Published to QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC: /ipfs/QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx</span><br></pre></td></tr></table></figure><p></p><p>这里我把文件夹的哈希值作为根发布，然后就可以使用<code>ipns</code>查看文件了：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipfs cat /ipns/QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC/roy.txt</span><br><span class="line"></span><br><span class="line">www.hi-roy.com</span><br><span class="line">www.hi-roy.com</span><br><span class="line">www.hi-roy.com</span><br></pre></td></tr></table></figure><p></p><p>以后更新文件后再publish就可以了。不过 <strong>使用ipns会很慢</strong>。</p><h2 id="使用IPFS时应该注意？"><a href="#使用IPFS时应该注意？" class="headerlink" title="使用IPFS时应该注意？"></a>使用IPFS时应该注意？</h2><p>永久性(Permanence)不等同于持久性(Persistence)。</p><blockquote><p>Objects are permanent。</p></blockquote><p>也就是说，你在IPFS网络中上传了某个文件，指向你这个文件的链接是永久不变的，但如果每个节点都觉得这个文件没什么价值而将其删除，那么这个文件是会”消失”的。</p><h2 id="IPFS的应用领域"><a href="#IPFS的应用领域" class="headerlink" title="IPFS的应用领域?"></a>IPFS的应用领域?</h2><p>白皮书3.8节提到了12个应用场景：</p><ol><li>作为全球文件系统挂载到<code>/ipfs</code>和<code>/ipns</code>下。</li><li>作为个人同步文件夹自动控制版本、推送、备份。</li><li>作为加密文件或者数据共享系统。</li><li>作为所有软件的版本控制器。</li><li>作为虚拟机的根文件系统。</li><li>作为VM的引导文件。</li><li>作为数据库:程序可以直接写入Merkle DAG数据模型，并获得IPFS提供的版本控制、缓存、分发功能。</li><li>作为一个加密的通信平台。</li><li>作为一个大文件完整性校验的CDN平台(不需要SSL)。</li><li>作为加密CDN。</li><li>作为网站CDN。</li><li>作为一个永远不会消失的网站。</li></ol><p>利用IPFS的项目比较多，但大多处于探索阶段，杀手级的目前还没出现。这里给大家介绍我认为比较有意思的：</p><ol><li><a href="https://akasha.world/" target="_blank" rel="noopener">akasha</a>，号称下一代社交网络，测试玩的话chrome浏览器可以装个<code>MetaMask</code>插件，并将网络设置为<code>Rinkeby Test Network</code>。</li><li><a href="https://github.com/ipfs/distributed-wikipedia-mirror" target="_blank" rel="noopener">基于IPFS的维基百科</a>，维基百科镜像。</li><li><a href="https://livepeer.org/" target="_blank" rel="noopener">livepeer</a>，去中心化流媒体平台，可以贡献自己的带宽获取token。</li></ol><p><img src="https://cdn-images-1.medium.com/max/800/1*N3BFp35i_jfTo7RMHsDNwg.jpeg" alt="应用"></p><h2 id="IPFS的缺点"><a href="#IPFS的缺点" class="headerlink" title="IPFS的缺点?"></a>IPFS的缺点?</h2><p>目前觉得缺点有２个：</p><ol><li><p>域名不友好，比如<code>ipfs.io/ipns/Qmxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/</code>。当然可以引入域名系统DNS，但又会面临现有DNS系统的各种缺陷，比如域名污染等。</p></li><li><p>数据节点没动力维持网络数据的长期备份，如果所有的数据节点都将某份数据清除来节省空间，理论上这个文件最终会”消失”。为了缓解这个问题，引入了<code>FileCoin</code>来为IPFS添加经济激励，毕竟有句话叫做”无利不起早”么。</p></li></ol><p>写到这让我想起了《人月神话》中的经典台词：</p><blockquote><p>没有银弹。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然区块链有很多令人兴奋的特性，但是也有其固有的缺点。比如，文件或者长度较长的文本信息就不适合存储在链上。那么如何解决这个缺点呢？一个解决方案就是IPFS(Interplanetary File System)——星际文件系统。&lt;/p&gt;&lt;p&gt;本文作为简介篇不打算涉及网络及数据结构相关知识(比如什么是协议、什么是树、什么是图……)，不过我相信各位看官既然能找到本文网络基础应该不是问题。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>墨卡托坐标转经纬度</title>
    <link href="http://www.hi-roy.com/2018/07/30/%E5%A2%A8%E5%8D%A1%E6%89%98%E5%9D%90%E6%A0%87%E8%BD%AC%E7%BB%8F%E7%BA%AC%E5%BA%A6/"/>
    <id>http://www.hi-roy.com/2018/07/30/墨卡托坐标转经纬度/</id>
    <published>2018-07-30T07:52:40.000Z</published>
    <updated>2019-09-16T08:11:51.523Z</updated>
    
    <content type="html"><![CDATA[<p>今天获取百度地图数据时候发现其坐标都是类似<code>12945050.96,4826978.52</code>这种而非常见的经纬度，之前获取百度外面商家信息时就发现了这个问题但没深入研究，搜索后发现这种表示方法叫做<code>墨卡托坐标</code>。不得不说，关于坐标的标准还真是挺多的，根据经纬度查询位置可以使用<a href="http://www.gpsspg.com/maps.htm" target="_blank" rel="noopener">这个网站</a>。</p><a id="more"></a><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mcband = [<span class="number">6</span>]<span class="keyword">float64</span>&#123;<span class="number">12890594.86</span>, <span class="number">8362377.87</span>, <span class="number">5591021</span>, <span class="number">3481989.83</span>, <span class="number">1678043.12</span>, <span class="number">0.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> mc2ll = [<span class="number">6</span>][<span class="number">10</span>]<span class="keyword">float64</span>&#123;</span><br><span class="line">&#123;<span class="number">1.410526172116255e-8</span>, <span class="number">0.00000898305509648872</span>, <span class="number">-1.9939833816331</span>,</span><br><span class="line"><span class="number">200.9824383106796</span>, <span class="number">-187.2403703815547</span>, <span class="number">91.6087516669843</span>, <span class="number">-23.38765649603339</span>,</span><br><span class="line"><span class="number">2.57121317296198</span>, <span class="number">-0.03801003308653</span>, <span class="number">17337981.2</span>&#125;,</span><br><span class="line">&#123;<span class="number">-7.435856389565537e-9</span>, <span class="number">0.000008983055097726239</span>, <span class="number">-0.78625201886289</span>,</span><br><span class="line"><span class="number">96.32687599759846</span>, <span class="number">-1.85204757529826</span>, <span class="number">-59.36935905485877</span>, <span class="number">47.40033549296737</span>,</span><br><span class="line"><span class="number">-16.50741931063887</span>, <span class="number">2.28786674699375</span>, <span class="number">10260144.86</span>&#125;,</span><br><span class="line">&#123;<span class="number">-3.030883460898826e-8</span>, <span class="number">0.00000898305509983578</span>, <span class="number">0.30071316287616</span>,</span><br><span class="line"><span class="number">59.74293618442277</span>, <span class="number">7.357984074871</span>, <span class="number">-25.38371002664745</span>, <span class="number">13.45380521110908</span>,</span><br><span class="line"><span class="number">-3.29883767235584</span>, <span class="number">0.32710905363475</span>, <span class="number">6856817.37</span>&#125;,</span><br><span class="line">&#123;<span class="number">-1.981981304930552e-8</span>, <span class="number">0.000008983055099779535</span>, <span class="number">0.03278182852591</span>, <span class="number">40.31678527705744</span>,</span><br><span class="line"><span class="number">0.65659298677277</span>, <span class="number">-4.44255534477492</span>, <span class="number">0.85341911805263</span>, <span class="number">0.12923347998204</span>,</span><br><span class="line"><span class="number">-0.04625736007561</span>, <span class="number">4482777.06</span>&#125;,</span><br><span class="line">&#123;<span class="number">3.09191371068437e-9</span>, <span class="number">0.000008983055096812155</span>, <span class="number">0.00006995724062</span>, <span class="number">23.10934304144901</span>,</span><br><span class="line"><span class="number">-0.00023663490511</span>, <span class="number">-0.6321817810242</span>, <span class="number">-0.00663494467273</span>, <span class="number">0.03430082397953</span>,</span><br><span class="line"><span class="number">-0.00466043876332</span>, <span class="number">2555164.4</span>&#125;,</span><br><span class="line">&#123;<span class="number">2.890871144776878e-9</span>, <span class="number">0.000008983055095805407</span>, <span class="number">-3.068298e-8</span>, <span class="number">7.47137025468032</span>,</span><br><span class="line"><span class="number">-0.00000353937994</span>, <span class="number">-0.02145144861037</span>, <span class="number">-0.00001234426596</span>, <span class="number">0.00010322952773</span>,</span><br><span class="line"><span class="number">-0.00000323890364</span>, <span class="number">826088.5</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159265358979324</span> * <span class="number">3000.0</span> / <span class="number">180.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ConvertMCT_2_BD09 将墨卡托坐标转换被BD09坐标（百度地图专用）</span></span><br><span class="line"><span class="comment">// log 经度 lat纬度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertMCT_2_BD09</span><span class="params">(lon, lat <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lat &lt; <span class="number">0.0</span>) || (lon &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line"><span class="comment">//国内经纬度都是正数</span></span><br><span class="line">log.Fatal(<span class="string">"lat and lon must greater than 0!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ax [<span class="number">10</span>]<span class="keyword">float64</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> mcband &#123;</span><br><span class="line"><span class="keyword">if</span> lat &gt;= v &#123;</span><br><span class="line">ax = mc2ll[i]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">e := ax[<span class="number">0</span>] + ax[<span class="number">1</span>]*lon</span><br><span class="line">i := lat / ax[<span class="number">9</span>]</span><br><span class="line">aw := ax[<span class="number">2</span>] + ax[<span class="number">3</span>]*i + ax[<span class="number">4</span>]*math.Pow(i, <span class="number">2</span>) + ax[<span class="number">5</span>]*math.Pow(i, <span class="number">3</span>) +</span><br><span class="line">ax[<span class="number">6</span>]*math.Pow(i, <span class="number">4</span>) + ax[<span class="number">7</span>]*math.Pow(i, <span class="number">5</span>) + ax[<span class="number">8</span>]*math.Pow(i, <span class="number">6</span>)</span><br><span class="line">fmt.Println(e, aw)</span><br><span class="line"><span class="keyword">return</span> e, aw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConvertBD09_2GCJ03 用于把BD09坐标转成GCJ03</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertBD09_2_GCJ03</span><span class="params">(lon, lat <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">x := lon - <span class="number">0.0065</span></span><br><span class="line">y := lat - <span class="number">0.006</span></span><br><span class="line">z := math.Sqrt(x*x+y*y) - <span class="number">0.00002</span>*math.Sin(y*pi)</span><br><span class="line">theta := math.Atan2(y, x) - <span class="number">0.000003</span>*math.Cos(x*pi)</span><br><span class="line">ggLon := z * math.Cos(theta)</span><br><span class="line">ggLat := z * math.Sin(theta)</span><br><span class="line"><span class="keyword">return</span> ggLon, ggLat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(ConvertBD09_2_GCJ03(ConvertMCT_2_BD09(<span class="number">12945050.96</span>, <span class="number">4826978.52</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">116.28610602331416 39.92229605145939</span><br><span class="line">116.27973999840552 39.915952179109595</span><br></pre></td></tr></table></figure><p></p><p>python2版本的在<a href="https://gist.github.com/JobsDong/8313339" target="_blank" rel="noopener">这里</a>，本文也是由这个方法改(chao)写(xi)的，python3使用时把<code>xrange</code>改成<code>range</code>即可。</p><p>最后记录一个百度查询地址接口<code>https://api.map.baidu.com/?qt=s&amp;c=340&amp;wd=地名&amp;rn=10&amp;ie=utf-8&amp;oue=1&amp;res=api</code>，其中参数<code>c</code>代表城市代码，如果不传递的话接口返回的是可能存在这个地名的城市，城市代码可以自行百度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天获取百度地图数据时候发现其坐标都是类似&lt;code&gt;12945050.96,4826978.52&lt;/code&gt;这种而非常见的经纬度，之前获取百度外面商家信息时就发现了这个问题但没深入研究，搜索后发现这种表示方法叫做&lt;code&gt;墨卡托坐标&lt;/code&gt;。不得不说，关于坐标的标准还真是挺多的，根据经纬度查询位置可以使用&lt;a href=&quot;http://www.gpsspg.com/maps.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个网站&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>200行GO代码实现区块链3</title>
    <link href="http://www.hi-roy.com/2018/06/22/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE3/"/>
    <id>http://www.hi-roy.com/2018/06/22/200行GO代码实现区块链3/</id>
    <published>2018-06-22T09:35:36.000Z</published>
    <updated>2019-09-16T08:11:51.451Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-mining-algorithm-in-go-82c6a71aba1f" target="_blank" rel="noopener">原文</a>，阅读之前请先看<a href="http://www.hi-roy.com/2018/05/18/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE1/">200行GO代码实现区块链1</a> 和 <a href="http://www.hi-roy.com/2018/05/21/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE2/">200行GO代码实现区块链2</a>。</p><p>如果看到这了相信你已经知道什么是加密算法等背景了，所以忽略关于这部分的翻译，直接从编码开始。这篇文章在前两篇的文章基础上添加了工作量证明(POW)挖矿算法。</p><a id="more"></a><p>首先创建<code>.env</code>文件来定义环境变量，里面只有一行<code>ADDR=8080</code>，然后创建<code>main.go</code>并引入相关依赖：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"crypto/sha256"</span></span><br><span class="line">        <span class="string">"encoding/hex"</span></span><br><span class="line">        <span class="string">"encoding/json"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"io"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"os"</span></span><br><span class="line">        <span class="string">"strconv"</span></span><br><span class="line">        <span class="string">"strings"</span></span><br><span class="line">        <span class="string">"sync"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">        <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">        <span class="string">"github.com/joho/godotenv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>如果你阅读过之前的文章，你应该知道区块链中的区块通过比较本区块记录的<code>PrevHash</code>和前一个区块的<code>Hash</code>来进行验证，这也是保证区块链完整性和坏人无法改变区块链历史的原因。</p><p><code>BMP</code>代表心跳速率，我们使用这个作为存储在区块中的数据，接下来定义数据模型和需要的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> difficulty = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">        Index      <span class="keyword">int</span></span><br><span class="line">        Timestamp  <span class="keyword">string</span></span><br><span class="line">        BPM        <span class="keyword">int</span></span><br><span class="line">        Hash       <span class="keyword">string</span></span><br><span class="line">        PrevHash   <span class="keyword">string</span></span><br><span class="line">        Difficulty <span class="keyword">int</span></span><br><span class="line">        Nonce      <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">        BPM <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>difficulty</code>定义了难度，即hash值开头0的数量。0数量越多，则难度越大，这里我们要求开头有1个0。</p><p><code>Block</code>是区块的数据结构，别忘了<code>Nonce</code>，我们晚一些解释这个。</p><p><code>Blockchain</code>是<code>Block</code>组成的列表(Roy注：准确的说是slice，不过翻译成切片有点拗口)，用来存储区块链。</p><p><code>Message</code>用来接收我们向REST API使用<code>POST</code>方式生成新区块的数据。</p><p>我们声明了<code>mutex</code>来数据冲突并且确保区块不会同一时刻生成多个。</p><p>接下来创建web服务，首先创建<code>run()</code>函数晚些将在<code>main</code>函数中调用，同时生成了<code>makeMuxRouter()</code>来管理路由。记住，我们使用<code>GET</code>来检索区块<code>POST</code>来添加新区块，由于区块链是不可变的所以我们不需要删除或编辑功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        mux := makeMuxRouter()</span><br><span class="line">        httpAddr := os.Getenv(<span class="string">"ADDR"</span>)</span><br><span class="line">        log.Println(<span class="string">"Listening on "</span>, os.Getenv(<span class="string">"ADDR"</span>))</span><br><span class="line">        s := &amp;http.Server&#123;</span><br><span class="line">                Addr:           <span class="string">":"</span> + httpAddr,</span><br><span class="line">                Handler:        mux,</span><br><span class="line">                ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">                WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">                MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := s.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMuxRouter</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">        muxRouter := mux.NewRouter()</span><br><span class="line">        muxRouter.HandleFunc(<span class="string">"/"</span>, handleGetBlockchain).Methods(<span class="string">"GET"</span>)</span><br><span class="line">        muxRouter.HandleFunc(<span class="string">"/"</span>, handleWriteBlock).Methods(<span class="string">"POST"</span>)</span><br><span class="line">        <span class="keyword">return</span> muxRouter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>httpAddr := os.Getenv(&quot;ADDR&quot;)</code>这行代码从<code>.env</code>文件中读取我们定义的<code>:8080</code>，这样就可以通过浏览器访问<code>http://localhost:8080</code>来查看应用了。(Roy注:注意这里的<code>1 &lt;&lt; 20</code>这个位移操作，正好是1KB。)</p><p>现在编写处理<code>GET</code>请求的函数来在浏览器展示我们的区块链，同时添加<code>respondwithJSON</code>函数来打印错误信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGetBlockchain</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        bytes, err := json.MarshalIndent(Blockchain, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        io.WriteString(w, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">respondWithJSON</span><span class="params">(w http.ResponseWriter, r *http.Request, code <span class="keyword">int</span>, payload <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        response, err := json.MarshalIndent(payload, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">                w.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP 500: Internal Server Error"</span>))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(code)</span><br><span class="line">        w.Write(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果你觉得一头雾水，请先看之前的文章。</em></p><p>接下来编写处理生成区块的<code>POST</code>请求函数，我们通过发送JSON类型的数据比如<code>{&quot;BMP&quot;:60}</code>到<code>http://localhost:8080</code>来生成新区块：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWriteBlock</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        <span class="keyword">var</span> m Message</span><br><span class="line"></span><br><span class="line">        decoder := json.NewDecoder(r.Body)</span><br><span class="line">        <span class="keyword">if</span> err := decoder.Decode(&amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                respondWithJSON(w, r, http.StatusBadRequest, r.Body)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ensure atomicity when creating new block</span></span><br><span class="line">        mutex.Lock()</span><br><span class="line">        newBlock := generateBlock(Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>], m.BPM)</span><br><span class="line">        mutex.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isBlockValid(newBlock, Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]) &#123;</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, newBlock)</span><br><span class="line">                spew.Dump(Blockchain)</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        respondWithJSON(w, r, http.StatusCreated, newBlock)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意<code>mutex</code>加锁和解锁的地方，我们在写新区块之前加锁，否则将可能造成数据冲突。有些读者可能注意到了<code>generateBlock</code>函数，这是实现工作量证明的关键函数，我们一会再说。</p><p>首先添加<code>isBlockValid</code>函数来确保区块链的索引递增并且每个区块的<code>PrevHash</code>和前一个区块的<code>Hash</code>相匹配。</p><p>然后添加<code>calculateHash</code>函数来计算创建Hash值，这里我们使用SHA256来链接Index、Timestamp，BMP，PrevHash和Nonce（我们晚一点解释这个）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> calculateHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        record := strconv.Itoa(block.Index) + block.Timestamp + strconv.Itoa(block.BPM) + block.PrevHash + block.Nonce</span><br><span class="line">        h := sha256.New()</span><br><span class="line">        h.Write([]<span class="keyword">byte</span>(record))</span><br><span class="line">        hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写挖矿算法——工作量证明(POW)，我们要确保在新区块添加到区块链之前工作量证明已经完成，让我们先写一个简单的函数来检查生成的散列是否满足条件：</p><ul><li>生成的散列是否以0开头</li><li>开头0的数量是否和我们常量<code>difficulty</code>中定义的一致(本例中为1)</li><li>我们可以通过增大难度来使挖矿变难</li></ul><p>函数<code>isHashValid</code>如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHashValid</span><span class="params">(hash <span class="keyword">string</span>, difficulty <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        prefix := strings.Repeat(<span class="string">"0"</span>, difficulty)</span><br><span class="line">        <span class="keyword">return</span> strings.HasPrefix(hash, prefix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>GO在<code>strings</code>包中提供了<code>Repeat</code>和<code>HasPrefix</code>函数，变量<code>prefix</code>是重复了<code>difficulty</code>次的0组成的字符串，接下来我们判断散列是否以这个字符串开头，如果是返回<code>True</code>否则返回<code>False</code>。</p><p>接下来构建<code>generateBlock</code>函数：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>)</span> <span class="title">Block</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">        t := time.Now()</span><br><span class="line"></span><br><span class="line">        newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">        newBlock.Timestamp = t.String()</span><br><span class="line">        newBlock.BPM = BPM</span><br><span class="line">        newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">        newBlock.Difficulty = difficulty</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">                hex := fmt.Sprintf(<span class="string">"%x"</span>, i)</span><br><span class="line">                newBlock.Nonce = hex</span><br><span class="line">                <span class="keyword">if</span> !isHashValid(calculateHash(newBlock), newBlock.Difficulty) &#123;</span><br><span class="line">                        fmt.Println(calculateHash(newBlock), <span class="string">" do more work!"</span>)</span><br><span class="line">                        time.Sleep(time.Second)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fmt.Println(calculateHash(newBlock), <span class="string">" work done!"</span>)</span><br><span class="line">                        newBlock.Hash = calculateHash(newBlock)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里创建新区块并将前一个区块的Hash存储到本区块的PrevHash中来确保连续性，其他字段也很明显：</p><ul><li><code>Index</code>自增</li><li><code>Timestamp</code>记录当前时间</li><li><code>BMP</code>记录心跳数据</li><li><code>Difficulty</code>简单的记录了程序最上面定义的常量。本文中不会使用，但未来如果我们需要确保难度和当前散列结果一致（比如散列前面有Ｎ位0，这个值应该和Difficulty相等）时将要用到。</li></ul><p><code>for</code>循环在这里是很关键的一步，我们来看看这里都做了些什么：</p><ul><li>首先我们将16进制的<code>i</code>值赋值给了<code>Nonce</code>，我们的<code>calculateHash</code>函数需要这个变量来进行Hash计算，如果计算结果0的个数不满足要求，我们则尝试一个新值。</li><li>我们从0开始循环，并判断其结果0开头的个数是否和<code>difficulty</code>规定的一样，如果不同则进行下一次循环。</li><li>我们添加了<code>sleep</code>1秒钟来模拟工作量证明算法中某些耗时操作。</li><li>进行循环直到获得一个开头0的个数满足我们需求的数值，也就意味着工作量证明算法成功执行。此时才准许新区块通过<code>handleWriteBlock</code>添加到区块链中。</li></ul><p>所有需要的函数都完成了，现在编写<code>main</code>函数：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := godotenv.Load()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                t := time.Now()</span><br><span class="line">                genesisBlock := Block&#123;&#125;</span><br><span class="line">                genesisBlock = Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, calculateHash(genesisBlock), <span class="string">""</span>, difficulty, <span class="string">""</span>&#125;</span><br><span class="line">                spew.Dump(genesisBlock)</span><br><span class="line"></span><br><span class="line">                mutex.Lock()</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">        log.Fatal(run())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过调用<code>godotenv.Load()</code>来载入环境变量，这里是<code>:8080</code>端口。然后创建一个go routine 创建了创世块作为整个区块链的起始，最后调用<code>run()</code>函数来运行web服务。</p><p>完整代码在<a href="https://github.com/mycoralhealth/blockchain-tutorial/blob/master/proof-work/main.go" target="_blank" rel="noopener">这里</a>。</p><hr><p>核心部分就翻译到这，原文还有一些如何使用<code>postman</code>进行测试以及测试输出的部分就不翻译了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://medium.com/@mycoralhealth/code-your-own-blockchain-mining-algorithm-in-go-82c6a71aba1f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，阅读之前请先看&lt;a href=&quot;http://www.hi-roy.com/2018/05/18/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE1/&quot;&gt;200行GO代码实现区块链1&lt;/a&gt; 和 &lt;a href=&quot;http://www.hi-roy.com/2018/05/21/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE2/&quot;&gt;200行GO代码实现区块链2&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果看到这了相信你已经知道什么是加密算法等背景了，所以忽略关于这部分的翻译，直接从编码开始。这篇文章在前两篇的文章基础上添加了工作量证明(POW)挖矿算法。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger-Fabric环境搭建笔记</title>
    <link href="http://www.hi-roy.com/2018/06/15/Hyperledger-Fabric%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.hi-roy.com/2018/06/15/Hyperledger-Fabric环境搭建笔记/</id>
    <published>2018-06-15T02:43:49.000Z</published>
    <updated>2019-09-16T08:11:51.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>前提需要电脑中存在<code>git</code>、<code>docker</code>、<code>docker-compose</code>命令以及有<code>golang</code>开发环境。</p><p>首先创建目录存放Fabric代码，<strong>注意路径和权限</strong>，在启动服务时候会向其中写一些文件，最开始我就是没注意到这点报错了。<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /opt/gopath/src/github.com/hyperledger/</span><br></pre></td></tr></table></figure><p></p><p>进入刚才创建的目录后拉取代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/gopath/src/github.com/hyperledger</span><br><span class="line">git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure><p></p><p>当前版本是1.1。</p><a id="more"></a><p>然后拉取所需镜像，这步速度慢需要耐心等待。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /opt/gopath/src/github.com/hyperledger/fabric/scripts/bootstrap.sh</span><br></pre></td></tr></table></figure><p></p><p>完成后进入<code>/opt/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli</code>目录，执行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash network_setup.sh up</span><br></pre></td></tr></table></figure><p></p><p>这个文件干了几件事：</p><ol><li>编译生成Fabric公私钥、证书的程序，程序在目录：/opt/gopath/src/github.com/hyperledger/fabric/release/linux-amd64/bin</li><li>基于configtx.yaml生成创世区块和通道相关信息，并保存在channel-artifacts文件夹。</li><li>基于crypto-config.yaml生成公私钥和证书信息，并保存在crypto-config文件夹中。</li><li>基于docker-compose-cli.yaml启动1Orderer+2org*2Peer+1CLI的Fabric容器。</li><li>在CLI启动的时候，会运行scripts/script.sh文件，这个脚本文件包含了创建Channel，加入Channel，安装Example02，运行Example02等功能。</li></ol><p>成功后会看到提示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">===================== All GOOD, End-2-End execution completed =====================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> _____   _   _   ____            _____   ____    _____</span><br><span class="line">| ____| | \ | | |  _ \          | ____| |___ \  | ____|</span><br><span class="line">|  _|   |  \| | | | | |  _____  |  _|     __) | |  _|  </span><br><span class="line">| |___  | |\  | | |_| | |_____| | |___   / __/  | |___</span><br><span class="line">|_____| |_| \_| |____/          |_____| |_____| |_____|</span><br></pre></td></tr></table></figure><p></p><p>查看创建的容器：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker ps --format <span class="string">"&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Names&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line">a2adbbe090ce:dev-peer1.org2.example.com-mycc-1.0</span><br><span class="line">434f146382d3:dev-peer0.org1.example.com-mycc-1.0</span><br><span class="line">f07e03296c11:dev-peer0.org2.example.com-mycc-1.0</span><br><span class="line">6eee69b127ff:cli</span><br><span class="line">f323f3bf5b0e:orderer.example.com</span><br><span class="line">f8eae1488dce:kafka3</span><br><span class="line">3b79d89b3928:kafka0</span><br><span class="line">dd5cd1d8c35a:kafka2</span><br><span class="line">c7953a8951f1:kafka1</span><br><span class="line">7d28f6dc8c3b:peer0.org1.example.com</span><br><span class="line">aeb4ce4d57c3:zookeeper2</span><br><span class="line">734e25a4430e:zookeeper0</span><br><span class="line">6b051d7edb2e:peer1.org2.example.com</span><br><span class="line">f19e5663a764:zookeeper1</span><br><span class="line">9494e1f87c56:peer1.org1.example.com</span><br><span class="line">7bada708f807:peer0.org2.example.com</span><br></pre></td></tr></table></figure><p></p><blockquote><p>默认安装了：4个peer（2个是org1的，2个是org2的）节点、4节点构成的kafka集群、3节点构成的zookeeper集群、1个orderer节点。这是因为：fabric提供的共识机制，PBFT目前还未达到生产级别的应用，只能靠kafka+zookeeper实现PAXOS算法下的共识机制（不能有作恶结点）</p></blockquote><h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><p>先进入容器中<code>docker exec -it cli sh</code>，然后看看<code>peer</code>命令都支持什么操作：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli sh</span><br><span class="line"></span><br><span class="line"># pwd</span><br><span class="line">/opt/gopath/src/github.com/hyperledger/fabric/peer</span><br><span class="line"># peer -h</span><br><span class="line">Usage:</span><br><span class="line">  peer [flags]</span><br><span class="line">  peer [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  chaincode   Operate a chaincode: install|instantiate|invoke|package|query|signpackage|upgrade|list.</span><br><span class="line">  channel     Operate a channel: create|fetch|join|list|update|signconfigtx|getinfo.</span><br><span class="line">  logging     Log levels: getlevel|setlevel|revertlevels.</span><br><span class="line">  node        Operate a peer node: start|status.</span><br><span class="line">  version     Print fabric peer version.</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --logging-level string   Default logging level and overrides, see core.yaml for full syntax</span><br><span class="line">  -v, --version                Display current version of fabric peer server</span><br><span class="line"></span><br><span class="line">Use &quot;peer [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p></p><p>和以太坊类似，fabric中交易也要通过chaincode操作。chancode支持的命令如下：</p><ul><li>package 智能合约需要打包后才能使用</li><li>install 智能合约必须安装后才能使用</li><li>instantiate 置初始状态。比如设系统一开始用户a有100元，用户b有200元</li><li>invoke 调用智能合约</li><li>query 查询状态</li><li>signpackage 包签名</li><li>upgrade 智能合约升级</li><li>list 显示智能合约</li></ul><p>首先执行命令查询余额：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br><span class="line">2018-06-15 03:16:39.226 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-06-15 03:16:39.226 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-06-15 03:16:39.226 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-06-15 03:16:39.227 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-06-15 03:16:39.227 UTC [chaincodeCmd] getChaincodeSpec -&gt; DEBU 005 java chaincode disabled</span><br><span class="line">2018-06-15 03:16:39.227 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: plaintext: 0ABE070A6608031A0B0897DF8CD90510...6D7963631A0A0A0571756572790A0161</span><br><span class="line">2018-06-15 03:16:39.227 UTC [msp/identity] Sign -&gt; DEBU 007 Sign: digest: 916F0EE6336EADD59FEBF6538B30645BED4C60C64AD65255ABFCADD189655300</span><br><span class="line">Query Result: 90</span><br></pre></td></tr></table></figure><p></p><p>等等，为什么我们什么安装操作都没做就能执行查询命令而且还有结果呢？原因在启动服务的过程中有这么一段：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Installing chaincode on org1/peer0...</span><br><span class="line">....</span><br><span class="line">2018-06-15 02:35:10.647 UTC [container] WriteFileToPackage -&gt; DEBU 00c Writing file to tarball: src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02/chaincode_example02.go</span><br><span class="line">2018-06-15 02:35:10.648 UTC [container] WriteFileToPackage -&gt; DEBU 00d Writing file to tarball: src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02/chaincode_example02_test.go</span><br><span class="line">2018-06-15 02:35:10.648 UTC [msp/identity] Sign -&gt; DEBU 00e Sign: plaintext: 0AB4070A5C08031A0C08DECB8CD90510...83C77F030000FFFF1E416A37002E0000</span><br><span class="line">2018-06-15 02:35:10.648 UTC [msp/identity] Sign -&gt; DEBU 00f Sign: digest: 45EC14B3196DC03ACB6A413DED651FBBAF8BEF4B109DA6F0D8E821F150DA7ED1</span><br><span class="line">2018-06-15 02:35:10.650 UTC [chaincodeCmd] install -&gt; DEBU 010 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">2018-06-15 02:35:10.650 UTC [main] main -&gt; INFO 011 Exiting.....</span><br><span class="line">===================== Chaincode is installed on remote peer PEER0 =====================</span><br></pre></td></tr></table></figure><p></p><p>启动脚本中已经帮我们安装好<code>src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02/chaincode_example02.go</code>这个Chaincode并且初始化了。<br>如果后续需要创建或修改代码，则需要重新安装：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure><p></p><p>其中<code>-n</code>表示合约名字，<code>-p</code>指向合约文件目录路径，<code>-v</code>是版本号。</p><p>而初始化则需要注意，是否开启了<code>tls</code>方法不同，见<code>/opt/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli/scripts/script.sh</code>中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">instantiateChaincode</span></span> () &#123;</span><br><span class="line">    PEER=<span class="variable">$1</span></span><br><span class="line">    setGlobals <span class="variable">$PEER</span></span><br><span class="line">    <span class="comment"># while 'peer chaincode' command can get the orderer endpoint from the peer (if join was successful),</span></span><br><span class="line">    <span class="comment"># lets supply it directly as we know it using the "-o" option</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$CORE_PEER_TLS_ENABLED</span>"</span> -o <span class="string">"<span class="variable">$CORE_PEER_TLS_ENABLED</span>"</span> = <span class="string">"false"</span> ]; <span class="keyword">then</span></span><br><span class="line">        peer chaincode instantiate -o orderer.example.com:7050 -C <span class="variable">$CHANNEL_NAME</span> -n mycc -v 1.0 -c <span class="string">'&#123;"Args":["init","a","100","b","200"]&#125;'</span> -P <span class="string">"OR    ('Org1MSP.member','Org2MSP.member')"</span> &gt;&amp;log.txt</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        peer chaincode instantiate -o orderer.example.com:7050 --tls <span class="variable">$CORE_PEER_TLS_ENABLED</span> --cafile <span class="variable">$ORDERER_CA</span> -C <span class="variable">$CHANNEL_NAME</span> -n mycc -v 1.0 -c <span class="string">'&#123;"Args":["init","a","100","b","200"]&#125;'</span> -P <span class="string">"OR  ('Org1MSP.member','Org2MSP.member')"</span> &gt;&amp;log.txt</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    res=$?</span><br><span class="line">    cat log.txt</span><br><span class="line">    verifyResult <span class="variable">$res</span> <span class="string">"Chaincode instantiation on PEER<span class="variable">$PEER</span> on channel '<span class="variable">$CHANNEL_NAME</span>' failed"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"===================== Chaincode Instantiation on PEER<span class="variable">$PEER</span> on channel '<span class="variable">$CHANNEL_NAME</span>' is successful ===================== "</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如没开启<code>tls</code>初始化代码就是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n mycc -v 1.0 -c &apos;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]&#125;&apos; -P &quot;OR    (&apos;Org1MSP.peer&apos;,&apos;Org2MSP.peer&apos;)&quot;</span><br></pre></td></tr></table></figure><p></p><p>其中，-C指向channel名字，-c则是初始构造json格式的消息，-P是背书策略，-o指定共识节点。这里置帐户a初始余额为100，帐户b初始余额为200。</p><p>每个chaincode都要实现Init和Invoke两个方法，其中前者用于初始化，后者是日常调用。 以我们调用的<code>Example02.go</code>代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ex02 Init"</span>)</span><br><span class="line">_, args := stub.GetFunctionAndParameters() <span class="comment">//获取传入的参数并解析</span></span><br><span class="line"><span class="keyword">var</span> A, B <span class="keyword">string</span>    <span class="comment">// Entities</span></span><br><span class="line"><span class="keyword">var</span> Aval, Bval <span class="keyword">int</span> <span class="comment">// Asset holdings</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">4</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Incorrect number of arguments. Expecting 4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the chaincode</span></span><br><span class="line">A = args[<span class="number">0</span>]</span><br><span class="line">Aval, err = strconv.Atoi(args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Expecting integer value for asset holding"</span>)</span><br><span class="line">&#125;</span><br><span class="line">B = args[<span class="number">2</span>]</span><br><span class="line">Bval, err = strconv.Atoi(args[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Expecting integer value for asset holding"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Aval = %d, Bval = %d\n"</span>, Aval, Bval)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the state to the ledger</span></span><br><span class="line">err = stub.PutState(A, []<span class="keyword">byte</span>(strconv.Itoa(Aval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = stub.PutState(B, []<span class="keyword">byte</span>(strconv.Itoa(Bval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke</code>函数如下，可以理解为所有日常操作的入口：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ex02 Invoke"</span>)</span><br><span class="line">function, args := stub.GetFunctionAndParameters()</span><br><span class="line"><span class="keyword">if</span> function == <span class="string">"invoke"</span> &#123;</span><br><span class="line"><span class="comment">// Make payment of X units from A to B</span></span><br><span class="line"><span class="keyword">return</span> t.invoke(stub, args)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> function == <span class="string">"delete"</span> &#123;</span><br><span class="line"><span class="comment">// Deletes an entity from its state</span></span><br><span class="line"><span class="keyword">return</span> t.<span class="built_in">delete</span>(stub, args)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> function == <span class="string">"query"</span> &#123;</span><br><span class="line"><span class="comment">// the old "Query" is now implemtned in invoke</span></span><br><span class="line"><span class="keyword">return</span> t.query(stub, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Invalid invoke function name. Expecting \"invoke\" \"delete\" \"query\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到实现了3种操作，转帐、删除用户、查询余额。</p><p>先看查询余额，函数定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query callback representing the query of a chaincode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">query</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> A <span class="keyword">string</span> <span class="comment">// Entities</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Incorrect number of arguments. Expecting name of the person to query"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = args[<span class="number">0</span>] <span class="comment">//帐户名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the state from the ledger</span></span><br><span class="line">Avalbytes, err := stub.GetState(A)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">jsonResp := <span class="string">"&#123;\"Error\":\"Failed to get state for "</span> + A + <span class="string">"\"&#125;"</span></span><br><span class="line"><span class="keyword">return</span> shim.Error(jsonResp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Avalbytes == <span class="literal">nil</span> &#123;</span><br><span class="line">jsonResp := <span class="string">"&#123;\"Error\":\"Nil amount for "</span> + A + <span class="string">"\"&#125;"</span></span><br><span class="line"><span class="keyword">return</span> shim.Error(jsonResp)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 返回json格式结果</span></span><br><span class="line">jsonResp := <span class="string">"&#123;\"Name\":\""</span> + A + <span class="string">"\",\"Amount\":\""</span> + <span class="keyword">string</span>(Avalbytes) + <span class="string">"\"&#125;"</span></span><br><span class="line">fmt.Printf(<span class="string">"Query Response:%s\n"</span>, jsonResp)</span><br><span class="line"><span class="keyword">return</span> shim.Success(Avalbytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>先正常从b给a支付50，这里注意我们开启了tls（<em>疑问：查询时候为啥不用指定tls而转帐不指定则会报错？</em>）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o orderer.example.com:7050  --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;b&quot;,&quot;a&quot;,&quot;50&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><p></p><p>查看a的余额：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-06-15 03:31:01.268 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-06-15 03:31:01.268 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-06-15 03:31:01.268 UTC [chaincodeCmd] getChaincodeSpec -&gt; DEBU 005 java chaincode disabled</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: plaintext: 0ABF070A6708031A0C08F5E58CD90510...6D7963631A0A0A0571756572790A0161</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp/identity] Sign -&gt; DEBU 007 Sign: digest: 6BAE5E272C5A3FD13D3921B98F0C4C35D6BBD6433DD66CFFF42B04561CDBE688</span><br><span class="line">Query Result: 140</span><br></pre></td></tr></table></figure><p></p><p>再看b的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;b&quot;]&#125;&apos;</span><br><span class="line">2018-06-15 03:48:24.458 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-06-15 03:48:24.458 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-06-15 03:48:24.458 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-06-15 03:48:24.458 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-06-15 03:48:24.458 UTC [chaincodeCmd] getChaincodeSpec -&gt; DEBU 005 java chaincode disabled</span><br><span class="line">2018-06-15 03:48:24.459 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: plaintext: 0ABF070A6708031A0C0888EE8CD90510...6D7963631A0A0A0571756572790A0162</span><br><span class="line">2018-06-15 03:48:24.459 UTC [msp/identity] Sign -&gt; DEBU 007 Sign: digest: B422147DF2CBDF964CAFA860B2FEF3E0928F1B317F599188284860D5EA5902A2</span><br><span class="line">Query Result: 160</span><br></pre></td></tr></table></figure><p></p><p>a有140，b有160。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o orderer.example.com:7050  --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;150&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><p></p><p>这里我们从a向b转150，结果也成功执行了，a余额变成-10，因为<code>invoke</code>代码中并没有对余额和转帐金额的大小进行判断。</p><p>转帐函数<code>invoke</code>定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction makes payment of X units from A to B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">invoke</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> A, B <span class="keyword">string</span>    <span class="comment">// Entities</span></span><br><span class="line"><span class="keyword">var</span> Aval, Bval <span class="keyword">int</span> <span class="comment">// Asset holdings</span></span><br><span class="line"><span class="keyword">var</span> X <span class="keyword">int</span>          <span class="comment">// Transaction value</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Incorrect number of arguments. Expecting 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = args[<span class="number">0</span>] <span class="comment">//转出帐户</span></span><br><span class="line">B = args[<span class="number">1</span>] <span class="comment">//转入帐户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the state from the ledger</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> will be nice to have a GetAllState call to ledger</span></span><br><span class="line">Avalbytes, err := stub.GetState(A)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Failed to get state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> Avalbytes == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Entity not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Aval, _ = strconv.Atoi(<span class="keyword">string</span>(Avalbytes))</span><br><span class="line"></span><br><span class="line">Bvalbytes, err := stub.GetState(B)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Failed to get state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> Bvalbytes == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Entity not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Bval, _ = strconv.Atoi(<span class="keyword">string</span>(Bvalbytes))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform the execution</span></span><br><span class="line">X, err = strconv.Atoi(args[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Invalid transaction amount, expecting a integer value"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//关键在于这里缺少判断</span></span><br><span class="line">Aval = Aval - X</span><br><span class="line">Bval = Bval + X</span><br><span class="line">fmt.Printf(<span class="string">"Aval = %d, Bval = %d\n"</span>, Aval, Bval)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the state back to the ledger</span></span><br><span class="line">err = stub.PutState(A, []<span class="keyword">byte</span>(strconv.Itoa(Aval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = stub.PutState(B, []<span class="keyword">byte</span>(strconv.Itoa(Bval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样，我们就可以尝试修改这个chaincode并重新安装部署初始化了，具体操作下次记录。</p><hr><p>参考链接：</p><ol><li><a href="http://www.taohui.pub/530.html" target="_blank" rel="noopener">http://www.taohui.pub/530.html</a></li><li><a href="http://nm1024.com/?p=10" target="_blank" rel="noopener">http://nm1024.com/?p=10</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;p&gt;前提需要电脑中存在&lt;code&gt;git&lt;/code&gt;、&lt;code&gt;docker&lt;/code&gt;、&lt;code&gt;docker-compose&lt;/code&gt;命令以及有&lt;code&gt;golang&lt;/code&gt;开发环境。&lt;/p&gt;&lt;p&gt;首先创建目录存放Fabric代码，&lt;strong&gt;注意路径和权限&lt;/strong&gt;，在启动服务时候会向其中写一些文件，最开始我就是没注意到这点报错了。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mkdir /opt/gopath/src/github.com/hyperledger/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入刚才创建的目录后拉取代码：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /opt/gopath/src/github.com/hyperledger&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/hyperledger/fabric.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当前版本是1.1。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Raft算法</title>
    <link href="http://www.hi-roy.com/2018/06/07/Raft%E7%AE%97%E6%B3%95/"/>
    <id>http://www.hi-roy.com/2018/06/07/Raft算法/</id>
    <published>2018-06-07T14:26:33.000Z</published>
    <updated>2019-09-16T08:11:51.469Z</updated>
    
    <content type="html"><![CDATA[<p>相比与Paxos算法，Raft更容易理解。首先推荐个<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">动画视频</a> (注意这个动画真的基于raft算法，所以每次选举出的节点都是不同的，我观看某些章节时候甚至出现过3次选举过程)，然后是<a href="http://www.infoq.com/cn/articles/raft-paper" target="_blank" rel="noopener">raft论文中文版</a>和<a href="https://raft.github.io/" target="_blank" rel="noopener">raft主页</a>，基本结合这3个网站就能理解raft了。</p><p>在Raft算法中，有3种角色：</p><ul><li>Leader</li><li>Follower</li><li>Candidate</li></ul><p>大体分为2个过程：</p><ol><li>选举(Leader Election)</li><li>日志同步(Log Replication)<a id="more"></a></li></ol><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>选举和现实社会中的民主选举制度很像，当Follower超过选举超时时间(election timeout)没收到来自Leader的心跳报文，则成为Candidate，增加任期(Term)并向其他节点发起新的选举请求。接收到请求的节点如果还没投票则投票给该节点，并重置自己的超时时间。如果获取到了超过一半的赞同票，则成为新的Leader。每隔一定时间向Follower发送心跳报文来维持自己的”统治”地位。</p><p>那么，万一有多个节点获得了同样的投票怎么办呢？</p><p>此时则等待各自的超时时间后，增加Term后再次发起投票。解决这个问题的关键在于 <strong>每个节点的election timeout</strong> 是不同的。</p><h2 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h2><p>当选举完成后，客户端进行的操作都要通过Leader来进行。首先Leader接受到客户端发来的操作请求后记录到日志中，此时为uncommitted状态。然后在下一个心跳报文中通知所有Follower，当大多数Follower响应后，Leader响应客户端，进入committed阶段，并向Follower发送通知应用(apply)操作。</p><h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p>如果由于网络分区(network partition)造成同时有多个Leader，这种情况下某些Leader由于获取不到大多数的投票，所以数据永远不会提交成功。当网络故障恢复后，旧的Leader发现有Term更新的Leader存在，则自动降级为Follower并从最新的Leader同步数据达成集群一致。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果在日志同步阶段，Leader响应客户端后进入committed阶段，但没来得及向Follower发送通知就挂掉了，重新选举后这次修改会不会丢失？</p><p>答案是不会丢失。具体解释可以参考<a href="https://stackoverflow.com/questions/34672331/what-will-happen-to-replicated-but-uncommited-logs-in-raft-protocol" target="_blank" rel="noopener">这里</a>。</p><hr><p>最后再推荐一个<a href="https://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">文章</a>，里面关于什么时候Leader挂掉的图解很清晰。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比与Paxos算法，Raft更容易理解。首先推荐个&lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动画视频&lt;/a&gt; (注意这个动画真的基于raft算法，所以每次选举出的节点都是不同的，我观看某些章节时候甚至出现过3次选举过程)，然后是&lt;a href=&quot;http://www.infoq.com/cn/articles/raft-paper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raft论文中文版&lt;/a&gt;和&lt;a href=&quot;https://raft.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raft主页&lt;/a&gt;，基本结合这3个网站就能理解raft了。&lt;/p&gt;&lt;p&gt;在Raft算法中，有3种角色：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Leader&lt;/li&gt;&lt;li&gt;Follower&lt;/li&gt;&lt;li&gt;Candidate&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大体分为2个过程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;选举(Leader Election)&lt;/li&gt;&lt;li&gt;日志同步(Log Replication)
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-互斥锁</title>
    <link href="http://www.hi-roy.com/2018/06/07/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <id>http://www.hi-roy.com/2018/06/07/GO语言学习笔记-互斥锁/</id>
    <published>2018-06-07T09:42:11.000Z</published>
    <updated>2019-09-16T08:11:51.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/mutex/" target="_blank" rel="noopener">原文</a>，互斥锁(Mutex)也是go并发系列最后一篇文章。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>在说互斥锁前，理解并发编程中的临界区(Critical section)是十分重要的。当一个程序并发执行时，共享资源不应该在同一时刻被多个goroutine修改。这段修改共享资源的代码就叫做临界区。举个例子，我们有一个代码片段用于修改变量x自增１。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x+1</span><br></pre></td></tr></table></figure><p></p><p>如果上面的代码在唯一的goroutine中执行，不会有任何问题。</p><a id="more"></a><p>让我们看看这段代码当多个goroutine并发执行时会有什么问题，为了简单我们假设有2个goroutine。操作系统执行上面代码时候有3步(其实更复杂，比如寄存器、加法如何进行，但这里我们简化成3步)：</p><ol><li>获取当前的x值</li><li>计算x+1</li><li>把上一步的结果赋值给x</li></ol><p>只有一个goroutine时，一切正常。但有2个goroutine并发执行时，下图展示了可能出现的一种情形：</p><p><img src="https://golangbot.com/content/images/2017/08/cs5.png" alt="img1"></p><p>我们假设初始值为0，goroutine1取得了这个值并计算x+1，但当把结果赋值给x前系统切换到了goroutine2，goroutine2也取得初始值0并计算x+1，然后系统切换到goroutine1，将计算的结果1赋值给x。接下来goroutine2继续执行，把其计算结果1赋值给x。因此，所有goroutine执行完成后x值为1。</p><p>下面让我们来看另一种情况：</p><p><img src="https://golangbot.com/content/images/2017/08/cs-6.png" alt="img2"></p><p>上述情况，goroutine1执行所有步骤后将x值变为1，然后goroutine2继续执行，最终x值为2。</p><p>所以最终x值为１还是２取决于context是如何切换的。这种结果取决于执行顺序的情况叫做竞争条件(Race Condition)。</p><p>上述场景中，如果同时刻只准许一个goroutine进入临界区，则竞争条件可以避免。可以使用互斥锁来达到这个目的。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁提供了一种锁机制来保证同一时刻只有一个goroutine访问临界区，这样就可以避免竞争条件了。</p><p>互斥锁位于<code>sync</code>包，提供了<code>Lock</code>和<code>Unlock</code>2个方法，任何被这２个方法包围在其中的代码同一时刻只能被一个goroutine执行，因此可以避免竞争条件了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex.Lock()  </span><br><span class="line">x = x + <span class="number">1</span>  </span><br><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure><p><strong>如果某个goroutine已经获得了锁，其他的goroutine尝试获取锁时将被阻塞，直到锁被释放。</strong></p><h2 id="一段有竞争条件的代码"><a href="#一段有竞争条件的代码" class="headerlink" title="一段有竞争条件的代码"></a>一段有竞争条件的代码</h2><p>我们先写一个有竞争条件的代码，然后解决它：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> x  = <span class="number">0</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)        </span><br><span class="line">        <span class="keyword">go</span> increment(&amp;w)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"final value of x"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>increment</code>函数将x自增1然后调用<code>wg.Done()</code>来通知<code>WaitGroup</code>完成，然后通过循环生成1000个goroutine，每个goroutine都是并发执行并且并发获取x的值。多次运行程序，你会发现结果每次都不同，比如<code>value of x 941</code>，<code>final value of x 928</code>，<code>final value of x 922</code>等。</p><h2 id="使用互斥锁解决问题"><a href="#使用互斥锁解决问题" class="headerlink" title="使用互斥锁解决问题"></a>使用互斥锁解决问题</h2><p>上面的代码我们生成1000个goroutine，如果每个自增1，结果应该是1000。这里我们使用互斥锁来解决问题。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> x  = <span class="number">0</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;  </span><br><span class="line">    m.Lock()</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    m.Unlock()</span><br><span class="line">    wg.Done()   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)        </span><br><span class="line">        <span class="keyword">go</span> increment(&amp;w, &amp;m)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"final value of x"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>互斥锁是一种<code>struct</code>类型，我们创建了一个默认值互斥锁<code>m</code>，并把其地址传递给了<code>increment</code>，同时把<code>x=x+1</code>这句代码放在<code>m.Lock()</code>和<code>m.Unlock()</code>之间。这样就只有一个goroutine能在同一时刻执行这句代码了。程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final value of x 1000</span><br></pre></td></tr></table></figure><h2 id="使用channel解决问题"><a href="#使用channel解决问题" class="headerlink" title="使用channel解决问题"></a>使用channel解决问题</h2><p>我们也可以使用channel，代码如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> x  = <span class="number">0</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup, ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="literal">true</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    &lt;- ch</span><br><span class="line">    wg.Done()   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)        </span><br><span class="line">        <span class="keyword">go</span> increment(&amp;w, ch)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"final value of x"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码中，我们创建了一个容量为1的带缓冲区的channel并且传递给函数<code>increment</code>，这个缓冲区channel用来确保同时刻只有一个goroutine能进入临界区操作x。先向channel中写入值，由于容量为1，所以其他goroutine将被阻塞。自增操作完成后在从channel中去读数据解除阻塞。这也是控制多个goroutine访问临界区的有效办法。</p><p>程序输出和上面一样。</p><h2 id="互斥锁-vs-Channel"><a href="#互斥锁-vs-Channel" class="headerlink" title="互斥锁 vs Channel"></a>互斥锁 vs Channel</h2><p>(roy注:这段我就选重点翻译了)</p><p>互斥锁和Channel都能解决上述问题，那么什么时候用哪个呢？</p><p><strong>如果各个goroutine之间需要通信，选择channel。否则，选择互斥锁。</strong></p><hr><p>另外下面有评论说goroutine数量多的时候互斥锁更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/mutex/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，互斥锁(Mutex)也是go并发系列最后一篇文章。&lt;/p&gt;&lt;h2 id=&quot;临界区&quot;&gt;&lt;a href=&quot;#临界区&quot; class=&quot;headerlink&quot; title=&quot;临界区&quot;&gt;&lt;/a&gt;临界区&lt;/h2&gt;&lt;p&gt;在说互斥锁前，理解并发编程中的临界区(Critical section)是十分重要的。当一个程序并发执行时，共享资源不应该在同一时刻被多个goroutine修改。这段修改共享资源的代码就叫做临界区。举个例子，我们有一个代码片段用于修改变量x自增１。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x = x+1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果上面的代码在唯一的goroutine中执行，不会有任何问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-Select</title>
    <link href="http://www.hi-roy.com/2018/06/07/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Select/"/>
    <id>http://www.hi-roy.com/2018/06/07/GO语言学习笔记-Select/</id>
    <published>2018-06-07T08:54:28.000Z</published>
    <updated>2019-09-16T08:11:51.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/select/" target="_blank" rel="noopener">原文</a></p><h2 id="什么是Select"><a href="#什么是Select" class="headerlink" title="什么是Select"></a>什么是Select</h2><p><code>select</code>语法用来从多个读／写的channel中选择一个，如果没有任何channel就绪select语句将被阻塞。如果多个就绪，则随机选择一个。语法和<code>switch</code>类似，除了case后面跟随的是channel。</p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">"from server1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">"from server2"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> server1(output1)</span><br><span class="line">    <span class="keyword">go</span> server2(output2)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">        fmt.Println(s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">        fmt.Println(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中<code>server1</code>在6秒钟后向<code>ch</code>写入数据，而<code>server2</code>则3秒钟后写入。<code>main</code>函数中启动这2个goroutine，然后程序阻塞在<code>select</code>处，直到满足一个case的条件。所以程序等待3秒钟后会输出<code>from server2</code>后结束。</p><h2 id="select实践"><a href="#select实践" class="headerlink" title="select实践"></a>select实践</h2><p>假设我们有一个重要的程序需要尽快的返回数据给用户，而数据库是分布式的并且处于世界不同的地方。上面例子中的server1和server2就是这样，响应速度取决于每个服务器的负载和网络延迟，我们向所有服务器发请求，然后使用<code>select</code>来选择接受哪个服务的响应。除了第一个响应外其他的将被忽略，这样我们就可以在多个服务器中选择响应最快的那个结果返回给用户了。</p><h2 id="默认case"><a href="#默认case" class="headerlink" title="默认case"></a>默认case</h2><p><code>select</code>中的默认case将在没有任何其他case满足的情况下被执行，这通常用来阻止<code>select</code>语句阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">10500</span> * time.Millisecond)</span><br><span class="line">    ch &lt;- <span class="string">"process successful"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> process(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">"received value: "</span>, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"no value received"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>process</code>函数等待10.5秒后向<code>ch</code>写入<code>process successful</code>，执行<code>process</code>的goroutine后程序进入死循环，每秒钟尝试一次读取channel中的数据。在10.5秒钟之前程序会进入<code>default</code>分支，之后进入到<code>case v := &lt;-ch</code>分支并跳出循环，所以程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">received value:  process successful</span><br></pre></td></tr></table></figure><p></p><h2 id="死锁和默认case"><a href="#死锁和默认case" class="headerlink" title="死锁和默认case"></a>死锁和默认case</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我们创建了一个channel并尝试在<code>select</code>中读取数据，因为没有任何goroutine向其写入数据，<code>select</code>将永远阻塞下去导致死锁，报错如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan receive]:  </span><br><span class="line">main.main()  </span><br><span class="line">    /tmp/sandbox416567824/main.go:6 +0x80</span><br></pre></td></tr></table></figure><p></p><p>如果提供了默认case，程序将不会死锁：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"default case executed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default case executed</span><br></pre></td></tr></table></figure><p></p><p>类似的，如果是一个空channel(roy注:之前学channel时候说过，channel没使用make创建时的值是nil)，默认case也会被执行：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">"received value"</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"default case executed"</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述代码中我们尝试从<code>nil</code>的channel中读取数据，如果没有<code>default</code>，程序将死锁。</p><p>##　随机选择<br>当<code>select</code>中多个case都满足时，将随即选择一个：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="string">"from server1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="string">"from server2"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> server1(output1)</span><br><span class="line">    <span class="keyword">go</span> server2(output2)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">        fmt.Println(s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">        fmt.Println(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述代码中，由于main函数中等待了1秒钟，所以<code>server1</code>和<code>server2</code>都有充足的时间执行完毕，即2个case都满足。如果你多次运行这个程序，输出将在<code>from server1</code>和<code>from server2</code>随机选择。</p><h2 id="空select"><a href="#空select" class="headerlink" title="空select"></a>空select</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你觉得上面的程序输出什么？</p><p>我们知道<code>select</code>将被阻塞直到一个case满足，但上面的<code>select</code>没有任何case，因此程序将死锁，报错如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [select (no cases)]:  </span><br><span class="line">main.main()  </span><br><span class="line">    /tmp/sandbox299546399/main.go:4 +0x20</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/select/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;什么是Select&quot;&gt;&lt;a href=&quot;#什么是Select&quot; class=&quot;headerlink&quot; title=&quot;什么是Select&quot;&gt;&lt;/a&gt;什么是Select&lt;/h2&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;语法用来从多个读／写的channel中选择一个，如果没有任何channel就绪select语句将被阻塞。如果多个就绪，则随机选择一个。语法和&lt;code&gt;switch&lt;/code&gt;类似，除了case后面跟随的是channel。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-缓冲区Channels和线程池</title>
    <link href="http://www.hi-roy.com/2018/06/04/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BC%93%E5%86%B2%E5%8C%BAChannels%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.hi-roy.com/2018/06/04/GO语言学习笔记-缓冲区Channels和线程池/</id>
    <published>2018-06-04T14:11:55.000Z</published>
    <updated>2019-09-16T08:11:51.458Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/buffered-channels-worker-pools/" target="_blank" rel="noopener">原文</a>，这里为了方便理解我把worker pools翻译成线程池。</p><h2 id="什么是缓冲区Channel"><a href="#什么是缓冲区Channel" class="headerlink" title="什么是缓冲区Channel"></a>什么是缓冲区Channel</h2><p>之前讨论的所有channel都是不带缓冲区的，因此读取和写入都会被阻塞。创建一个带缓冲区的channel也是可能的，这种channel只有在缓冲区满后再写入或者读取一个空的channel时才会被阻塞。</p><p>创建一个带缓冲区的channel需要一个额外的参数容量来表明缓冲区大小：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, capacity)</span><br></pre></td></tr></table></figure><p></p><p>上面代码中的 <em>capacity</em>　需要大于０，如果等于０的话则是之前学习的无缓冲区channel。</p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="string">"naveen"</span></span><br><span class="line">    ch &lt;- <span class="string">"paul"</span></span><br><span class="line">    fmt.Println(&lt;- ch)</span><br><span class="line">    fmt.Println(&lt;- ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们创建了一个容量为2的channel，所以在写入２个字符串之前的写操作不会被阻塞。然后分别在12、13行读取，程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">naveen  </span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p></p><h2 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h2><p>我们再来看一个例子，我们在并发执行的goroutine中进行写操作，然后在main goroutine中读取，这个例子帮助我们更好的理解缓冲区channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">        fmt.Println(<span class="string">"successfully wrote"</span>, i, <span class="string">"to ch"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> write(ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read value"</span>, v,<span class="string">"from ch"</span>)</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，我们创建了一个容量是2的缓冲区channel，并把它作为参数传递给<code>write</code>函数，接下来sleep2秒钟。同时<code>write</code>函数并发的执行，在函数中使用<code>for</code>循环向<code>ch</code>写入0-4。由于容量是2，所以可以立即向channel中写入0和１，然后阻塞等待至少一个值被读取。所以程序会立即输出下面２行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">successfully wrote 0 to ch  </span><br><span class="line">successfully wrote 1 to ch</span><br></pre></td></tr></table></figure><p></p><p>当main函数中sleep２秒后，进入<code>for range</code>循环中开始读取数据，然后继续sleep２秒钟。所以程序接下来会输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read value 0 from ch  </span><br><span class="line">successfully wrote 2 to ch</span><br></pre></td></tr></table></figure><p></p><p>如此循环直到channel被关闭为止，程序最终输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">successfully wrote 0 to ch  </span><br><span class="line">successfully wrote 1 to ch  </span><br><span class="line">read value 0 from ch  </span><br><span class="line">successfully wrote 2 to ch  </span><br><span class="line">read value 1 from ch  </span><br><span class="line">successfully wrote 3 to ch  </span><br><span class="line">read value 2 from ch  </span><br><span class="line">successfully wrote 4 to ch  </span><br><span class="line">read value 3 from ch  </span><br><span class="line">read value 4 from ch</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="string">"naveen"</span></span><br><span class="line">    ch &lt;- <span class="string">"paul"</span></span><br><span class="line">    ch &lt;- <span class="string">"steve"</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，我们想向容量为2的channel中写入３个字符串。程序执行到１１行时候将会被阻塞，因为此时channel缓冲区已经满了。如果没有其他goroutine从中读取数据，程序将会死锁。报错如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:  </span><br><span class="line">main.main()  </span><br><span class="line">    /tmp/sandbox274756028/main.<span class="keyword">go</span>:<span class="number">11</span> +<span class="number">0x100</span></span><br></pre></td></tr></table></figure><p></p><h2 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h2><p>容量是指一个有缓冲区的channel能够最多同时存储多少数据，这个值在使用<code>make</code>关键字用在创建channel时。而长度则是指当前channel中已经存放了多少个数据。我们看下面的代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="string">"naveen"</span></span><br><span class="line">    ch &lt;- <span class="string">"paul"</span></span><br><span class="line">    fmt.Println(<span class="string">"capacity is"</span>, <span class="built_in">cap</span>(ch))</span><br><span class="line">    fmt.Println(<span class="string">"length is"</span>, <span class="built_in">len</span>(ch))</span><br><span class="line">    fmt.Println(<span class="string">"read value"</span>, &lt;-ch)</span><br><span class="line">    fmt.Println(<span class="string">"new length is"</span>, <span class="built_in">len</span>(ch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码中我们创建了一个容量为3的channel，然后向里面写入2个字符串，因此现在channel的长度是２。接下来从channel中读取１个字符串，所以现在长度是１。程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capacity is 3  </span><br><span class="line">length is 2  </span><br><span class="line">read value naveen  </span><br><span class="line">new length is 1</span><br></pre></td></tr></table></figure><p></p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>下一节我们将要介绍线程池(worker pools)，为了更好的理解，我们需要先介绍<code>WaitGroup</code>，然后我们基于这个实现线程池。</p><p>WaitGroup用来等待一组goroutine都执行完毕，在这之前程序都会被阻塞。假设我们有３个goroutine，主程序会等待这3个goroutine都执行结束才会退出。不多说看代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"started Goroutine "</span>, i)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">"Goroutine %d ended\n"</span>, i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    no := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; no; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> process(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"All go routines finished executing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><a href="https://golang.org/pkg/sync/#WaitGroup" target="_blank" rel="noopener">WaitGroup</a>是一种struct类型，我们在18行创建了一个默认值的WaitGroup，其内部是基于计数器实现的。我们调用<code>Add</code>方法并传递给其一个数字作为参数，计数器将增长传入参数的值。当调用<code>Done</code>方法，计数器将自减１。<code>Wait</code>方法阻塞goroutine直到计数器归零。</p><p>上面的代码中通过在循环中调用<code>wg.Add(1)</code>来使计数器变成3，同时启动3个goroutine，然后掉用<code>wg.Wait()</code>阻塞主goroutine，直到计数器归零。在函数<code>process</code>中，调用<code>wg.Done()</code>来减小计数器，一旦三个goroutine执行结束，<code>wg.Done()</code>将被执行3次，计数器归零，主goroutine解除阻塞。</p><p><strong>传递<code>wg</code>的地址给goroutine是非常重要的！如果传递的不是地址，那么每个goroutine都将有一份拷贝，这样的话每个goroutine结束就不能通知到<code>main</code>函数了。</strong></p><p>程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">started Goroutine  2  </span><br><span class="line">started Goroutine  0  </span><br><span class="line">started Goroutine  1  </span><br><span class="line">Goroutine 0 ended  </span><br><span class="line">Goroutine 2 ended  </span><br><span class="line">Goroutine 1 ended  </span><br><span class="line">All go routines finished executing</span><br></pre></td></tr></table></figure><p></p><p>你的输出结果可能和上面略有不同。</p><h2 id="线程池-worker-pools"><a href="#线程池-worker-pools" class="headerlink" title="线程池(worker pools)"></a>线程池(worker pools)</h2><p>缓冲区channel一个重要的使用方法就是实现线程池。</p><p>通常来说，线程池就是一组线程的集合等待任务分配给他们，一旦完成任务，则继续等待下一个任务。</p><p>接下来我们实现一个线程池，来计算输入数字每一位的和。比如输入１２３，则返回９(1+2+3)，输入给线程池的数字由伪随机算法生成。</p><p>下面是我们需要的核心步骤：</p><ul><li>创建一组goroutine集合监听缓冲区channel等待任务。</li><li>向缓冲区channel添加任务。</li><li>任务结束后向另一个缓冲区channel写入结果。</li><li>从存储结果的channel读取数据并输出。</li></ul><p>首先我们创建存储任务和结果的结构：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;  </span><br><span class="line">    id       <span class="keyword">int</span></span><br><span class="line">    randomno <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;  </span><br><span class="line">    job         Job</span><br><span class="line">    sumofdigits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>每个<code>Job</code>都有一个<code>id</code>和一个<code>randomno</code>用来存储将要计算的随机数。而<code>Result</code>类型则包括<code>Job</code>属性和<code>sumofdigits</code>存储结果。</p><p>接下来创建缓冲区channel来接收任务和结果：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">10</span>)  </span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>goroutine从jobs中获取任务，并向results写入结果。</p><p>下面的<code>digits</code>函数用来计算求和并且返回结果，我们通过<code>Sleep</code>来模拟进行耗时的计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digits</span><span class="params">(number <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    no := number</span><br><span class="line">    <span class="keyword">for</span> no != <span class="number">0</span> &#123;</span><br><span class="line">        digit := no % <span class="number">10</span></span><br><span class="line">        sum += digit</span><br><span class="line">        no /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的函数创建goroutine：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        output := Result&#123;job, digits(job.randomno)&#125;</span><br><span class="line">        results &lt;- output</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过读取<code>jobs</code>中的任务来创建<code>Result</code>结构，并存储函数<code>digits</code>计算后的结果，然后再将其写入<code>results</code>这个channel。这个函数接收一个WaitGroup类型的指针参数<code>wg</code>，并且在计算完成后调用<code>wg.Done()</code>。</p><p><code>createWorkerPool</code>这个函数用来创建线程池：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorkerPool</span><span class="params">(noOfWorkers <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfWorkers; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这个函数创建了包含<code>noOfWorkers</code>个goroutine的线程池，创建goroutine之前调用<code>wg.Add(1)</code>来增加计数器，然后将<code>wg</code>的地址传递给<code>worker</code>函数。创建完成后，使用<code>wg.Wait()</code>等待所有的goroutine执行完毕，然后又调用<code>close</code>函数关闭<code>results</code>这个channel，这样以后就没有任何goroutine能写入数据了。</p><p>接下来，我们来编写函数向线程池分配任务：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(noOfJobs <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfJobs; i++ &#123;</span><br><span class="line">        randomno := rand.Intn(<span class="number">999</span>)</span><br><span class="line">        job := Job&#123;i, randomno&#125;</span><br><span class="line">        jobs &lt;- job</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这个函数通过传入的参数决定写入的任务数量，随机数最大值是<code>998</code>，并且使用循环中的计数器<code>i</code>作为ID来创建<code>job</code>结构并写入<code>jobs</code>，完成后关闭<code>jobs</code>。</p><p>接下来创建函数读取<code>results</code>这个channel并且打印输出:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">result</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Job id %d, input random no %d , sum of digits %d\n"</span>, result.job.id, result.job.randomno, result.sumofdigits)</span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这个函数读取<code>results</code>并且打印id、随机数和结果，最后向<code>done</code>这个channel写入数据表明其已经打印了全部的结果。</p><p>万事具备，让我们完成<code>main</code>函数：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    noOfJobs := <span class="number">100</span></span><br><span class="line">    <span class="keyword">go</span> allocate(noOfJobs)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> result(done)</span><br><span class="line">    noOfWorkers := <span class="number">10</span></span><br><span class="line">    createWorkerPool(noOfWorkers)</span><br><span class="line">    &lt;-done</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    diff := endTime.Sub(startTime)</span><br><span class="line">    fmt.Println(<span class="string">"total time taken "</span>, diff.Seconds(), <span class="string">"seconds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先我们记录程序开始执行的时间，最后用结束时间减去开始时间计算程序运行时常，我们需要这个时常来比较不同数量的线程池的差异。</p><p>创建名为<code>done</code>的channel，并传递给<code>result</code>函数，这样就可以打印输出并且在完成全部输出后得到通知了。</p><p>最后创建了10个goroutine的线程池，并通过读取<code>done</code>来等待计算全部完成。</p><p>完整代码如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;  </span><br><span class="line">    id       <span class="keyword">int</span></span><br><span class="line">    randomno <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;  </span><br><span class="line">    job         Job</span><br><span class="line">    sumofdigits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">10</span>)  </span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digits</span><span class="params">(number <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    no := number</span><br><span class="line">    <span class="keyword">for</span> no != <span class="number">0</span> &#123;</span><br><span class="line">        digit := no % <span class="number">10</span></span><br><span class="line">        sum += digit</span><br><span class="line">        no /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        output := Result&#123;job, digits(job.randomno)&#125;</span><br><span class="line">        results &lt;- output</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorkerPool</span><span class="params">(noOfWorkers <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfWorkers; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(noOfJobs <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfJobs; i++ &#123;</span><br><span class="line">        randomno := rand.Intn(<span class="number">999</span>)</span><br><span class="line">        job := Job&#123;i, randomno&#125;</span><br><span class="line">        jobs &lt;- job</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">result</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Job id %d, input random no %d , sum of digits %d\n"</span>, result.job.id, result.job.randomno, result.sumofdigits)</span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    noOfJobs := <span class="number">100</span></span><br><span class="line">    <span class="keyword">go</span> allocate(noOfJobs)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> result(done)</span><br><span class="line">    noOfWorkers := <span class="number">10</span></span><br><span class="line">    createWorkerPool(noOfWorkers)</span><br><span class="line">    &lt;-done</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    diff := endTime.Sub(startTime)</span><br><span class="line">    fmt.Println(<span class="string">"total time taken "</span>, diff.Seconds(), <span class="string">"seconds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Job id 1, input random no 636, sum of digits 15  </span><br><span class="line">Job id 0, input random no 878, sum of digits 23  </span><br><span class="line">Job id 9, input random no 150, sum of digits 6  </span><br><span class="line">...</span><br><span class="line">total time taken  20.01081009 seconds</span><br></pre></td></tr></table></figure><p></p><p>程序会有100行的输出，因为我们创建了100个job，你的输出顺序可能和我不同，并且时间也可能不一样，这取决于硬件配置。在我这总共用时20秒。</p><p>接下来提高<code>noOfWorkers</code>到20，我们提高了线程池中goroutine的数量(翻了一倍)，运行时间绝对应该减少(接近一半)。在我的机器上，程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">total time taken  10.004364685 seconds</span><br></pre></td></tr></table></figure><p></p><p>这样我们可以明白了，线程池中goroutine增加会让程序运行时间减少。你可以随意调整<code>main</code>中的<code>noOfJobs</code>和<code>noOfWorkers</code>的值来分析结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/buffered-channels-worker-pools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，这里为了方便理解我把worker pools翻译成线程池。&lt;/p&gt;&lt;h2 id=&quot;什么是缓冲区Channel&quot;&gt;&lt;a href=&quot;#什么是缓冲区Channel&quot; class=&quot;headerlink&quot; title=&quot;什么是缓冲区Channel&quot;&gt;&lt;/a&gt;什么是缓冲区Channel&lt;/h2&gt;&lt;p&gt;之前讨论的所有channel都是不带缓冲区的，因此读取和写入都会被阻塞。创建一个带缓冲区的channel也是可能的，这种channel只有在缓冲区满后再写入或者读取一个空的channel时才会被阻塞。&lt;/p&gt;&lt;p&gt;创建一个带缓冲区的channel需要一个额外的参数容量来表明缓冲区大小：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;, capacity)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面代码中的 &lt;em&gt;capacity&lt;/em&gt;　需要大于０，如果等于０的话则是之前学习的无缓冲区channel。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
</feed>
