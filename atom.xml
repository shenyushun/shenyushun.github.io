<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi!Roy!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.hi-roy.com/"/>
  <updated>2019-09-17T09:52:54.381Z</updated>
  <id>http://www.hi-roy.com/</id>
  
  <author>
    <name>Roy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenStack源码学习笔记1</title>
    <link href="http://www.hi-roy.com/2019/09/16/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://www.hi-roy.com/2019/09/16/OpenStack源码学习笔记1/</id>
    <published>2019-09-16T09:46:29.000Z</published>
    <updated>2019-09-17T09:52:54.381Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%e9%a2%84%e5%a4%87%e7%9f%a5%e8%af%86">预备知识</a><ul><li><a href="#%e8%99%9a%e6%8b%9f%e5%8c%96">虚拟化</a></li><li><a href="#wsgi">WSGI</a></li><li><a href="#paste-deployment">Paste Deployment</a></li></ul></li><li><a href="#%e9%80%9a%e7%94%a8%e5%a5%97%e8%b7%af">通用套路</a></li><li><a href="#%e9%85%8d%e7%bd%ae%e5%8a%a0%e8%bd%bd%e4%b8%8e%e8%b7%af%e7%94%b1%e7%bb%91%e5%ae%9a">配置加载与路由绑定</a></li><li><a href="#%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e6%9c%ba">创建虚拟机</a><ul><li><a href="#nova-api">Nova-Api</a></li><li><a href="#nova-conductor-1">Nova-Conductor-1</a></li><li><a href="#nova-scheduler">Nova-Scheduler</a></li><li><a href="#nova-conductor-2">Nova-Conductor-2</a></li><li><a href="#nova-compute">Nova-Compute</a></li></ul></li></ul><p>作为已经比较成熟的IAAS开源解决方案，OpenStack已经发布了19个版本，目前稳定版是Stein，并且下一个版本Train也预计在10月发布。可以说，从代码架构角度来说对于初学者来说已经略微复杂，但最核心的组件有以下几个：</p><ol><li>Nova：负责虚拟机相关。</li><li>Glance：负责镜像相关。</li><li>Cinder：负责存储相关。</li><li>Neutron：负责网络相关。</li><li>Keystone：负责鉴权以及服务注册。</li></ol><p>大体架构如下图：</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/opstack/openstack-arch-kilo-logical-v1.png" alt="all.png"></p><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>正式开始学习Openstack源码前，需要一些预备知识，不用特别深入但要知道是做什么的。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>虚拟化本身就是一门比较复杂的学问，涉及硬件、操作系统、软件等多个层面知识。这里至少要知道4个名词：</p><ol><li>KVM</li><li>Qemu</li><li>Qemu-KVM</li><li>Libvert</li></ol><p>其中KVM在负责对CPU和内存进行虚拟化，Qemu负责对IO进行虚拟化，而Qemu-KVM则是整合了这2者。而Libvert则是提供了一个更加方便的封装，通过Libvertd服务以及virt-*、virsh命令来方便的管理虚拟机。而OpenStack则在此基础上更进一步的封装，通过各种driver插件来管理不同类型的虚拟机。</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/opstack/qemu-kvm.png" alt="qemu-kvm-libvert"></p><h3 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h3><p>OpenStack的哲学是各个组件通过API以及消息队列建立联系，既然要对外暴露端口，那么其中自然少不了WSGI的存在。<br>简单来说，WSGI解耦了Web Server和Web Application，可以让开发人员专注于功能实现而不是网络协议的处理上。</p><h3 id="Paste-Deployment"><a href="#Paste-Deployment" class="headerlink" title="Paste Deployment"></a>Paste Deployment</h3><p><a href="https://pastedeploy.readthedocs.io/en/latest/" target="_blank" rel="noopener">pastedeploy</a>，这个我也是开始阅读Openstack才学到的新知识，用来建立Server和Application之间的联系。<br>简单来说就是提供服务发现功能，并且隐藏Application的实现细节的，等开始查看Nova代码时候再详细说明。</p><h2 id="通用套路"><a href="#通用套路" class="headerlink" title="通用套路"></a>通用套路</h2><p><a href="https://github.com/openstack" target="_blank" rel="noopener">Openstack</a>的Github主页已经将各个组件拆分，但基本全部遵循着一个相似的结构，比较需要重点关注的文件有3个：</p><ol><li><code>api.py</code>提供对外访问的接口，可以从这开始入手跟踪各个功能实现。</li><li><code>rpcapi.py</code>封装RPC请求调用，大多数是异步调用。</li><li><code>manager.py</code>各种RPC调用的实现，基本和<code>rpcapi.py</code>中调用的名称一一对应。</li></ol><p>另外需要关注的就是根目录中的<code>setup.cfg</code>文件，特别是其中的<code>console_scripts</code>，可以说安装完Openstack后提供的各种命令对应的函数都在这里了，可以说是学习Openstack源码的路标。</p><p>此外还有一点，Openstack的目录结构是根据功能划分的，比如Nova中compute目录不一定都是在<code>nova-compute</code>节点上运行，而是所有和虚拟机创建相关的功能都在这里。</p><h2 id="配置加载与路由绑定"><a href="#配置加载与路由绑定" class="headerlink" title="配置加载与路由绑定"></a>配置加载与路由绑定</h2><p>这里以stein版的Nova为例，根据架构图，Nova-api是所有虚拟机相关请求的入口，首先看Nova中<code>setup.cfg</code>文件定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">……省略……</span><br><span class="line"></span><br><span class="line">nova.compute.monitors.cpu =</span><br><span class="line">    virt_driver = nova.compute.monitors.cpu.virt_driver:Monitor</span><br><span class="line"></span><br><span class="line">console_scripts =</span><br><span class="line">    nova-api = nova.cmd.api:main</span><br><span class="line">    nova-api-metadata = nova.cmd.api_metadata:main</span><br><span class="line">    nova-compute = nova.cmd.compute:main</span><br><span class="line">    nova-conductor = nova.cmd.conductor:main</span><br><span class="line">    nova-console = nova.cmd.console:main</span><br><span class="line">    nova-manage = nova.cmd.manage:main</span><br><span class="line">    nova-network = nova.cmd.network:main</span><br><span class="line">    nova-scheduler = nova.cmd.scheduler:main</span><br><span class="line"></span><br><span class="line">nova.scheduler.driver =</span><br><span class="line">    filter_scheduler = nova.scheduler.filter_scheduler:FilterScheduler</span><br><span class="line">    fake_scheduler = nova.tests.unit.scheduler.fakes:FakeScheduler</span><br><span class="line">……省略……</span><br></pre></td></tr></table></figure><p>从配置文件可以明显的看出，nova-api对应的文件是<code>nova/cmd/api.py</code>的<code>main()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, <span class="string">"nova"</span>)</span><br><span class="line">    objects.register_all()</span><br><span class="line">    gmr_opts.set_defaults(CONF)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'osapi_compute'</span> <span class="keyword">in</span> CONF.enabled_apis:</span><br><span class="line">        <span class="comment"># NOTE(mriedem): This is needed for caching the nova-compute service</span></span><br><span class="line">        <span class="comment"># version.</span></span><br><span class="line">        objects.Service.enable_min_version_cache()</span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line">    launcher = service.process_launcher()</span><br><span class="line">    started = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> api <span class="keyword">in</span> CONF.enabled_apis:</span><br><span class="line">        should_use_ssl = api <span class="keyword">in</span> CONF.enabled_ssl_apis</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server = service.WSGIService(api, use_ssl=should_use_ssl)</span><br><span class="line">            launcher.launch_service(server, workers=server.workers <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line">            started += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> exception.PasteAppNotFound <span class="keyword">as</span> ex:</span><br><span class="line">            log.warning(<span class="string">"%s. ``enabled_apis`` includes bad values. "</span></span><br><span class="line">                        <span class="string">"Fix to remove this warning."</span>, ex)</span><br><span class="line">    <span class="keyword">if</span> started == <span class="number">0</span>:</span><br><span class="line">        log.error(<span class="string">'No APIs were started. '</span></span><br><span class="line">                  <span class="string">'Check the enabled_apis config option.'</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure><p><code>main</code>函数其实就做了一件事，启动配置文件中设定的WSGI服务，默认情况下配置文件位于<code>/etc/nova/nova.conf</code>，配置文件中定义了启用哪些服务、Glance、Cinder、Keystone、Libvert、数据库等信息。说到这里简单提一下 <a href="https://github.com/openstack/oslo.config" target="_blank" rel="noopener">oslo_config</a>这个项目，是从Openstack独立出来的专门处理配置文件的基础功能库。</p><p>查看<code>WSGIService</code>的定义，位于<code>nova/service.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIService</span><span class="params">(service.Service)</span>:</span></span><br><span class="line">    <span class="string">"""Provides ability to launch API from a 'paste' configuration."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, loader=None, use_ssl=False, max_url_len=None)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize, but do not start the WSGI server.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: The name of the WSGI server given to the loader.</span></span><br><span class="line"><span class="string">        :param loader: Loads the WSGI application using the given name.</span></span><br><span class="line"><span class="string">        :returns: None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># NOTE(danms): Name can be metadata, osapi_compute, per</span></span><br><span class="line">        <span class="comment"># nova.service's enabled_apis</span></span><br><span class="line">        self.binary = <span class="string">'nova-%s'</span> % name</span><br><span class="line"></span><br><span class="line">        LOG.warning(<span class="string">'Running %s using eventlet is deprecated. Deploy with '</span></span><br><span class="line">                    <span class="string">'a WSGI server such as uwsgi or mod_wsgi.'</span>, self.binary)</span><br><span class="line"></span><br><span class="line">        self.topic = <span class="literal">None</span></span><br><span class="line">        self.manager = self._get_manager()</span><br><span class="line">        self.loader = loader <span class="keyword">or</span> api_wsgi.Loader()</span><br><span class="line">        self.app = self.loader.load_app(name)</span><br><span class="line">        <span class="comment"># inherit all compute_api worker counts from osapi_compute</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'openstack_compute_api'</span>):</span><br><span class="line">            wname = <span class="string">'osapi_compute'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            wname = name</span><br><span class="line">        self.host = getattr(CONF, <span class="string">'%s_listen'</span> % name, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">        self.port = getattr(CONF, <span class="string">'%s_listen_port'</span> % name, <span class="number">0</span>)</span><br><span class="line">        self.workers = (getattr(CONF, <span class="string">'%s_workers'</span> % wname, <span class="literal">None</span>) <span class="keyword">or</span></span><br><span class="line">                        processutils.get_worker_count())</span><br><span class="line">        <span class="keyword">if</span> self.workers <span class="keyword">and</span> self.workers &lt; <span class="number">1</span>:</span><br><span class="line">            worker_name = <span class="string">'%s_workers'</span> % name</span><br><span class="line">            msg = (_(<span class="string">"%(worker_name)s value of %(workers)s is invalid, "</span></span><br><span class="line">                     <span class="string">"must be greater than 0"</span>) %</span><br><span class="line">                   &#123;<span class="string">'worker_name'</span>: worker_name,</span><br><span class="line">                    <span class="string">'workers'</span>: str(self.workers)&#125;)</span><br><span class="line">            <span class="keyword">raise</span> exception.InvalidInput(msg)</span><br><span class="line">        self.use_ssl = use_ssl</span><br><span class="line">        self.server = wsgi.Server(name,</span><br><span class="line">                                  self.app,</span><br><span class="line">                                  host=self.host,</span><br><span class="line">                                  port=self.port,</span><br><span class="line">                                  use_ssl=self.use_ssl,</span><br><span class="line">                                  max_url_len=max_url_len)</span><br><span class="line">        <span class="comment"># Pull back actual port used</span></span><br><span class="line">        self.port = self.server.port</span><br><span class="line">        self.backdoor_port = <span class="literal">None</span></span><br><span class="line">        setup_profiler(name, self.host)</span><br></pre></td></tr></table></figure><p>其中，<code>self.app = self.loader.load_app(name)</code>就是上面所说的使用Paste Deployment来建立连接的部分，相关代码位于<code>nova/api/wsgi.py</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Used to load WSGI applications from paste configurations."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config_path=None)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize the loader, and attempt to find the config.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param config_path: Full or relative path to the paste config.</span></span><br><span class="line"><span class="string">        :returns: None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.config_path = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        config_path = config_path <span class="keyword">or</span> CONF.wsgi.api_paste_config</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isabs(config_path):</span><br><span class="line">            self.config_path = CONF.find_file(config_path)</span><br><span class="line">        <span class="keyword">elif</span> os.path.exists(config_path):</span><br><span class="line">            self.config_path = config_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config_path:</span><br><span class="line">            <span class="keyword">raise</span> exception.ConfigNotFound(path=config_path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_app</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""Return the paste URLMap wrapped WSGI application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: Name of the application to load.</span></span><br><span class="line"><span class="string">        :returns: Paste URLMap object wrapping the requested application.</span></span><br><span class="line"><span class="string">        :raises: `nova.exception.PasteAppNotFound`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            LOG.debug(<span class="string">"Loading app %(name)s from %(path)s"</span>,</span><br><span class="line">                      &#123;<span class="string">'name'</span>: name, <span class="string">'path'</span>: self.config_path&#125;)</span><br><span class="line">            <span class="keyword">return</span> deploy.loadapp(<span class="string">"config:%s"</span> % self.config_path, name=name)</span><br><span class="line">        <span class="keyword">except</span> LookupError:</span><br><span class="line">            LOG.exception(_LE(<span class="string">"Couldn't lookup app: %s"</span>), name)</span><br><span class="line">            <span class="keyword">raise</span> exception.PasteAppNotFound(name=name, path=self.config_path)</span><br></pre></td></tr></table></figure><p>默认情况下，配置文件位于<code>/etc/nova/api-paste.ini</code>，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="comment"># Metadata #</span></span><br><span class="line"><span class="comment">############</span></span><br><span class="line"><span class="section">[composite:metadata]</span></span><br><span class="line"><span class="attr">use</span> = egg:Paste<span class="comment">#urlmap</span></span><br><span class="line">/: meta</span><br><span class="line"></span><br><span class="line"><span class="section">[pipeline:meta]</span></span><br><span class="line"><span class="attr">pipeline</span> = cors metaapp</span><br><span class="line"></span><br><span class="line"><span class="section">[app:metaapp]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = nova.api.metadata.handler:MetadataRequestHandler.factory</span><br><span class="line"></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># OpenStack #</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line"><span class="section">[composite:osapi_compute]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.openstack.urlmap:urlmap_factory</span><br><span class="line">/: oscomputeversions</span><br><span class="line"><span class="comment"># v21 is an exactly feature match for v2, except it has more stringent</span></span><br><span class="line"><span class="comment"># input validation on the wsgi surface (prevents fuzzing early on the</span></span><br><span class="line"><span class="comment"># API). It also provides new features via API microversions which are</span></span><br><span class="line"><span class="comment"># opt into for clients. Unaware clients will receive the same frozen</span></span><br><span class="line"><span class="comment"># v2 API feature set, but with some relaxed validation</span></span><br><span class="line">/v2: openstack_compute_api_v21_legacy_v2_compatible</span><br><span class="line">/v2.1: openstack_compute_api_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:openstack_compute_api_v21]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.auth:pipeline_factory_v21</span><br><span class="line"><span class="attr">noauth2</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler noauth2 osapi_compute_app_v21</span><br><span class="line"><span class="attr">keystone</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler authtoken keystonecontext osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:openstack_compute_api_v21_legacy_v2_compatible]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.auth:pipeline_factory_v21</span><br><span class="line"><span class="attr">noauth2</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler noauth2 legacy_v2_compatible osapi_compute_app_v21</span><br><span class="line"><span class="attr">keystone</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler authtoken keystonecontext legacy_v2_compatible osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:request_log]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack.requestlog:RequestLog.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:compute_req_id]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.compute_req_id:ComputeReqIdMiddleware.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:faultwrap]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack:FaultWrapper.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:noauth2]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack.auth:NoAuthMiddleware.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:osprofiler]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.profiler:WsgiMiddleware.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:sizelimit]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = oslo_middleware:RequestBodySizeLimiter.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:http_proxy_to_wsgi]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = oslo_middleware.http_proxy_to_wsgi:HTTPProxyToWSGI.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[filter:legacy_v2_compatible]</span></span><br><span class="line"><span class="attr">paste.filter_factory</span> = nova.api.openstack:LegacyV2CompatibleWrapper.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[app:osapi_compute_app_v21]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = nova.api.openstack.compute:APIRouterV21.factory</span><br></pre></td></tr></table></figure><p>PasteDeploy的配置文件可以包括多个段。每个段包含一个名称和多个键值对。名称由type和name组成，使用冒号分隔。每个键值对占一行，键名和值使用等号分隔。比较常用的type有：</p><ul><li>composite:用来分发请求到其它应用去。其下的键值对use = egg:Paste#urlmap表示使用Paste中的urlmap应用。urlmap是使用路径的前缀来将请求映射到不同的应用去。</li><li>app:基本的WSGI应用,通常的用法是paste.app_factory = &lt;模块名&gt;:&lt;类名&gt;.&lt;类方法&gt;。</li><li>filter-app:过滤器，通过next可以指定下一步交给谁处理，next指定的可以是一个普通的WSGI应用，也可以是另一个过滤器。</li><li>filter:过滤器，与filter-app用法上不同，其他应用中使用filter-with来指定使用此filter。</li><li>pipeline:管道，可以将多个filter和最后一个WSGI应用串联起来。</li></ul><p>比如对于<code>metadata</code>，就直接使用了Paste中的路由，而对于<code>osapi_compute</code>，则使用nova自己的<code>urlmap_factory</code>处理。这里以V2版本接口为例，当程序收到请求后转交给了<code>openstack_compute_api_v21_legacy_v2_compatible</code>，然后经过pipeline定义的各种filter处理后由<code>osapi_compute_app_v21</code>接手，而这个程序对应的代码就是<code>nova/api/openstack/compute/routes.py</code>中的<code>APIRouterV21</code>类的<code>factory</code>方法，而这个方法本质上就是创建了一个类实例并建立路由和函数之间的映射关系。</p><p>这些操作完成后通过使用eventlet创建<code>wsgi.Server</code>、绑定监听IP和端口，位于<code>nova/wsgi.py</code>的<code>Server</code>类中，这里就不贴出代码了。</p><h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><h3 id="Nova-Api"><a href="#Nova-Api" class="headerlink" title="Nova-Api"></a>Nova-Api</h3><p>根据<a href="https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#create-server" target="_blank" rel="noopener">文档</a>，创建虚拟机的行为其实就是向<code>/servers</code>发送POST请求而已。而上面已经知道在<code>nova/api/openstack/compute/routes.py</code>中定义了对应的函数是：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'/servers'</span>, &#123;</span><br><span class="line">        <span class="string">'GET'</span>: [server_controller, <span class="string">'index'</span>],</span><br><span class="line">        <span class="string">'POST'</span>: [server_controller, <span class="string">'create'</span>]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p></p><p>而这个<code>server_controller</code>是位于<code>nova/api/openstack/compute/servers.py</code>的<code>ServersController</code>类，其<code>create</code>方法定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, req, body)</span>:</span></span><br><span class="line">    <span class="string">"""Creates a new server for a given user."""</span></span><br><span class="line">    context = req.environ[<span class="string">'nova.context'</span>]</span><br><span class="line">    server_dict = body[<span class="string">'server'</span>]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[<span class="string">'name'</span>])</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    availability_zone = server_dict.pop(<span class="string">"availability_zone"</span>, <span class="literal">None</span>)</span><br><span class="line">    image_uuid = self._image_from_req_data(server_dict, create_kwargs)</span><br><span class="line">    self._process_networks_for_create(</span><br><span class="line">        context, target, server_dict, create_kwargs)</span><br><span class="line">    flavor_id = self._flavor_id_from_req_data(body)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        inst_type = flavors.get_flavor_by_flavor_id(</span><br><span class="line">                flavor_id, ctxt=context, read_deleted=<span class="string">"no"</span>)</span><br><span class="line">        supports_multiattach = common.supports_multiattach_volume(req)</span><br><span class="line">        supports_port_resource_request = \</span><br><span class="line">            common.supports_port_resource_request(req)</span><br><span class="line">        (instances, resv_id) = self.compute_api.create(context,</span><br><span class="line">            inst_type,</span><br><span class="line">            image_uuid,</span><br><span class="line">            display_name=name,</span><br><span class="line">            display_description=description,</span><br><span class="line">            availability_zone=availability_zone,</span><br><span class="line">            forced_host=host, forced_node=node,</span><br><span class="line">            metadata=server_dict.get(<span class="string">'metadata'</span>, &#123;&#125;),</span><br><span class="line">            admin_password=password,</span><br><span class="line">            check_server_group_quota=<span class="literal">True</span>,</span><br><span class="line">            supports_multiattach=supports_multiattach,</span><br><span class="line">            supports_port_resource_request=supports_port_resource_request,</span><br><span class="line">            **create_kwargs)</span><br><span class="line">    <span class="keyword">except</span> (exception.QuotaError,</span><br><span class="line">            exception.PortLimitExceeded) <span class="keyword">as</span> error:</span><br><span class="line">        <span class="keyword">raise</span> exc.HTTPForbidden(</span><br><span class="line">            explanation=error.format_message())</span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>经过一些获取、验证操作后，调用了<code>self.compute_api.create()</code>方法，这个<code>compute_api</code>就是<code>nova/compute/api.py</code>中定义的<code>API</code>类，<code>create</code>函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@hooks.add_hook("create_instance")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, context, instance_type,</span></span></span><br><span class="line"><span class="function"><span class="params">            image_href, kernel_id=None, ramdisk_id=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            min_count=None, max_count=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            display_name=None, display_description=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            key_name=None, key_data=None, security_groups=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            availability_zone=None, forced_host=None, forced_node=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            user_data=None, metadata=None, injected_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            admin_password=None, block_device_mapping=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            access_ip_v4=None, access_ip_v6=None, requested_networks=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            config_drive=None, auto_disk_config=None, scheduler_hints=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            legacy_bdm=True, shutdown_terminate=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            check_server_group_quota=False, tags=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            supports_multiattach=False, trusted_certs=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            supports_port_resource_request=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            requested_host=None, requested_hypervisor_hostname=None)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> self._create_instance(</span><br><span class="line">        context, instance_type,</span><br><span class="line">        image_href, kernel_id, ramdisk_id,</span><br><span class="line">        min_count, max_count,</span><br><span class="line">        display_name, display_description,</span><br><span class="line">        key_name, key_data, security_groups,</span><br><span class="line">        availability_zone, user_data, metadata,</span><br><span class="line">        injected_files, admin_password,</span><br><span class="line">        access_ip_v4, access_ip_v6,</span><br><span class="line">        requested_networks, config_drive,</span><br><span class="line">        block_device_mapping, auto_disk_config,</span><br><span class="line">        filter_properties=filter_properties,</span><br><span class="line">        legacy_bdm=legacy_bdm,</span><br><span class="line">        shutdown_terminate=shutdown_terminate,</span><br><span class="line">        check_server_group_quota=check_server_group_quota,</span><br><span class="line">        tags=tags, supports_multiattach=supports_multiattach,</span><br><span class="line">        trusted_certs=trusted_certs,</span><br><span class="line">        supports_port_resource_request=supports_port_resource_request,</span><br><span class="line">        requested_host=requested_host,</span><br><span class="line">        requested_hypervisor_hostname=requested_hypervisor_hostname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_instance</span><span class="params">(self, context, instance_type,</span></span></span><br><span class="line"><span class="function"><span class="params">               image_href, kernel_id, ramdisk_id,</span></span></span><br><span class="line"><span class="function"><span class="params">               min_count, max_count,</span></span></span><br><span class="line"><span class="function"><span class="params">               display_name, display_description,</span></span></span><br><span class="line"><span class="function"><span class="params">               key_name, key_data, security_groups,</span></span></span><br><span class="line"><span class="function"><span class="params">               availability_zone, user_data, metadata, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">               admin_password, access_ip_v4, access_ip_v6,</span></span></span><br><span class="line"><span class="function"><span class="params">               requested_networks, config_drive,</span></span></span><br><span class="line"><span class="function"><span class="params">               block_device_mapping, auto_disk_config, filter_properties,</span></span></span><br><span class="line"><span class="function"><span class="params">               reservation_id=None, legacy_bdm=True, shutdown_terminate=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               check_server_group_quota=False, tags=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               supports_multiattach=False, trusted_certs=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               supports_port_resource_request=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               requested_host=None, requested_hypervisor_hostname=None)</span>:</span></span><br><span class="line">    <span class="comment"># Normalize and setup some parameters</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> image_href:</span><br><span class="line">        image_id, boot_meta = self._get_image(context, image_href)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># This is similar to the logic in _retrieve_trusted_certs_object.</span></span><br><span class="line">        <span class="keyword">if</span> (trusted_certs <span class="keyword">or</span></span><br><span class="line">            (CONF.glance.verify_glance_signatures <span class="keyword">and</span></span><br><span class="line">                CONF.glance.enable_certificate_validation <span class="keyword">and</span></span><br><span class="line">                CONF.glance.default_trusted_certificate_ids)):</span><br><span class="line">            msg = _(<span class="string">"Image certificate validation is not supported "</span></span><br><span class="line">                    <span class="string">"when booting from volume"</span>)</span><br><span class="line">            <span class="keyword">raise</span> exception.CertificateValidationFailed(message=msg)</span><br><span class="line">        image_id = <span class="literal">None</span></span><br><span class="line">        boot_meta = self._get_bdm_image_metadata(</span><br><span class="line">            context, block_device_mapping, legacy_bdm)</span><br><span class="line"></span><br><span class="line">    self._check_auto_disk_config(image=boot_meta,</span><br><span class="line">                                    auto_disk_config=auto_disk_config)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    self.compute_task_api.schedule_and_build_instances(</span><br><span class="line">        context,</span><br><span class="line">        build_requests=build_requests,</span><br><span class="line">        request_spec=request_specs,</span><br><span class="line">        image=boot_meta,</span><br><span class="line">        admin_password=admin_password,</span><br><span class="line">        injected_files=injected_files,</span><br><span class="line">        requested_networks=requested_networks,</span><br><span class="line">        block_device_mapping=block_device_mapping,</span><br><span class="line">        tags=tags)</span><br><span class="line">    <span class="keyword">return</span> instances, reservation_id</span><br></pre></td></tr></table></figure><p>最终，这个函数又调用了<code>self.compute_task_api.schedule_and_build_instances</code>方法，而这个<code>compute_task_api</code>就是<code>nova/conductor/api.py</code>中定义的<code>ComputeTaskAPI</code>类，方法定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                request_spec, image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                requested_networks, block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                tags=None)</span>:</span></span><br><span class="line">    self.conductor_compute_rpcapi.schedule_and_build_instances(</span><br><span class="line">        context, build_requests, request_spec, image,</span><br><span class="line">        admin_password, injected_files, requested_networks,</span><br><span class="line">        block_device_mapping, tags)</span><br></pre></td></tr></table></figure><p>这个函数很简单，就是调用了<code>nova/conductor/rpcapi.py</code>中<code>ComputeTaskAPI</code>类的<code>schedule_and_build_instances</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                request_specs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                image, admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                requested_networks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                tags=None)</span>:</span></span><br><span class="line">    version = <span class="string">'1.17'</span></span><br><span class="line">    kw = &#123;<span class="string">'build_requests'</span>: build_requests,</span><br><span class="line">            <span class="string">'request_specs'</span>: request_specs,</span><br><span class="line">            <span class="string">'image'</span>: jsonutils.to_primitive(image),</span><br><span class="line">            <span class="string">'admin_password'</span>: admin_password,</span><br><span class="line">            <span class="string">'injected_files'</span>: injected_files,</span><br><span class="line">            <span class="string">'requested_networks'</span>: requested_networks,</span><br><span class="line">            <span class="string">'block_device_mapping'</span>: block_device_mapping,</span><br><span class="line">            <span class="string">'tags'</span>: tags&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.client.can_send_version(version):</span><br><span class="line">        version = <span class="string">'1.16'</span></span><br><span class="line">        <span class="keyword">del</span> kw[<span class="string">'tags'</span>]</span><br><span class="line"></span><br><span class="line">    cctxt = self.client.prepare(version=version)</span><br><span class="line">    cctxt.cast(context, <span class="string">'schedule_and_build_instances'</span>, **kw)</span><br></pre></td></tr></table></figure><p><code>cast</code>代表这个是一个异步调用，<code>schedule_and_build_instances</code>是调用的方法名。虽然目录从api到compute到conductor`，但上面的所有过程都是在nova-api管控下的。一直到发出这个异步请求为止，nova-api阶段结束，返回响应，虚拟机状态为building。</p><h3 id="Nova-Conductor-1"><a href="#Nova-Conductor-1" class="headerlink" title="Nova-Conductor-1"></a>Nova-Conductor-1</h3><p>上面说过，<code>manager.py</code>是对应rpc调用方法的实现，所以在<code>nova/conductor/manager.py</code>中找到函数定义如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     request_specs, image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     requested_networks, block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     tags=None)</span>:</span></span><br><span class="line">    <span class="comment"># Add all the UUIDs for the instances</span></span><br><span class="line">    instance_uuids = [spec.instance_uuid <span class="keyword">for</span> spec <span class="keyword">in</span> request_specs]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        host_lists = self._schedule_instances(context, request_specs[<span class="number">0</span>],</span><br><span class="line">                instance_uuids, return_alternates=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        LOG.exception(<span class="string">'Failed to schedule instances'</span>)</span><br><span class="line">        self._bury_in_cell0(context, request_specs[<span class="number">0</span>], exc,</span><br><span class="line">                            build_requests=build_requests,</span><br><span class="line">                            block_device_mapping=block_device_mapping,</span><br><span class="line">                            tags=tags)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_schedule_instances</span><span class="params">(self, context, request_spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                        instance_uuids=None, return_alternates=False)</span>:</span></span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec)</span><br><span class="line">    <span class="keyword">with</span> timeutils.StopWatch() <span class="keyword">as</span> timer:</span><br><span class="line">        host_lists = self.query_client.select_destinations(</span><br><span class="line">            context, request_spec, instance_uuids, return_objects=<span class="literal">True</span>,</span><br><span class="line">            return_alternates=return_alternates)</span><br><span class="line">    LOG.debug(<span class="string">'Took %0.2f seconds to select destinations for %s '</span></span><br><span class="line">                <span class="string">'instance(s).'</span>, timer.elapsed(), len(instance_uuids))</span><br><span class="line">    <span class="keyword">return</span> host_lists</span><br></pre></td></tr></table></figure><p></p><p>首先这函数调用<code>_schedule_instances</code>方法，这个方法中又调用了<code>select_destinations</code>，而<code>self.query_client</code>其实是一个<code>SchedulerQueryClient</code>类实例，位于<code>nova/scheduler/query.py</code>中，代码很耿直:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_destinations</span><span class="params">(self, context, spec_obj, instance_uuids,</span></span></span><br><span class="line"><span class="function"><span class="params">        return_objects=False, return_alternates=False)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.scheduler_rpcapi.select_destinations(context, spec_obj,</span><br><span class="line">            instance_uuids, return_objects, return_alternates)</span><br></pre></td></tr></table></figure><p>一看到rpcapi，果不其然在<code>nova/scheduler/rpcapi.py</code>中找到对应的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_destinations</span><span class="params">(self, ctxt, spec_obj, instance_uuids,</span></span></span><br><span class="line"><span class="function"><span class="params">            return_objects=False, return_alternates=False)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    cctxt = self.client.prepare(</span><br><span class="line">        version=version, call_monitor_timeout=CONF.rpc_response_timeout,</span><br><span class="line">        timeout=CONF.long_rpc_timeout)</span><br><span class="line">    <span class="keyword">return</span> cctxt.call(ctxt, <span class="string">'select_destinations'</span>, **msg_args)</span><br></pre></td></tr></table></figure><p>注意这里使用的<code>call</code>而不是<code>cast</code>，所以是一个同步调用，此时nova-conductor会堵塞等待直到nova-scheduler返回。</p><h3 id="Nova-Scheduler"><a href="#Nova-Scheduler" class="headerlink" title="Nova-Scheduler"></a>Nova-Scheduler</h3><p>根据套路，在<code>nova/scheduler/manager.py</code>中找到函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@messaging.expected_exceptions(exception.NoValidHost)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_destinations</span><span class="params">(self, ctxt, request_spec=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        filter_properties=None, spec_obj=_sentinel, instance_uuids=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        return_objects=False, return_alternates=False)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    selections = self.driver.select_destinations(ctxt, spec_obj,</span><br><span class="line">            instance_uuids, alloc_reqs_by_rp_uuid, provider_summaries,</span><br><span class="line">            allocation_request_version, return_alternates)</span><br><span class="line">    <span class="comment"># If `return_objects` is False, we need to convert the selections to</span></span><br><span class="line">    <span class="comment"># the older format, which is a list of host state dicts.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> return_objects:</span><br><span class="line">        selection_dicts = [sel[<span class="number">0</span>].to_dict() <span class="keyword">for</span> sel <span class="keyword">in</span> selections]</span><br><span class="line">        <span class="keyword">return</span> jsonutils.to_primitive(selection_dicts)</span><br><span class="line">    <span class="keyword">return</span> selections</span><br></pre></td></tr></table></figure><p>这个函数本质上又是一层封装，最终调用的是<code>nova-api.conf</code>文件中定义的<code>scheduler.driver</code>，这里以自带的<code>FilterScheduler</code>为例，位于<code>nova/scheduler/filter_scheduler.py</code>，入口函数是<code>_schedule</code>，在这里首先获取全部的host，然后经过<code>_get_sorted_hosts</code>函数的筛选和权重计算，返回满足条件的主机给nova-conductor。</p><h3 id="Nova-Conductor-2"><a href="#Nova-Conductor-2" class="headerlink" title="Nova-Conductor-2"></a>Nova-Conductor-2</h3><p>回到<code>nova/conductor/manager.py</code>的<code>schedule_and_build_instances</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_and_build_instances</span><span class="params">(self, context, build_requests,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     request_specs, image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     admin_password, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     requested_networks, block_device_mapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     tags=None)</span>:</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    zipped = six.moves.zip(build_requests, request_specs, host_lists,</span><br><span class="line">                            instances)</span><br><span class="line">    <span class="keyword">for</span> (build_request, request_spec, host_list, instance) <span class="keyword">in</span> zipped:</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> obj_target_cell(instance, cell) <span class="keyword">as</span> cctxt:</span><br><span class="line">            <span class="comment"># send a state update notification for the initial create to</span></span><br><span class="line">            <span class="comment"># show it going from non-existent to BUILDING</span></span><br><span class="line">            <span class="comment"># This can lazy-load attributes on instance.</span></span><br><span class="line">            notifications.send_update_with_states(cctxt, instance, <span class="literal">None</span>,</span><br><span class="line">                    vm_states.BUILDING, <span class="literal">None</span>, <span class="literal">None</span>, service=<span class="string">"conductor"</span>)</span><br><span class="line">            objects.InstanceAction.action_start(</span><br><span class="line">                cctxt, instance.uuid, instance_actions.CREATE,</span><br><span class="line">                want_result=<span class="literal">False</span>)</span><br><span class="line">            instance_bdms = self._create_block_device_mapping(</span><br><span class="line">                cell, instance.flavor, instance.uuid, block_device_mapping)</span><br><span class="line">            instance_tags = self._create_tags(cctxt, instance.uuid, tags)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update mapping for instance. Normally this check is guarded by</span></span><br><span class="line">        <span class="comment"># a try/except but if we're here we know that a newer nova-api</span></span><br><span class="line">        <span class="comment"># handled the build process and would have created the mapping</span></span><br><span class="line">        inst_mapping = objects.InstanceMapping.get_by_instance_uuid(</span><br><span class="line">            context, instance.uuid)</span><br><span class="line">        inst_mapping.cell_mapping = cell</span><br><span class="line">        inst_mapping.save()</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        legacy_secgroups = [s.identifier</span><br><span class="line">                            <span class="keyword">for</span> s <span class="keyword">in</span> request_spec.security_groups]</span><br><span class="line">        <span class="keyword">with</span> obj_target_cell(instance, cell) <span class="keyword">as</span> cctxt:</span><br><span class="line">            self.compute_rpcapi.build_and_run_instance(</span><br><span class="line">                cctxt, instance=instance, image=image,</span><br><span class="line">                request_spec=request_spec,</span><br><span class="line">                filter_properties=filter_props,</span><br><span class="line">                admin_password=admin_password,</span><br><span class="line">                injected_files=injected_files,</span><br><span class="line">                requested_networks=requested_networks,</span><br><span class="line">                security_groups=legacy_secgroups,</span><br><span class="line">                block_device_mapping=instance_bdms,</span><br><span class="line">                host=host.service_host, node=host.nodename,</span><br><span class="line">                limits=host.limits, host_list=host_list)</span><br></pre></td></tr></table></figure><p>拿到主机列表后，由于可能同时创建多台主机，所以使用for循环，进行了一些数据库操作后，进行rpc调用，位于<code>nova/compute/rpcapi.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_and_run_instance</span><span class="params">(self, ctxt, instance, host, image, request_spec,</span></span></span><br><span class="line"><span class="function"><span class="params">        filter_properties, admin_password=None, injected_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        requested_networks=None, security_groups=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        block_device_mapping=None, node=None, limits=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        host_list=None)</span>:</span></span><br><span class="line">    ......    </span><br><span class="line">    cctxt.cast(ctxt, <span class="string">'build_and_run_instance'</span>, **kwargs)</span><br></pre></td></tr></table></figure><h3 id="Nova-Compute"><a href="#Nova-Compute" class="headerlink" title="Nova-Compute"></a>Nova-Compute</h3><p>套路都熟悉了，直接看<code>nova/compute/manager.py</code>吧，其实最核心函数是<code>_build_and_run_instance</code>，这里进行镜像、网络资源的准备以及各种验证、状态修改、发送通知等。最后调用对应driver的spawn方法，这里以libvert为例，对应文件是<code>nova/virt/libvirt/driver.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(self, context, instance, image_meta, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">            admin_password, allocations, network_info=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            block_device_info=None, power_on=True)</span>:</span></span><br><span class="line">    disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,</span><br><span class="line">                                        instance,</span><br><span class="line">                                        image_meta,</span><br><span class="line">                                        block_device_info)</span><br><span class="line">    injection_info = InjectionInfo(network_info=network_info,</span><br><span class="line">                                    files=injected_files,</span><br><span class="line">                                    admin_pass=admin_password)</span><br><span class="line">    gen_confdrive = functools.partial(self._create_configdrive,</span><br><span class="line">                                        context, instance,</span><br><span class="line">                                        injection_info)</span><br><span class="line">    self._create_image(context, instance, disk_info[<span class="string">'mapping'</span>],</span><br><span class="line">                        injection_info=injection_info,</span><br><span class="line">                        block_device_info=block_device_info)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required by Quobyte CI</span></span><br><span class="line">    self._ensure_console_log_for_instance(instance)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Does the guest need to be assigned some vGPU mediated devices ?</span></span><br><span class="line">    mdevs = self._allocate_mdevs(allocations)</span><br><span class="line"></span><br><span class="line">    xml = self._get_guest_xml(context, instance, network_info,</span><br><span class="line">                                disk_info, image_meta,</span><br><span class="line">                                block_device_info=block_device_info,</span><br><span class="line">                                mdevs=mdevs)</span><br><span class="line">    self._create_domain_and_network(</span><br><span class="line">        context, xml, instance, network_info,</span><br><span class="line">        block_device_info=block_device_info,</span><br><span class="line">        post_xml_callback=gen_confdrive,</span><br><span class="line">        destroy_disks_on_failure=<span class="literal">True</span>,</span><br><span class="line">        power_on=power_on)</span><br><span class="line">    LOG.debug(<span class="string">"Guest created on hypervisor"</span>, instance=instance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_wait_for_boot</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""Called at an interval until the VM is running."""</span></span><br><span class="line">        state = self.get_info(instance).state</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> state == power_state.RUNNING:</span><br><span class="line">            LOG.info(<span class="string">"Instance spawned successfully."</span>, instance=instance)</span><br><span class="line">            <span class="keyword">raise</span> loopingcall.LoopingCallDone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> power_on:</span><br><span class="line">        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_boot)</span><br><span class="line">        timer.start(interval=<span class="number">0.5</span>).wait()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LOG.info(<span class="string">"Instance spawned successfully."</span>, instance=instance)</span><br></pre></td></tr></table></figure><p>在这里拉取镜像创建根目录，生成XML(默认在/etc/libvert/qemu目录)，定义网络和domain并启动，然后虚拟机状态为running。到此为止，创建虚拟机完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#%e9%a2%84%e5%a4%87%e7%9f%a5%e8%af%86&quot;&gt;预备知识&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#%e8%99%9a%e6%8b%9f%e5%8c%96&quot;&gt;虚拟化&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#wsgi&quot;&gt;WSGI&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#paste-deployment&quot;&gt;Paste Deployment&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#%e9%80%9a%e7%94%a8%e5%a5%97%e8%b7%af&quot;&gt;通用套路&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#%e9%85%8d%e7%bd%ae%e5%8a%a0%e8%bd%bd%e4%b8%8e%e8%b7%af%e7%94%b1%e7%bb%91%e5%ae%9a&quot;&gt;配置加载与路由绑定&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e6%9c%ba&quot;&gt;创建虚拟机&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#nova-api&quot;&gt;Nova-Api&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-conductor-1&quot;&gt;Nova-Conductor-1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-scheduler&quot;&gt;Nova-Scheduler&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-conductor-2&quot;&gt;Nova-Conductor-2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#nova-compute&quot;&gt;Nova-Compute&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;作为已经比较成熟的IAAS开源解决方案，OpenStack已经发布了19个版本，目前稳定版是Stein，并且下一个版本Train也预计在10月发布。可以说，从代码架构角度来说对于初学者来说已经略微复杂，但最核心的组件有以下几个：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Nova：负责虚拟机相关。&lt;/li&gt;&lt;li&gt;Glance：负责镜像相关。&lt;/li&gt;&lt;li&gt;Cinder：负责存储相关。&lt;/li&gt;&lt;li&gt;Neutron：负责网络相关。&lt;/li&gt;&lt;li&gt;Keystone：负责鉴权以及服务注册。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;大体架构如下图：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/opstack/openstack-arch-kilo-logical-v1.png&quot; alt=&quot;all.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Nova" scheme="http://www.hi-roy.com/source/all-tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy-Redis结合POST请求获取数据</title>
    <link href="http://www.hi-roy.com/2019/05/06/Scrapy-Redis%E7%BB%93%E5%90%88POST%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.hi-roy.com/2019/05/06/Scrapy-Redis结合POST请求获取数据/</id>
    <published>2019-05-06T08:31:37.000Z</published>
    <updated>2019-09-16T08:11:51.470Z</updated>
    
    <content type="html"><![CDATA[<p>能看到这篇文章的小伙伴肯定已经知道什么是Scrapy以及Scrapy-Redis了，基础概念这里就不再介绍。默认情况下Scrapy-Redis是发送GET请求获取数据的，对于某些使用POST请求的情况需要重写<code>make_request_from_data</code>函数即可，但奇怪的是居然没在网上搜到简洁明了的答案，或许是太简单了？</p><p>这里我以<code>httpbin.org</code>这个网站为例，首先在<code>settings.py</code>中添加所需配置，这里需要根据实际情况进行修改：<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SCHEDULER = <span class="string">"scrapy_redis.scheduler.Scheduler"</span>  <span class="comment">#启用Redis调度存储请求队列</span></span><br><span class="line">SCHEDULER_PERSIST = <span class="literal">True</span>    <span class="comment">#不清除Redis队列、这样可以暂停/恢复 爬取</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">"scrapy_redis.dupefilter.RFPDupeFilter"</span>  <span class="comment">#确保所有的爬虫通过Redis去重</span></span><br><span class="line">SCHEDULER_QUEUE_CLASS = <span class="string">'scrapy_redis.queue.SpiderPriorityQueue'</span></span><br><span class="line">REDIS_URL = <span class="string">"redis://127.0.0.1:6379"</span></span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>爬虫代码如下：<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy_redis.spiders <span class="keyword">import</span> RedisSpider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HpbSpider</span><span class="params">(RedisSpider)</span>:</span></span><br><span class="line">    name = <span class="string">'hpb'</span></span><br><span class="line">    redis_key = <span class="string">'test_post_data'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_request_from_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Returns a Request instance from data coming from Redis.</span></span><br><span class="line"><span class="string">        By default, ``data`` is an encoded URL. You can override this method to</span></span><br><span class="line"><span class="string">        provide your own message decoding.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        data : bytes</span></span><br><span class="line"><span class="string">            Message from redis.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> scrapy.FormRequest(<span class="string">"https://www.httpbin.org/post"</span>,</span><br><span class="line">                                  formdata=&#123;<span class="string">"data"</span>:data&#125;,callback=self.parse)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        print(response.body)</span><br></pre></td></tr></table></figure><p></p><p>这里为了简单直接进行输出，真实使用时可以结合pipeline写数据库等。</p><p>然后启动爬虫程序<code>scrapy crawl hpb</code>，由于我们还没向<code>test_post_data</code>中写数据，所以启动后程序进入等待状态。然后模拟向队列写数据：<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">rd = redis.Redis(<span class="string">'127.0.0.1'</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    rd.lpush(<span class="string">'test_post_data'</span>,_)</span><br></pre></td></tr></table></figure><p></p><p>此时可以看到爬虫已经开始获取程序了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2019-05-06 16:30:21 [hpb] DEBUG: Read 8 requests from &apos;test_post_data&apos;</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">2019-05-06 16:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;POST https://www.httpbin.org/post&gt; (referer: None)</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;0&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;1&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;3&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;2&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;4&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;5&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;6&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">b&apos;&#123;\n  &quot;args&quot;: &#123;&#125;, \n  &quot;data&quot;: &quot;&quot;, \n  &quot;files&quot;: &#123;&#125;, \n  &quot;form&quot;: &#123;\n    &quot;data&quot;: &quot;7&quot;\n  &#125;, \n  &quot;headers&quot;: &#123;\n    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, \n    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, \n    &quot;Accept-Language&quot;: &quot;en&quot;, \n    &quot;Content-Length&quot;: &quot;6&quot;, \n    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, \n    &quot;Host&quot;: &quot;www.httpbin.org&quot;, \n    &quot;User-Agent&quot;: &quot;Scrapy/1.5.1 (+https://scrapy.org)&quot;\n  &#125;, \n  &quot;json&quot;: null, \n  &quot;origin&quot;: &quot;1.2.3.48, 1.2.3.48&quot;, \n  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;\n&#125;\n&apos;</span><br><span class="line">2019-05-06 16:31:09 [scrapy.extensions.logstats] INFO: Crawled 1001 pages (at 280 pages/min), scraped 0 items (at 0 items/min)</span><br><span class="line">2019-05-06 16:32:09 [scrapy.extensions.logstats] INFO: Crawled 1001 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br><span class="line">2019-05-06 16:33:09 [scrapy.extensions.logstats] INFO: Crawled 1001 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br></pre></td></tr></table></figure><p></p><p>至于数据重复的问题，如果POST的数据重复，这个请求就不会发送出去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能看到这篇文章的小伙伴肯定已经知道什么是Scrapy以及Scrapy-Redis了，基础概念这里就不再介绍。默认情况下Scrapy-Redis是发送GET请求获取数据的，对于某些使用POST请求的情况需要重写&lt;code&gt;make_request_from_data&lt;/code&gt;函数即可，但奇怪的是居然没在网上搜到简洁明了的答案，或许是太简单了？&lt;/p&gt;&lt;p&gt;这里我以&lt;code&gt;httpbin.org&lt;/code&gt;这个网站为例，首先在&lt;code&gt;settings.py&lt;/code&gt;中添加所需配置，这里需要根据实际情况进行修改：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SCHEDULER = &lt;span class=&quot;string&quot;&gt;&quot;scrapy_redis.scheduler.Scheduler&quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#启用Redis调度存储请求队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SCHEDULER_PERSIST = &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#不清除Redis队列、这样可以暂停/恢复 爬取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DUPEFILTER_CLASS = &lt;span class=&quot;string&quot;&gt;&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#确保所有的爬虫通过Redis去重&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SCHEDULER_QUEUE_CLASS = &lt;span class=&quot;string&quot;&gt;&#39;scrapy_redis.queue.SpiderPriorityQueue&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;REDIS_URL = &lt;span class=&quot;string&quot;&gt;&quot;redis://127.0.0.1:6379&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
    
      <category term="python" scheme="http://www.hi-roy.com/source/all-tags/python/"/>
    
  </entry>
  
  <entry>
    <title>提升keras准确率和速度的小tips</title>
    <link href="http://www.hi-roy.com/2019/03/14/%E6%8F%90%E5%8D%87keras%E5%87%86%E7%A1%AE%E7%8E%87%E5%92%8C%E9%80%9F%E5%BA%A6%E7%9A%84tips/"/>
    <id>http://www.hi-roy.com/2019/03/14/提升keras准确率和速度的tips/</id>
    <published>2019-03-14T09:27:14.000Z</published>
    <updated>2019-09-16T08:11:51.526Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下对于新手(对,说的就是本人)学习kears框架时用来提升准确率的一些tip,但这里都是”术”的层面,而对于”道”,还是要看数学.全文以深度学习界的”hello world”-<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">手写数字识别</a>为例.</p><a id="more"></a><p>首先载入所需要的库:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers.core <span class="keyword">import</span> Dense,Dropout,Activation</span><br></pre></td></tr></table></figure><p></p><p>然后编写函数加载数据:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">  (x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line">  number = <span class="number">10000</span></span><br><span class="line">  x_train = x_train[:number] <span class="comment"># 完整训练数据有6w,这里取前1w</span></span><br><span class="line">  y_train = y_train[:number]  </span><br><span class="line">  x_train = x_train.reshape(number,<span class="number">28</span>*<span class="number">28</span>) <span class="comment"># 原始数据是3维,这里变成2维</span></span><br><span class="line">  x_test=x_test.reshape(x_test.shape[<span class="number">0</span>],<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">  x_train = x_train.astype(<span class="string">'float32'</span>)</span><br><span class="line">  x_test = x_test.astype(<span class="string">'float32'</span>)</span><br><span class="line">  y_train = np_utils.to_categorical(y_train,<span class="number">10</span>) <span class="comment"># 原始数据是1,2...9这样的数字,to_categorical将其变成向量,对应的数字位置为1,其余为0</span></span><br><span class="line">  y_test = np_utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line">  x_train = x_train / <span class="number">255</span></span><br><span class="line">  x_test = x_test / <span class="number">255</span></span><br><span class="line">  <span class="keyword">return</span> (x_train,y_train),(x_test,y_test)</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test) = load_data()</span><br></pre></td></tr></table></figure><p></p><h2 id="选择合适的loss函数"><a href="#选择合适的loss函数" class="headerlink" title="选择合适的loss函数"></a>选择合适的loss函数</h2><p>对于loss函数,如果之前有学过经典机器学习的小伙伴一定最熟悉MSE(均方误差),所以先用这个实现一个版本:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'mse'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p></p><p>这里activation函数使用<code>sigmoid</code>,optimizer使用SGD(随机梯度下降),loss选择MSE,2个隐藏层,隐藏层节点数量689,程序输出如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.12860000133514404</span><br><span class="line">Test Accc: 0.1362999975681305</span><br></pre></td></tr></table></figure><p></p><p>这里可以看出,基本凉凉.不论是在测试集还是训练集准确度都很低.但是,如果把loss函数换成<code>categorical_crossentropy</code>,输出就变成:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.8550000190734863</span><br><span class="line">Test Accc: 0.8374000191688538</span><br></pre></td></tr></table></figure><p></p><p>很明显的提升,这也说明,MSE对于分类问题不是很有好.</p><h2 id="合适的隐藏层数量"><a href="#合适的隐藏层数量" class="headerlink" title="合适的隐藏层数量"></a>合适的隐藏层数量</h2><p>对于初学者有种幻想,层数越多精度就会越高.这里增加一下层数试试:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.09910000115633011</span><br><span class="line">Test Accc: 0.10320000350475311</span><br></pre></td></tr></table></figure><p></p><p>WTF?!准确度反而降低了??这里其实和<code>sigmoid</code>这个函数有关,这个函数会导致vanish gradient problem.简言之就是使用这个函数进行训练时层数越多,每次参数变化引起结果变化的程度就越小,因为<code>sigmoid</code>函数会把不论大小的输入都转化到0-1这个区间中,具体看其<a href="https://baike.baidu.com/item/Sigmoid%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">函数图像</a>就可以明白了.</p><h2 id="合适的激活函数"><a href="#合适的激活函数" class="headerlink" title="合适的激活函数"></a>合适的激活函数</h2><p><code>sigmoid</code>函数其实比较少用了,现在更常用的是<code>relu</code><a href="https://baike.baidu.com/item/ReLU%20%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">函数</a>,可以避免vanish gradient problem.此外,<code>relu</code>其实是<code>Maxout</code>的一个特例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>结果如下,可以看到增加10层使用<code>relu</code>函数不受影响.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9959999918937683</span><br><span class="line">Test Accc: 0.9541000127792358</span><br></pre></td></tr></table></figure><p></p><h2 id="合适的batch-size"><a href="#合适的batch-size" class="headerlink" title="合适的batch_size"></a>合适的batch_size</h2><p>batch_size影响每次训练使用的数据量,比如极端情况下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">10000</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这里把batch_size的值改成和整个训练集一样大,结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.2732999920845032</span><br><span class="line">Test Accc: 0.26249998807907104</span><br></pre></td></tr></table></figure><p></p><p>又凉凉了,所以 <strong>batch_size</strong> 过大速度快,但会影响精度.而过小则速度会慢,特别是使用GPU的时候,如果这个值设定的过小不能完全发挥GPU的加速功能.</p><h2 id="合适的optimizer"><a href="#合适的optimizer" class="headerlink" title="合适的optimizer"></a>合适的optimizer</h2><p>目前最常用的优化函数是<code>adam</code>,<code>adam=RMSProp+Momentum</code>,这里替换掉SGD:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>)) <span class="comment"># 来个10层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出如下,精度差不多但是训练的速度提升了很多:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9906999754905701</span><br><span class="line">Test Accc: 0.9217000007629395</span><br></pre></td></tr></table></figure><p></p><h2 id="Dropout层"><a href="#Dropout层" class="headerlink" title="Dropout层"></a>Dropout层</h2><p>当训练样本过少时候,往往会出现过拟合的现象,这时可以使用Dropout层来”限制学习能力”.这个方法原理是在每次更新参数之前根据概率丢掉某些neuron,使整个网络结构发生了改变,在每一个mini-batch上重复这个行为,得到不同的结果,相当于训练出了很多个不同的网络,然后再把结果平均得到最终结果(ensemble的理念).这个方法会降低在训练集上的精准度.</p><p>为了模拟过拟合,我们在处理数据集时候添加噪声:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">  (x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line">  number = <span class="number">10000</span></span><br><span class="line">  x_train = x_train[:number] <span class="comment"># 完整训练数据有6w,这里取前1w</span></span><br><span class="line">  y_train = y_train[:number]  </span><br><span class="line">  x_train = x_train.reshape(number,<span class="number">28</span>*<span class="number">28</span>) <span class="comment"># 原始数据是3维,这里变成2维</span></span><br><span class="line">  x_test=x_test.reshape(x_test.shape[<span class="number">0</span>],<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">  x_train = x_train.astype(<span class="string">'float32'</span>)</span><br><span class="line">  x_test = x_test.astype(<span class="string">'float32'</span>)</span><br><span class="line">  y_train = np_utils.to_categorical(y_train,<span class="number">10</span>) <span class="comment"># 原始数据是1,2...9这样的数字,to_categorical将其变成向量,对应的数字位置为1,其余为0</span></span><br><span class="line">  y_test = np_utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line">  x_train = x_train / <span class="number">255</span></span><br><span class="line">  x_test = x_test / <span class="number">255</span></span><br><span class="line">  x_test=np.random.normal(x_test) <span class="comment"># 加噪声</span></span><br><span class="line">  <span class="keyword">return</span> (x_train,y_train),(x_test,y_test)</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test) = load_data()</span><br></pre></td></tr></table></figure><p>然后经过2层<code>relu</code>+<code>adam</code>+<code>categorical_crossentropy</code>+<code>batch_size=100</code>结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9894000291824341</span><br><span class="line">Test Accc:  0.5034999847412109</span><br></pre></td></tr></table></figure><p></p><p>可以看到训练集精度很高而测试集准确度一般,添加Dropout层:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.7</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.7</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.7</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment"># 输出层10个节点</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">train_result = model.evaluate(x_train,y_train,batch_size=<span class="number">10000</span>)</span><br><span class="line">test_result = model.evaluate(x_test,y_test,batch_size=<span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'Train Accc:'</span>,train_result[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">'Test Accc:'</span>,test_result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>其中Dropout层添加到每个隐藏层之间,常用的概率值是0.5左右,结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.9824030212854031</span><br><span class="line">Test Accc: 0.6224999713897705</span><br></pre></td></tr></table></figure><p></p><p>可以看到测试集精度提升了一些.当然,除了Dropout之外可以<a href="https://keras.io/getting-started/faq/#how-can-i-interrupt-training-when-the-validation-loss-isnt-decreasing-anymore" target="_blank" rel="noopener">Early Stopping</a>和Regularization(正则化,简单说就是使用某种方法使结果越来越接近0,Weight Decay,但这个帮助并不显著.)</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程!"></a>特征工程!</h2><p>在上面的测试准确率可以达到90%以上,但细心的小伙伴应该发现了,在加载数据时候有这样2行代码:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_train = x_train / <span class="number">255</span></span><br><span class="line">x_test = x_test / <span class="number">255</span></span><br></pre></td></tr></table></figure><p>这两行代码就是对原始数据进行了缩放,将原始值在0-255之间的数据转化到0-1这个区间.如果没有这个处理,那么依然使用2层<code>relu</code>+<code>adam</code>+<code>categorical_crossentropy</code>+<code>batch_size=100</code>结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accc: 0.10010000318288803</span><br><span class="line">Test Accc: 0.09799999743700027</span><br></pre></td></tr></table></figure><p>准确度居然降到和<code>sigmoid</code>+<code>SGD</code>+<code>mse</code>差不多的程度.所以,如果当程序在训练集上的准确度都很低的话,除了调整参数还需要进一步考虑特征工程是否合理合适了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下对于新手(对,说的就是本人)学习kears框架时用来提升准确率的一些tip,但这里都是”术”的层面,而对于”道”,还是要看数学.全文以深度学习界的”hello world”-&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手写数字识别&lt;/a&gt;为例.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="机器学习" scheme="http://www.hi-roy.com/source/all-categories/Python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://www.hi-roy.com/source/all-tags/python/"/>
    
      <category term="kears" scheme="http://www.hi-roy.com/source/all-tags/kears/"/>
    
  </entry>
  
  <entry>
    <title>如何对Go代码解偶</title>
    <link href="http://www.hi-roy.com/2019/02/11/%E5%A6%82%E4%BD%95%E5%AF%B9Go%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%81%B6/"/>
    <id>http://www.hi-roy.com/2019/02/11/如何对Go代码解偶/</id>
    <published>2019-02-11T03:05:03.000Z</published>
    <updated>2019-09-16T08:11:51.524Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sage42.org/2019/01/30/how-to-fix-tightly-coupled-go-code/" target="_blank" rel="noopener">原文</a>，文章作者也是《Hands-On Dependency Injection in Go》的作者，向原作者表示感谢。</p><hr><p>你是否曾经由于添加某个新功能却导致另一个功能出问题？修复好这个，另一个又出问题，就好象打地鼠一般。</p><p>你是否曾经花费大量的时间调试Bug，最后却发现问题潜伏在另一个、甚至毫不相关的模块中？</p><p>这些问题都是由于高耦合引起的。</p><p>在这篇文章中，我们来使用解偶的方式来让代码更加易于理解、维护、测试。</p><a id="more"></a><h1 id="什么是耦合？"><a href="#什么是耦合？" class="headerlink" title="什么是耦合？"></a>什么是耦合？</h1><p>在软件开发中，耦合是用来测量2个部分（对象、包、函数）之间相互依赖程度的指标。参考下面的例子：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">DSN            <span class="keyword">string</span></span><br><span class="line">MaxConnections <span class="keyword">int</span></span><br><span class="line">Timeout        time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonLoader <span class="keyword">struct</span> &#123;</span><br><span class="line">Config *Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这2个对象不能离开另一个单独存在(Roy个人理解：虽然可以单独声明Config对象，但单独这个对象是什么也做不了的。)，所以说这2者是高耦合的(tightly coupled)。</p><h1 id="为什么高耦合的代码是个问题？"><a href="#为什么高耦合的代码是个问题？" class="headerlink" title="为什么高耦合的代码是个问题？"></a>为什么高耦合的代码是个问题？</h1><p>高耦合代码会带来很多问题，但最明显的一个就是会导致散弹式修改(shotgun surgery)。散弹式修改是一个术语，用来描述那种修改一个地方的代码导致要修改很多其他地方代码的情况。</p><p>考虑下面的代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserEndpoint</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// get and check inputs</span></span><br><span class="line">ID, err := getRequestedID(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">resp.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load requested data</span></span><br><span class="line">user, err := loadUser(ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// technical error</span></span><br><span class="line">resp.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> user == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// user not found</span></span><br><span class="line">resp.WriteHeader(http.StatusNoContent)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare output</span></span><br><span class="line"><span class="keyword">switch</span> req.Header.Get(<span class="string">"Accept"</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"text/csv"</span>:</span><br><span class="line">outputAsCSV(resp, user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"application/xml"</span>:</span><br><span class="line">outputAsXML(resp, user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"application/json"</span>:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">outputAsJSON(resp, user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在假设我们要在User对象中添加一个Password字段，但我们不想让这个字段出现在API返回数据中，我们不得不同时修改<code>outputAsCSV()</code>， <code>outputAsXML()</code>和<code>outputAsJSON()</code>这3个函数。</p><p>这看上去似乎没什么问题，但试想如果我们还有其他的接口(endpoint)也将User作为输出的一部分，比如”GetAllUsers”，我们不得不做同样的工作。这一切都是由于”GetUser”接口和User类型输出的形式是高耦合的。</p><p>换言之，我们把渲染逻辑从”GetUserHandler”接口转移到User类型中，这样我们修改一个地方就可以了。更重要的是，如果我们需要添加新的字段，User类显然更加明显和容易找到，这样也提高了整体代码的可维护性。</p><p>在我们深入讨论如何解偶之前，我们还需要讨论一下依赖倒置原则(Dependency Inversion Principle)。</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则(DIP)由Robert C. Martin在1996年在 <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener">Dependency Inversion Principle</a>中提出，他对此定义如下:</p><blockquote><p>顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。<br>High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions<br>Robert C. Martin</p></blockquote><p>(Roy注：为了统一下面把modules、packages都翻译成模块。)</p><p>正如Robert所言，大智慧往往浓缩成非常精炼的句子。下面是我的理解并且翻译成Go代码：</p><p>1) <strong>顶层模块不应该依赖底层模块</strong> - 当我们编写Go程序时，一些包被<code>main()</code>函数调用，这些可以认为是顶层模块。相反的，一些和外部资源交互的模块，比如数据库，典型的不由<code>main()</code>调用而是由逻辑层调用，这就要低1-2级。</p><p>顶层模块应该依赖于抽象而不是这些实现细节的模块，这有助于解偶。</p><p>2) <strong>结构体不应该依赖于结构体</strong> - 当一个结构体接受另一个结构体作为方法参数或成员变量时:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PizzaMaker <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PizzaMaker)</span> <span class="title">MakePizza</span><span class="params">(oven *SuperPizaOven5000)</span></span> &#123;</span><br><span class="line">pizza := p.buildPizza()</span><br><span class="line">oven.Bake(pizza)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样的代码耦合度很高导致及其不灵活，让我们考虑一个实际情况：我走进一家旅行社并说:”我想购买一张澳洲航空在星期四3点30分飞往悉尼的15D座位机票。”这种说法旅行社是很难满足我的要求的。</p><p>但如果我放松要求，就好像我们将输入的参数由结构体类型改成接口类型一般:”我想购买一张星期四飞往悉尼的机票。”这样旅行社可以更加灵活处理我的请求，也就更可能买到机票。</p><p>修改代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PizzaMaker <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PizzaMaker)</span> <span class="title">MakePizza</span><span class="params">(oven Oven)</span></span> &#123;</span><br><span class="line">pizza := p.buildPizza()</span><br><span class="line">oven.Bake(pizza)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Oven <span class="keyword">interface</span> &#123;</span><br><span class="line">Bake(pizza Pizza)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用任何类型来实现<code>Bake()</code>方法。</p><p>3) <strong>接口不应该依赖结构体</strong> - 和前文类似，根据特定的情况，我们定义接口：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">DSN            <span class="keyword">string</span></span><br><span class="line">MaxConnections <span class="keyword">int</span></span><br><span class="line">Timeout        time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonLoader <span class="keyword">interface</span> &#123;</span><br><span class="line">Load(cfg *Config, ID <span class="keyword">int</span>) *Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们将<code>PersonLoader</code>和<code>Config</code>这个特定的额结构体绑定到了一起，也就是说想在其他项目中复用<code>PersonLoader</code>将需要修改代码，而这些修改可能导致Bug。换句话说，如果我们像下面这样定义<code>PersonLoader</code>：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonLoaderConfig <span class="keyword">interface</span> &#123;</span><br><span class="line">DSN() <span class="keyword">string</span></span><br><span class="line">MaxConnections() <span class="keyword">int</span></span><br><span class="line">Timeout() time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonLoader <span class="keyword">interface</span> &#123;</span><br><span class="line">Load(cfg PersonLoaderConfig, ID <span class="keyword">int</span>) *Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样我们就可以在其他地方复用<code>PersonLoader</code>了。</p><p>上面的结构体应该用作提供逻辑实现接口而不是用作传递数据。（原文’Structs above should be taken to mean structs that provide logic and/or implement interfaces and does not include structs that are used as Data Transfer Objects’，翻译的有点别扭。）</p><h1 id="解偶"><a href="#解偶" class="headerlink" title="解偶"></a>解偶</h1><p>了解背景后，我们来深入了解一下如何解偶。这个例子中我们有2个对象，<code>Person</code>和<code>BlueShoes</code>分别在2个不同的包中：</p><p><img src="https://i0.wp.com/www.sage42.org/wp-content/uploads/2019/01/step1.png?w=579&amp;ssl=1" alt="img1"></p><p>正如图中所示，它们是高耦合的，<code>Person</code>没法离开<code>BlueShoes</code>单独存在。</p><p>如果你之前使用Java/C++，本能的解偶方法是在<code>shoes</code>包中定义一个接口：<br><img src="https://i1.wp.com/www.sage42.org/wp-content/uploads/2019/01/step2.png?w=609&amp;ssl=1" alt="img2"></p><p>在大多数语言中到此为止了，然而在Go中，我们可以更进一步。</p><p>在我们这么做之前，需要注意一个问题。</p><p>你也许注意到了，<code>Person</code>结构只实现了一个<code>Walk()</code>方法，而在<code>Footwear</code>中实现了<code>Walk()</code>和<code>Run()</code>。这种差异导致了<code>Person</code>和 <code>Footwear</code>之间的关系有些不明确并且违反了Robert C. Martin提出的另一个原则: <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank" rel="noopener">接口隔离原则(Interface Segregation Principle ,ISP)</a>。</p><blockquote><p>使用者不应该被强迫依赖那些它们不使用的方法。<br>Clients should not be forced to depend on methods they do not use.<br>Robert C. Martin</p></blockquote><p>幸运的是，我们可以同过在<code>people</code>包中而非<code>shoes</code>包中定义接口来解决这些问题：</p><p><img src="https://i2.wp.com/www.sage42.org/wp-content/uploads/2019/01/step3-1.png?w=582&amp;ssl=1" alt="img3"></p><p>这也许看起来是个小事，不值得为此花费时间，但实际上这是意义深远的。在上面这个例子中2个包完全解偶了，<code>people</code>再也不需要依赖或使用<code>shoes</code>包了。</p><p>通过这种改变，<code>people</code>包更加简洁明了易于发现，而且以后修改<code>shoes</code>包不会影响到<code>people</code>包。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>正如我在《Hands-On Dependency Injection in Go》中写的，Go语言中一个流行的概念和<a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="noopener">Unix哲学</a>相似：</p><blockquote><p>Write programs that do one thing and do it well. Write programs to work together</p></blockquote><p>(这句就不翻译了，翻译的没意境。)</p><p>这个概念充满在Go标准库中，甚至影响到了Go语言的设计。像隐式实现接口（即没有“implements”关键字）使我们（该语言的用户）能够实现解耦代码，这些代码可以用于单一目标并且易于编写。</p><p>低耦合的代码更易于理解，因为你需要的所有信息都在一个地方，反过来说使代码更容易测试和扩展。</p><p>所以下次你看到一个具体的对象作为函数参数或者成员变量，问问自己”这真的必要吗？”，”如果把这个改成接口类型，会不会更加灵活、易于理解和维护？”</p><p>Happy Coding!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.sage42.org/2019/01/30/how-to-fix-tightly-coupled-go-code/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，文章作者也是《Hands-On Dependency Injection in Go》的作者，向原作者表示感谢。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;你是否曾经由于添加某个新功能却导致另一个功能出问题？修复好这个，另一个又出问题，就好象打地鼠一般。&lt;/p&gt;&lt;p&gt;你是否曾经花费大量的时间调试Bug，最后却发现问题潜伏在另一个、甚至毫不相关的模块中？&lt;/p&gt;&lt;p&gt;这些问题都是由于高耦合引起的。&lt;/p&gt;&lt;p&gt;在这篇文章中，我们来使用解偶的方式来让代码更加易于理解、维护、测试。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go get命令使用socket代理</title>
    <link href="http://www.hi-roy.com/2018/10/12/go-get%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8socket%E4%BB%A3%E7%90%86/"/>
    <id>http://www.hi-roy.com/2018/10/12/go-get命令使用socket代理/</id>
    <published>2018-10-12T05:57:35.000Z</published>
    <updated>2019-09-16T08:11:51.490Z</updated>
    
    <content type="html"><![CDATA[<p>由于某些不可描述的原因，国内使用<code>go get</code>命令安装某些包的时候会超时导致失败，比如<code>net</code>包、<code>sys</code>包、<code>tools</code>包等。第一种解决办法就是自己从git上下载后添加链接到<code>GOPATH</code>中，比如：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/golang/net.git <span class="variable">$GOPATH</span>/src/github.com/golang/net</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/sys.git <span class="variable">$GOPATH</span>/src/github.com/golang/sys</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git <span class="variable">$GOPATH</span>/src/github.com/golang/tools</span><br><span class="line"></span><br><span class="line">ln -s <span class="variable">$GOPATH</span>/src/github.com/golang <span class="variable">$GOPATH</span>/src/golang.org/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/  &amp;&amp; mv golang x</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>另外就是使用代理，网上大多是使用http代理，这里记录下如何使用socket代理。<code>go get</code>命令其实也是利用了<code>git</code>命令进行下载，不过下载后会自动编译安装，所以首先设置git的代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:7070</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=socks5://127.0.0.1:7070 go get xxxx</span><br></pre></td></tr></table></figure><p>就可以了。</p><p>恢复的话可以重置git配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于某些不可描述的原因，国内使用&lt;code&gt;go get&lt;/code&gt;命令安装某些包的时候会超时导致失败，比如&lt;code&gt;net&lt;/code&gt;包、&lt;code&gt;sys&lt;/code&gt;包、&lt;code&gt;tools&lt;/code&gt;包等。第一种解决办法就是自己从git上下载后添加链接到&lt;code&gt;GOPATH&lt;/code&gt;中，比如：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/golang/net.git &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang/net&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/golang/sys.git &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang/sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/golang/tools.git &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang/tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ln -s &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/golang &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/golang.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/golang.org/  &amp;amp;&amp;amp; mv golang x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>IPFS初窥3</title>
    <link href="http://www.hi-roy.com/2018/10/10/IPFS%E5%88%9D%E7%AA%A53/"/>
    <id>http://www.hi-roy.com/2018/10/10/IPFS初窥3/</id>
    <published>2018-10-10T07:26:16.000Z</published>
    <updated>2019-09-16T08:11:51.460Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><p>在<a href="http://www.hi-roy.com/2018/09/19/IPFS%E5%88%9D%E7%AA%A52/">上一篇文章</a>中记录到了IPFS的<code>BitSwap</code>协议，今天接着往下看关于<code>Object</code>的部分。</p><h2 id="Merkle-DAG"><a href="#Merkle-DAG" class="headerlink" title="Merkle DAG"></a>Merkle DAG</h2><p>Merkle DAG是IPFS核心概念之一，在Git的数据结构上进行了改造。理解Merkle DAG之前先来了解下<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener">Merkle Tree</a>。</p><a id="more"></a><p>简单说，Merkle Tree是一种特殊的树结构，其叶子节点的值为包含记录的哈希值，而非叶子节点的值为子节点哈希值合并后的哈希结果，一图胜千言：</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/ipfs3-1.png" alt="ipfs3-1"></p><p>Merkle Tree最常见的一个应用就是数据验证领域了，这种数据结构可以大量减少验证所需传输的数据量，在<code>Top Hash</code>已知的情况下想验证L3中的数据是否被篡改过，只需要向一个可信任的中心请求获取<code>Hash0</code>和<code>Hash1-1</code>即可。</p><p>正由于比特币中将Merkle Tree的根哈希值包含在了区块头中，所以各种轻钱包(SPV)才得以出现。</p><p><img src="https://mypic-1252424367.cos.ap-hongkong.myqcloud.com/ipfs3-2.png" alt="ipfs3-2"></p><p>而Merkle DAG则是一种　<strong>有向无环图</strong>　结构，而且和Merkle Tree有个很重要的区别就是Merkle DAG中准许非叶节点存储数据。IPFS中数据结构定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IPFSLink <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Hash Multihash</span><br><span class="line">  Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPFSObject <span class="keyword">struct</span>&#123;</span><br><span class="line">  links []IPFSLink</span><br><span class="line">  data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先我们有这样一个目录结构：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipfs</span><br><span class="line">├── imgs</span><br><span class="line">│   └── 1.jpg</span><br><span class="line">├── test.txt</span><br><span class="line">└── video</span><br><span class="line">    └── paxos和分布式系统.mp4</span><br></pre></td></tr></table></figure><p></p><p>然后执行<code>add</code>命令添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipfs add -r ipfs</span><br><span class="line">added QmTBGNDfodpscKje46wyTmzsPsJ6REWebionWK9dVc2Cms ipfs/imgs/1.jpg</span><br><span class="line">added QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ ipfs/test.txt</span><br><span class="line">added Qme5oV4uKLA2BDVjFtqiCfFqv74LZXTqG1oiuu5gshqvk7 ipfs/video/paxos和分布式系统.mp4</span><br><span class="line">added QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK ipfs/imgs</span><br><span class="line">added QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb ipfs/video</span><br><span class="line">added QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4 ipfs</span><br><span class="line"> 53.15 MiB / 53.16 MiB [=============================================================================================================================================================]  99.98%</span><br></pre></td></tr></table></figure><p>这里插一句，在浏览器中访问<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/ipfs/QmTBGNDfodpscKje46wyTmzsPsJ6REWebionWK9dVc2Cms</span><br><span class="line"></span><br><span class="line">http://localhost:8080/ipfs/QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK/1.jpg</span><br><span class="line"></span><br><span class="line">http://localhost:8080/ipfs/QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4/imgs/1.jpg</span><br></pre></td></tr></table></figure><p></p><p>这3种访问路径都可以最终得到<code>1.jpg</code>这个图片。</p><p>可以使用<code>ls</code>命令查看文件切分情况：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipfs ls -v Qme5oV4uKLA2BDVjFtqiCfFqv74LZXTqG1oiuu5gshqvk7</span><br><span class="line">Hash                                           Size     Name</span><br><span class="line">QmexC2a5eSkVuoErKhAjxpMt6DJoQeS57T3yU1cxCpb3Tu 45623854</span><br><span class="line">QmR2GQi1DhvGzZ1Ra1fgpwKBTd9ubt9aPUSCvqMZPHB3cp 10103195</span><br></pre></td></tr></table></figure><p></p><p>可以看出，mp4文件被切分成了2部分。</p><p>再使用<code>object get</code>命令查看<code>ipfs</code>这个文件夹的DAG:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ipfs object get QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;Links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;imgs&quot;,</span><br><span class="line">      &quot;Hash&quot;: &quot;QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK&quot;,</span><br><span class="line">      &quot;Size&quot;: 18418</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;test.txt&quot;,</span><br><span class="line">      &quot;Hash&quot;: &quot;QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ&quot;,</span><br><span class="line">      &quot;Size&quot;: 18</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;video&quot;,</span><br><span class="line">      &quot;Hash&quot;: &quot;QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb&quot;,</span><br><span class="line">      &quot;Size&quot;: 55727234</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;Data&quot;: &quot;\u0008\u0001&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>也和上面给的数据结构定义一致。</p><p>还有更重要的一点，IPFS准许使用者使用<code>block</code>相关命令直接操作Merkle DAG中的数据，比如：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hi roy"</span> | ipfs block put</span><br><span class="line">QmUHW9uK8aKYHNSSJwS1AnnBt1dV6wbKmDWDr8tmRk9pXo</span><br><span class="line"></span><br><span class="line">ipfs block get QmUHW9uK8aKYHNSSJwS1AnnBt1dV6wbKmDWDr8tmRk9pXo</span><br><span class="line"></span><br><span class="line">hi roy</span><br></pre></td></tr></table></figure><p></p><p>有这个功能可玩性就很高了，白皮书中给出了几种结构：</p><ul><li>键值对存储（key-value stores）</li><li>关系型数据库（traditional relatioinal databases）</li><li>三元组存储（Linked Data triple stores）</li><li>文档发布系统（Linked document publishing systems）</li><li>通信平台（Linked communications platforms）</li><li>加密货币区块链（cryptocurrency blockchains）</li></ul><p>再插一句，很多小伙伴不知道如何向已经存在的文件夹中添加新文件，比如想向<code>ipfs</code>目录添加文件<code>test2.txt</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ipfs add test2.txt</span><br><span class="line">added QmUARAWmSHC3aiWhYFcGfQGEyfAKdUPWqFHxemY3iDJDRM test2.txt</span><br><span class="line"> 11 B / 11 B [=======================================================================================================================================================================] 100.00%</span><br><span class="line"></span><br><span class="line"> ipfs ls -v QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4</span><br><span class="line">Hash                                           Size     Name</span><br><span class="line">QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK 18418    imgs/</span><br><span class="line">QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ 18       test.txt</span><br><span class="line">QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb 55727234 video/</span><br></pre></td></tr></table></figure><p></p><p>可以发现文件并没有添加进文件夹中，而仅仅是获得了一个自己的哈希值。可以使用下面的命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipfs object patch add-link QmPkbxXPM2hY97NR8Tf25KZxysWn4FZrsuPwD8ztYM32j4 test21.txt QmUARAWmSHC3aiWhYFcGfQGEyfAKdUPWqFHxemY3iDJDRM</span><br><span class="line"></span><br><span class="line">QmZzY6fgW2ndjoAXpa2gMSaJ3c8h6hzq1TFusdF33u2jvy</span><br></pre></td></tr></table></figure><p></p><p>这里会返回一个新的哈希值，查看这个发现文件已经被添加进去了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipfs ls -v QmZzY6fgW2ndjoAXpa2gMSaJ3c8h6hzq1TFusdF33u2jvy</span><br><span class="line">Hash                                           Size     Name</span><br><span class="line">QmQEwN1jbjPPAnfjnbXjCi92yKu7gZbZnmK2niotz4d8oK 18418    imgs/</span><br><span class="line">QmRmfJ8RYrULTZkjt9H11kkPBswrzVQXf36QAF3XoBG6XZ 18       test.txt</span><br><span class="line">QmUARAWmSHC3aiWhYFcGfQGEyfAKdUPWqFHxemY3iDJDRM 19       test21.txt</span><br><span class="line">QmVYaDuyoS4otNXnQ7WRbBP4ZZuLi7PLhyz2LV9vLWVwWb 55727234 video/</span><br></pre></td></tr></table></figure><p></p><p>注意存储后的文件名是<code>ipfs object patch add-link</code>中指定的值，而不是原文件名。再多说一句，这个命令需要的参数仅仅是哈希值，换言之如果你知道其他人的link地址也可以加到自己的文件下。</p><p>另外，最新的文件系统已经变成IPLD了，是Merkle DAG的一个变种。</p><h2 id="IPNS"><a href="#IPNS" class="headerlink" title="IPNS"></a>IPNS</h2><p>由上面的例子也可以看出来，在IPFS中每次新增、修改某个文件都会导致哈希值的变化，这对于实际应用中是十分不便的。为了处理这个问题，IPFS中引入了一个可变命名空间的概念——IPNS(InterPlanetary Name Space)，结合之前说的 <strong>路由系统</strong> 实现了”不可变的内容”和”可变的引用”的组合(可以结合编程语言中指针的概念)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routing.setValue(NodeId,&lt;ns-object-hash&gt;)</span><br></pre></td></tr></table></figure><p>之前说过每个节点的NodeID来源与其公钥的哈希值，那么给每个节点分配一个可变命名空间<code>/ipns/&lt;NodeID&gt;</code>，用户将私钥签名过的数据发布到这个路径上，别的用户下载这个数据时可以检查签名是否和公钥、NodeID匹配来验证真实性。</p>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;&lt;p&gt;在&lt;a href=&quot;http://www.hi-roy.com/2018/09/19/IPFS%E5%88%9D%E7%AA%A52/&quot;&gt;上一篇文章&lt;/a&gt;中记录到了IPFS的&lt;code&gt;BitSwap&lt;/code&gt;协议，今天接着往下看关于&lt;code&gt;Object&lt;/code&gt;的部分。&lt;/p&gt;&lt;h2 id=&quot;Merkle-DAG&quot;&gt;&lt;a href=&quot;#Merkle-DAG&quot; class=&quot;headerlink&quot; title=&quot;Merkle DAG&quot;&gt;&lt;/a&gt;Merkle DAG&lt;/h2&gt;&lt;p&gt;Merkle DAG是IPFS核心概念之一，在Git的数据结构上进行了改造。理解Merkle DAG之前先来了解下&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Merkle Tree&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPFS初窥2</title>
    <link href="http://www.hi-roy.com/2018/09/19/IPFS%E5%88%9D%E7%AA%A52/"/>
    <id>http://www.hi-roy.com/2018/09/19/IPFS初窥2/</id>
    <published>2018-09-19T02:52:06.000Z</published>
    <updated>2019-09-16T08:11:51.460Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><p>在<a href="http://www.hi-roy.com/2018/09/04/IPFS%E5%88%9D%E7%AA%A5/">上一篇文章</a>中初步介绍了IPFS的基本概念和使用方法，今天更深入一些了解IPFS的设计理念。</p><p>根据 <strong>第三版</strong> 白皮书，IPFS体系可以分为7层：</p><ol><li>身份：负责节点的身份生成和认证。</li><li>网络：负责节点间的网络连接，可以配置使用各种网络协议。</li><li>路由：维护路由信息来找出特定的节点和对象。默认使用DHT，可以替换。</li><li>交换：一个新型的块交换协议(BitSwap)来高效管理块分发。有点类似超市，对数据复制有激励。交易策略可以替换。</li><li>对象：带有链接的、内容寻址的不可变对象组成的Merkle DAG，可以代表任意数据结构。比如文件层级和通信系统。</li><li>文件：受到Git启发的版本控制文件层级系统。</li><li>命名：自验证的可变命名系统。</li></ol><a id="more"></a><h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><p>节点间通过<code>NodeID</code>来识别彼此之间的身份，而<code>NodeID</code>是根据公钥和<code>S/Kademlia</code>静态加密算法生成的，一个节点可以生成多个<code>NodeID</code>，但这种行为将失去某些“好处”，至于什么好处在BitSwap时候细说。</p><p>文中还给了生成<code>NodeID</code>的伪代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">difficulty = &lt;integet parameter&gt;</span><br><span class="line">n = Node&#123;&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">  n.PubKey,n.PrivKey = PKI.genKeyPair()</span><br><span class="line">  n.NodeID = hash(n.PubKey)</span><br><span class="line">  p = count_preceding_zero_bits((hash(n.NodeId)))</span><br><span class="line">&#125;while (p &lt; difficulty)</span><br></pre></td></tr></table></figure><p></p><p>代码比较好理解这里就不多解释，当节点间第一次建立链接时候会交换公钥，并且计算哈希值，如果不匹配则终止链接。另外IPFS更倾向于使用能自解释的哈希格式，比如使用了哪个哈希函数、摘要长度：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;function code&gt;&lt;digest length&gt;&lt;digest bytes&gt;</span><br></pre></td></tr></table></figure><p></p><p>这样做的好处有2个：</p><ol><li>可以根据实际情况选择合适的函数(安全性Vs高性能)</li><li>可以根据选择函数的不同而演变。自描述的值准许使用兼容的、不同的参数。</li></ol><h2 id="网络和路由"><a href="#网络和路由" class="headerlink" title="网络和路由"></a>网络和路由</h2><p>这两个相对好理解就放一起记录了。</p><p>IPFS可以使用任何传输协议，但最适合的是<code>WebRTC DataChannels</code>和<code>uTP</code>，同时基于<code>uTP</code>提供了可靠传输。并且支持<code>ICE NAT</code>穿透技术，还可以选择检查哈希值来保证消息完整性，并通过使用HAMC以及发送方的公钥来保证真实性。</p><p>正是因为可以使用各种传输协议，所以IPFS也可使用<code>覆盖网络(overlay networks)</code>。因此IPFS使用多层地址的格式来存储地址信息。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sctp/ipv4链接</span><br><span class="line"></span><br><span class="line">/ip4/10.20.30.40/sctp/1234/</span><br><span class="line"></span><br><span class="line"># 通过tcp/ipv4代理的sctp/ipv4链接</span><br><span class="line">/ipo/5.6.7.8/tcp/5678/ip4/1.3.4.5/sctp/1234/</span><br></pre></td></tr></table></figure><p>IPFS通过使用路由来寻找其他节点的网络地址和谁可以提供特定的对象。基于DSHT、Coral和S/Kademila。IPFS DHT根据大小来使用不同的存储方式，比如小文件(小于1KB)直接存在DHT中，而大文件则存储那些可以提供数据的节点的引用。</p><p>另外不同的场景可以使用不同的路由系统，比如DHT用于广域网，静态HT用于本地网络。所以根据不同场景路由系统是可以改变的，只要实现了相应的接口。</p><h2 id="块交换——BitSwap协议"><a href="#块交换——BitSwap协议" class="headerlink" title="块交换——BitSwap协议"></a>块交换——BitSwap协议</h2><p>BitSwap协议灵感来源于Bittorrent，使用<code>want_list</code>来记录自己想要什么，<code>have_list</code>来记录自己有什么。和Bittorrent不同的是BitSwap不关注数据块来源于哪个文件。为了解决“吸血节点”问题，IPFS引入了信用机制：</p><ol><li>节点通过账本记录和其他节点之间的收(负债)发(信用)字节长度。</li><li>根据不同的负债率，是否发送数据的概率不同。</li></ol><p>如果一个节点决定不发送数据给请求方，随后则会根据<code>ignore_cooldown</code>时间来忽略接下来这个节点的请求，以便防止DDos攻击。</p><p>负债率的计算公式为：</p><p>$$r=\frac{bytes sent}{bytes recv+1}$$</p><p>分母加1防止出现除以0的异常。已知r后，发送数据的概率P为：</p><p>$$P(send|r)=1-\frac{1}{1+\exp(6-3r)}$$</p><p>这里有个点要注意，节点A的负债(debt)就是节点B的信用(credit)，以<code>go-bitswap</code>中关于账本的代码为例，来源于<code>decision\ledger.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ledger <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Partner is the remote Peer.</span></span><br><span class="line">Partner peer.ID</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accounting tracks bytes sent and received.</span></span><br><span class="line">Accounting debtRatio</span><br><span class="line"></span><br><span class="line"><span class="comment">// lastExchange is the time of the last data exchange.</span></span><br><span class="line">lastExchange time.Time</span><br><span class="line"></span><br><span class="line"><span class="comment">// exchangeCount is the number of exchanges with this peer</span></span><br><span class="line">exchangeCount <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wantList is a (bounded, small) set of keys that Partner desires.</span></span><br><span class="line">wantList *wl.Wantlist</span><br><span class="line"></span><br><span class="line"><span class="comment">// sentToPeer is a set of keys to ensure we dont send duplicate blocks</span></span><br><span class="line"><span class="comment">// to a given peer</span></span><br><span class="line">sentToPeer <span class="keyword">map</span>[<span class="keyword">string</span>]time.Time</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref is the reference count for this ledger, its used to ensure we</span></span><br><span class="line"><span class="comment">// don't drop the reference to this ledger in multi-connection scenarios</span></span><br><span class="line">ref <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">lk sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> debtRatio <span class="keyword">struct</span> &#123;</span><br><span class="line">BytesSent <span class="keyword">uint64</span></span><br><span class="line">BytesRecv <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *debtRatio)</span> <span class="title">Value</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(dr.BytesSent) / <span class="keyword">float64</span>(dr.BytesRecv+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ledger)</span> <span class="title">SentBytes</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">l.exchangeCount++</span><br><span class="line">l.lastExchange = time.Now()</span><br><span class="line">l.Accounting.BytesSent += <span class="keyword">uint64</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ledger)</span> <span class="title">ReceivedBytes</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">l.exchangeCount++</span><br><span class="line">l.lastExchange = time.Now()</span><br><span class="line">l.Accounting.BytesRecv += <span class="keyword">uint64</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子方便理解：假设有A、B两个节点，目前A向B发送了60个字节的数据，从B接收了100字节数据，那么对于B来说则是向A发送100字节数据、接收60字节数据。当A再次向B请求下载数据时，B就会根据自己的账本计算负债率，并决定是否接受这次请求。</p><p>块交换生命周期大体分成4种：</p><ol><li>open：发送账本直到对方同意。</li><li>sending：交换want_list和数据块。</li><li>close：关闭链接。</li><li>ignore：这个只有在策略是避免发送时候才会出现。</li></ol><p>白皮书中说，在open阶段节点A会创建一个新账本或者使用旧账本发送给节点B，而B则在ignore_cooldown超时时间内概率性的决定忽略还是接受这次请求。(原文是:This should be done probabilistically with an ignore_cooldown timeout)。此外，如果决定了接受这次请求，则使用本地账本新建一个peer对象并修改账本的<code>last_seen</code>时间戳，然后比较接收到的账本和对方发来的账本是否一致，一致则建立链接，否则初始化一个空账本并发送。</p><blockquote><p>这里Roy我有个疑惑，在<code>go-ipfs</code>源码中找了很多地方都没找到这个”概率性忽略或接受请求”以及对比账本是否一致部分的代码，甚至上面计算概率的公式都没找到，希望知道这部分代码实现位置的大佬能够指点一下小弟，先谢谢了。</p></blockquote><p>建立链接后就可以开始交换数据了。在<code>go-ipfs</code>中，want_list是一个字典，定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wantlist <span class="keyword">struct</span> &#123;</span><br><span class="line">set <span class="keyword">map</span>[<span class="keyword">string</span>]*Entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">Cid      cid.Cid</span><br><span class="line">Priority <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">SesTrk <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>block则更简洁:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicBlock <span class="keyword">struct</span> &#123;</span><br><span class="line">cid  cid.Cid</span><br><span class="line">data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在IPFS中，文件被分为若干Blocks，Block使用一个叫做<code>CID</code>标识符来索引，这是一个自描述的索引结构体，用来唯一标识一个Block。所以要想从节点下载一个Block，只需在知道<code>CID</code>即可，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cid represents a self-describing content adressed</span></span><br><span class="line"><span class="comment">// identifier. It is formed by a Version, a Codec (which indicates</span></span><br><span class="line"><span class="comment">// a multicodec-packed content type) and a Multihash.</span></span><br><span class="line"><span class="keyword">type</span> Cid <span class="keyword">struct</span>&#123; str <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCidV0 returns a Cid-wrapped multihash.</span></span><br><span class="line"><span class="comment">// They exist to allow IPFS to work with Cids while keeping</span></span><br><span class="line"><span class="comment">// compatibility with the plain-multihash format used used in IPFS.</span></span><br><span class="line"><span class="comment">// NewCidV1 should be used preferentially.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCidV0</span><span class="params">(mhash mh.Multihash)</span> <span class="title">Cid</span></span> &#123;</span><br><span class="line"><span class="comment">// Need to make sure hash is valid for CidV0 otherwise we will</span></span><br><span class="line"><span class="comment">// incorrectly detect it as CidV1 in the Version() method</span></span><br><span class="line">dec, err := mh.Decode(mhash)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dec.Code != mh.SHA2_256 || dec.Length != <span class="number">32</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"invalid hash for cidv0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Cid&#123;<span class="keyword">string</span>(mhash)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCidV1 returns a new Cid using the given multicodec-packed</span></span><br><span class="line"><span class="comment">// content type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCidV1</span><span class="params">(codecType <span class="keyword">uint64</span>, mhash mh.Multihash)</span> <span class="title">Cid</span></span> &#123;</span><br><span class="line">hashlen := <span class="built_in">len</span>(mhash)</span><br><span class="line"><span class="comment">// two 8 bytes (max) numbers plus hash</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>*binary.MaxVarintLen64+hashlen)</span><br><span class="line">n := binary.PutUvarint(buf, <span class="number">1</span>)</span><br><span class="line">n += binary.PutUvarint(buf[n:], codecType)</span><br><span class="line">cn := <span class="built_in">copy</span>(buf[n:], mhash)</span><br><span class="line"><span class="keyword">if</span> cn != hashlen &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"copy hash length is inconsistent"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Cid&#123;<span class="keyword">string</span>(buf[:n+hashlen])&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>ipfs daemon</code>后，可以使用<code>ipfs bitswap stat</code>来查看整体的情况：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % ipfs bitswap stat</span><br><span class="line">bitswap status</span><br><span class="line">provides buffer: 0 / 256</span><br><span class="line">blocks received: 760</span><br><span class="line">blocks sent: 11</span><br><span class="line">data received: 195407444</span><br><span class="line">data sent: 2883738</span><br><span class="line">dup blocks received: 75</span><br><span class="line">dup data received: 18 MB</span><br><span class="line">wantlist [6 keys]</span><br><span class="line">QmeUUfUS4DMsKzMkTda3iunruYMvJEwDfGnF7KBAt2smwJ</span><br><span class="line">QmcQQyNtMy3Z1fekutzjwkZCPHXwVvs4ZqgiboMBbc2H3A</span><br><span class="line">Qmc4XdqSLbyjYGsaZihb1nGhNAWbU8hKmmUNeUjExsLQyi</span><br><span class="line">QmYxE2fXENrJvuzES3Tyive4o1zp9VoNJD5bft4soyv1H2</span><br><span class="line">QmPmLZxuK4hAk9kx6mipvXvUjbtMxTXXnbbahP2VicYLeu</span><br><span class="line">QmRtJugMr7yPPS7Kw5azRQaj3VB774ARSLJfw7gsKM1fzt</span><br><span class="line">partners [936]</span><br><span class="line">QmNMTsUaKTDdunSUN44TZuMPDpGTCLG8R2ooEo1ZmxJadq</span><br><span class="line">QmNPNDYybTYcZK2KBrrn24M4Lc7VcPnGDNX8ueur9TRCmK</span><br><span class="line">QmNQC6nB2LACt1h6nkJdFz1vaFRP5iTHeB1p9nsfpk4nnM</span><br><span class="line">QmNRPRpbgM1WTEUo4T4sadsASmBudPKqYupdtZcSoFkvSL</span><br><span class="line">QmNRSBnfjE6PMZ5AfnLccWpMjX2LtRFYedxQ2UqQxvozfV</span><br><span class="line">QmNRV7kyUxYaQ4KQxFXPYm8EfuzJbtGn1wSFenjXL6LD8y</span><br><span class="line">QmNUCfyL67rqBesyCLon9kRUpXtPEfVUzf7aGp1VXqGqW4</span><br><span class="line">QmNV721hfbzxuLdBvLaBpzmKtnPP4duf59SZ3AU1fV5CrK</span><br></pre></td></tr></table></figure><p></p><p>也可以使用<code>ipfs bitswap ledger NodeID</code>来具体查看和某个节点之间的债务关系。</p><p>本文最后来个彩蛋吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%ipfs get Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t                                                                                                                 </span><br><span class="line">Saving file(s) to Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t</span><br><span class="line">322.39 MiB / 322.39 MiB[====================================================================================================================================================] 100.00% 17m47s</span><br></pre></td></tr></table></figure><p>然后把下载好的文件后缀改成<code>mp4</code>，慢慢欣赏。</p>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;&lt;p&gt;在&lt;a href=&quot;http://www.hi-roy.com/2018/09/04/IPFS%E5%88%9D%E7%AA%A5/&quot;&gt;上一篇文章&lt;/a&gt;中初步介绍了IPFS的基本概念和使用方法，今天更深入一些了解IPFS的设计理念。&lt;/p&gt;&lt;p&gt;根据 &lt;strong&gt;第三版&lt;/strong&gt; 白皮书，IPFS体系可以分为7层：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;身份：负责节点的身份生成和认证。&lt;/li&gt;&lt;li&gt;网络：负责节点间的网络连接，可以配置使用各种网络协议。&lt;/li&gt;&lt;li&gt;路由：维护路由信息来找出特定的节点和对象。默认使用DHT，可以替换。&lt;/li&gt;&lt;li&gt;交换：一个新型的块交换协议(BitSwap)来高效管理块分发。有点类似超市，对数据复制有激励。交易策略可以替换。&lt;/li&gt;&lt;li&gt;对象：带有链接的、内容寻址的不可变对象组成的Merkle DAG，可以代表任意数据结构。比如文件层级和通信系统。&lt;/li&gt;&lt;li&gt;文件：受到Git启发的版本控制文件层级系统。&lt;/li&gt;&lt;li&gt;命名：自验证的可变命名系统。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPFS初窥</title>
    <link href="http://www.hi-roy.com/2018/09/04/IPFS%E5%88%9D%E7%AA%A5/"/>
    <id>http://www.hi-roy.com/2018/09/04/IPFS初窥/</id>
    <published>2018-09-04T02:41:30.000Z</published>
    <updated>2019-09-16T08:11:51.459Z</updated>
    
    <content type="html"><![CDATA[<p>虽然区块链有很多令人兴奋的特性，但是也有其固有的缺点。比如，文件或者长度较长的文本信息就不适合存储在链上。那么如何解决这个缺点呢？一个解决方案就是IPFS(Interplanetary File System)——星际文件系统。</p><p>本文作为简介篇不打算涉及网络及数据结构相关知识(比如什么是协议、什么是树、什么是图……)，不过我相信各位看官既然能找到本文网络基础应该不是问题。</p><a id="more"></a><h2 id="为什么需要IPFS"><a href="#为什么需要IPFS" class="headerlink" title="为什么需要IPFS?"></a>为什么需要IPFS?</h2><p>说这个之前，我们看看现在互联网基石 —— <a href="https://baike.baidu.com/link?url=OBnU342D_H3DsMIofgdDvKsuy42D6BIdvLtFH7Y62gaeTON6Znlw_9ADYFHI4qPR5u9Bdw4dfPI1VueLNQRnpq" target="_blank" rel="noopener">HTTP协议</a>，网址(URL)由几部份构成:</p><ol><li>协议</li><li>服务器地址（IP地址，或者域名)</li><li>端口</li><li>路径</li><li>参数</li></ol><p>HTTP是路径(位置)导向的、中心化的，而IPFS则是资源导向的、分布式的。以网站举例，如果某个网站服务器关闭，那么如果没有其他三方对其进行过快照的话，基本就是再也看不到上面的内容了。而IPFS则不然，只要IPFS网络中有对应的副本，则不会因为某个”人”删除资源而导致无法访问。(单点问题)</p><p>老司机应该觉得眼熟，这不就和BT种子类似么？是的，IPFS结合了Git版本系统、Bittorrent、DHT等技术。也正因如此，IPFS刚好可以用来弥补区块链不适合存储文件或长文本这个缺陷。</p><p>基于路径导向还会导致某些安全问题，假定你需要下载<code>http://www.aa.com/file.zip</code>这个文件，如果这个文件被替换成木马病毒一类的，客户端是无法判断数据是否被更改的。换言之，客户端只知道”在哪里”，而不知道”是什么”。</p><p>此外，随着媒体类资源如音频、视频越发流行，带宽资源也越发成为限制HTTP传输速度的瓶颈。而如果你需要的资源在IPFS存在，则会自动选择一个最近的下载，传输速度大大提升。</p><h2 id="什么是IPFS"><a href="#什么是IPFS" class="headerlink" title="什么是IPFS?"></a>什么是IPFS?</h2><p>官网原话:</p><blockquote><p>IPFS aims to replace HTTP and build a better web for all of us.</p></blockquote><p>翻译过来就是：IPFS是来干掉现有HTTP协议、带领农奴翻身的。所以咧，<a href="https://ipfs.io/" target="_blank" rel="noopener">官网</a>就被”墙”了。但从技术角度，更好的解释在<a href="https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf" target="_blank" rel="noopener">白皮书</a>中。</p><p>白皮书标题就3点：</p><ul><li>内容寻址：通过文件内容生成唯一哈希值来标识文件，而不是通过文件保存位置来标识。相同内容的文件在系统中只会存在一份，节约存储空间。</li><li>版本化：可追溯文件修改历史。（参照git、svn）</li><li>点对点文件系统：P2P保存各种各样类型的数据。</li></ul><p>涉及的技术点有5个:</p><ol><li>分布式哈希表(DHT)</li><li>块交换</li><li>Merkle DAG</li><li>版本控制系统</li><li>自验证文件系统(SFS)</li></ol><p>上面的技术点基本每个都能写一系列文章，这里就简单说一下，如果有时间以后再补充完善。(没错，我又开始挖坑了！)</p><p>DHT被广泛用于维护协调p2p网络的元数据，比如BitTorrent中的<code>MainlineDHT</code>就追踪了torrent网络中节点的集合。而IPFS中则是结合了<code>Coral DSHT</code>和<code>S/Kademlia DHT</code>，这两个都是<code>Kademlia DHT</code>的扩展。(再简单说就是用来查找节点的。)</p><p>块交换，IPFS在BitTorrent的基础上实现了更通用的版本——<code>BitSwap</code>，这也是<a href="https://filecoin.io/" target="_blank" rel="noopener">Filecoin</a>的基础。</p><p>Merkle DAG，如果涉及过轻钱包应用的应该知道Merkle Tree，在Merkle Tree中每个父节点的值都是其子节点值的哈希。Merkle DAG则是Merkle Tree和有向无环图(DAG)的结合体，广义上所有数据都在Merkle DAG进行建模，这是保证数据正确、安全传输的关键点。</p><p>版本控制，这个不用多说了吧？</p><p>自验证文件系统(Self-certifying File System,SFS)是一种不需要特殊权限的分布式文件系统，因为每个用户上传是生成的文件名已经是经过其私钥签名过的了。在这个基础上，又可以引出星际命名空间(InterPlanetary Name Space,IPNS)的概念。之前说过IPFS上的文件哈希后都是唯一识别的，推广开来，每个节点也有公钥、私钥和节点ID，节点ID是其公钥的哈希值，节点可以使用私钥来对其发布的数据签名，其他用户检索时，可以检查发送者的公钥来验证数据真实性。</p><h2 id="如何使用IPFS"><a href="#如何使用IPFS" class="headerlink" title="如何使用IPFS?"></a>如何使用IPFS?</h2><p>首先下载<a href="https://dist.ipfs.io/#go-ipfs" target="_blank" rel="noopener">go-ipfs</a>，我这里直接使用linux版本的，解压后执行:<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">go-ipfs❯ sudo sh install.sh</span><br><span class="line">[sudo] password <span class="keyword">for</span> roy:</span><br><span class="line">Moved ./ipfs to /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">go-ipfs❯ ipfs init</span><br><span class="line">initializing IPFS node at /home/roy/.ipfs</span><br><span class="line">generating 2048-bit RSA keypair...done</span><br><span class="line">peer identity: QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC</span><br><span class="line">to get started, enter:</span><br><span class="line"></span><br><span class="line">ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</span><br><span class="line"></span><br><span class="line">go-ipfs❯ ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</span><br><span class="line">Hello and Welcome to IPFS!</span><br><span class="line"></span><br><span class="line">██╗██████╗ ███████╗███████╗</span><br><span class="line">██║██╔══██╗██╔════╝██╔════╝</span><br><span class="line">██║██████╔╝█████╗  ███████╗</span><br><span class="line">██║██╔═══╝ ██╔══╝  ╚════██║</span><br><span class="line">██║██║     ██║     ███████║</span><br><span class="line">╚═╝╚═╝     ╚═╝     ╚══════╝</span><br><span class="line"></span><br><span class="line">If you seeing this, you have successfully installed</span><br><span class="line">IPFS and are now interfacing with the ipfs merkledag!</span><br><span class="line"></span><br><span class="line"> -------------------------------------------------------</span><br><span class="line">| Warning:                                              |</span><br><span class="line">|   This is alpha software. Use at your own discretion! |</span><br><span class="line">|   Much is missing or lacking polish. There are bugs.  |</span><br><span class="line">|   Not yet secure. Read the security notes <span class="keyword">for</span> more.   |</span><br><span class="line"> -------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Check out some of the other files <span class="keyword">in</span> this directory:</span><br><span class="line"></span><br><span class="line">  ./about</span><br><span class="line">  ./<span class="built_in">help</span></span><br><span class="line">  ./quick-start     &lt;-- usage examples</span><br><span class="line">  ./readme          &lt;-- this file</span><br><span class="line">  ./security-notes</span><br></pre></td></tr></table></figure><p></p><p>建议使用提示中的哦命令看看<code>quick-start</code>，常用操作都在里面了。</p><p>然后启动ipfs服务：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">go-ipfs❯ ipfs daemon</span><br><span class="line">Initializing daemon...</span><br><span class="line">Successfully raised file descriptor limit to 2048.</span><br><span class="line"></span><br><span class="line">Swarm listening on /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/172.17.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/172.18.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.1.104/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.124.1/tcp/4001</span><br><span class="line">Swarm listening on /ip6/::1/tcp/4001</span><br><span class="line">Swarm listening on /p2p-circuit/ipfs/QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC</span><br><span class="line">Swarm announcing /ip4/100.64.109.213/tcp/12182</span><br><span class="line">Swarm announcing /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/172.17.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/172.18.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.1.104/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.124.1/tcp/4001</span><br><span class="line">Swarm announcing /ip6/::1/tcp/4001</span><br><span class="line">API server listening on /ip4/127.0.0.1/tcp/5001</span><br><span class="line">Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure><p></p><p>然后访问<code>http://localhost:5001/webui</code>可以查看系统信息、创建文件夹、添加文件等。</p><p>添加个文件：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ » mkdir roy_test</span><br><span class="line">~ » <span class="built_in">echo</span> <span class="string">"www.hi-roy.com"</span> &gt; roy_test/roy.txt</span><br><span class="line">~ » ipfs add -r roy_test</span><br><span class="line">added QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd roy_test/roy.txt</span><br><span class="line">added QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx roy_test</span><br></pre></td></tr></table></figure><p></p><p>然后测试下文件是否添加成功：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipfs ls QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx</span><br><span class="line">QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd 23 roy.txt</span><br><span class="line"></span><br><span class="line">ipfs cat /ipfs/QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd</span><br><span class="line">www.hi-roy.com</span><br></pre></td></tr></table></figure><p></p><p>也可以通过本地网关访问<code>http://localhost:8080/ipfs/QmTbyi4XTyG8PrJo7KDcexNGxBJNKfJCwjfmY4HmtENqYd</code>。</p><p>然后我们来修改一下文件：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"www.hi-roy.com"</span> &gt;&gt; roy_test/roy.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"www.hi-roy.com"</span> &gt;&gt; roy_test/roy.txt</span><br><span class="line">ipfs add roy_test/roy.txt</span><br><span class="line">added QmUcwEGLBhLKYG7X1DrbMbbSKSJ3GbDHWibymwXqUG1PCK roy.txt</span><br></pre></td></tr></table></figure><p></p><p>注意，修改文件后哈希值发生了变化，原来的文件依然存在。但每次更新文件都有一个新哈希也太麻烦了，这时可以使用上面说的<code>IPNS</code>了:<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipfs name publish QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx</span><br><span class="line">Published to QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC: /ipfs/QmUK6CHzQyn2CWpHumysxhQXjzi4dA373DYLD2zgj8n7kx</span><br></pre></td></tr></table></figure><p></p><p>这里我把文件夹的哈希值作为根发布，然后就可以使用<code>ipns</code>查看文件了：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipfs cat /ipns/QmcWR5hMnF7LNqNJBC6fxSBdXRUBgJEnXca3MHWN8kpdXC/roy.txt</span><br><span class="line"></span><br><span class="line">www.hi-roy.com</span><br><span class="line">www.hi-roy.com</span><br><span class="line">www.hi-roy.com</span><br></pre></td></tr></table></figure><p></p><p>以后更新文件后再publish就可以了。不过 <strong>使用ipns会很慢</strong>。</p><h2 id="使用IPFS时应该注意？"><a href="#使用IPFS时应该注意？" class="headerlink" title="使用IPFS时应该注意？"></a>使用IPFS时应该注意？</h2><p>永久性(Permanence)不等同于持久性(Persistence)。</p><blockquote><p>Objects are permanent。</p></blockquote><p>也就是说，你在IPFS网络中上传了某个文件，指向你这个文件的链接是永久不变的，但如果每个节点都觉得这个文件没什么价值而将其删除，那么这个文件是会”消失”的。</p><h2 id="IPFS的应用领域"><a href="#IPFS的应用领域" class="headerlink" title="IPFS的应用领域?"></a>IPFS的应用领域?</h2><p>白皮书3.8节提到了12个应用场景：</p><ol><li>作为全球文件系统挂载到<code>/ipfs</code>和<code>/ipns</code>下。</li><li>作为个人同步文件夹自动控制版本、推送、备份。</li><li>作为加密文件或者数据共享系统。</li><li>作为所有软件的版本控制器。</li><li>作为虚拟机的根文件系统。</li><li>作为VM的引导文件。</li><li>作为数据库:程序可以直接写入Merkle DAG数据模型，并获得IPFS提供的版本控制、缓存、分发功能。</li><li>作为一个加密的通信平台。</li><li>作为一个大文件完整性校验的CDN平台(不需要SSL)。</li><li>作为加密CDN。</li><li>作为网站CDN。</li><li>作为一个永远不会消失的网站。</li></ol><p>利用IPFS的项目比较多，但大多处于探索阶段，杀手级的目前还没出现。这里给大家介绍我认为比较有意思的：</p><ol><li><a href="https://akasha.world/" target="_blank" rel="noopener">akasha</a>，号称下一代社交网络，测试玩的话chrome浏览器可以装个<code>MetaMask</code>插件，并将网络设置为<code>Rinkeby Test Network</code>。</li><li><a href="https://github.com/ipfs/distributed-wikipedia-mirror" target="_blank" rel="noopener">基于IPFS的维基百科</a>，维基百科镜像。</li><li><a href="https://livepeer.org/" target="_blank" rel="noopener">livepeer</a>，去中心化流媒体平台，可以贡献自己的带宽获取token。</li></ol><p><img src="https://cdn-images-1.medium.com/max/800/1*N3BFp35i_jfTo7RMHsDNwg.jpeg" alt="应用"></p><h2 id="IPFS的缺点"><a href="#IPFS的缺点" class="headerlink" title="IPFS的缺点?"></a>IPFS的缺点?</h2><p>目前觉得缺点有２个：</p><ol><li><p>域名不友好，比如<code>ipfs.io/ipns/Qmxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/</code>。当然可以引入域名系统DNS，但又会面临现有DNS系统的各种缺陷，比如域名污染等。</p></li><li><p>数据节点没动力维持网络数据的长期备份，如果所有的数据节点都将某份数据清除来节省空间，理论上这个文件最终会”消失”。为了缓解这个问题，引入了<code>FileCoin</code>来为IPFS添加经济激励，毕竟有句话叫做”无利不起早”么。</p></li></ol><p>写到这让我想起了《人月神话》中的经典台词：</p><blockquote><p>没有银弹。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然区块链有很多令人兴奋的特性，但是也有其固有的缺点。比如，文件或者长度较长的文本信息就不适合存储在链上。那么如何解决这个缺点呢？一个解决方案就是IPFS(Interplanetary File System)——星际文件系统。&lt;/p&gt;&lt;p&gt;本文作为简介篇不打算涉及网络及数据结构相关知识(比如什么是协议、什么是树、什么是图……)，不过我相信各位看官既然能找到本文网络基础应该不是问题。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>墨卡托坐标转经纬度</title>
    <link href="http://www.hi-roy.com/2018/07/30/%E5%A2%A8%E5%8D%A1%E6%89%98%E5%9D%90%E6%A0%87%E8%BD%AC%E7%BB%8F%E7%BA%AC%E5%BA%A6/"/>
    <id>http://www.hi-roy.com/2018/07/30/墨卡托坐标转经纬度/</id>
    <published>2018-07-30T07:52:40.000Z</published>
    <updated>2019-09-16T08:11:51.523Z</updated>
    
    <content type="html"><![CDATA[<p>今天获取百度地图数据时候发现其坐标都是类似<code>12945050.96,4826978.52</code>这种而非常见的经纬度，之前获取百度外面商家信息时就发现了这个问题但没深入研究，搜索后发现这种表示方法叫做<code>墨卡托坐标</code>。不得不说，关于坐标的标准还真是挺多的，根据经纬度查询位置可以使用<a href="http://www.gpsspg.com/maps.htm" target="_blank" rel="noopener">这个网站</a>。</p><a id="more"></a><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mcband = [<span class="number">6</span>]<span class="keyword">float64</span>&#123;<span class="number">12890594.86</span>, <span class="number">8362377.87</span>, <span class="number">5591021</span>, <span class="number">3481989.83</span>, <span class="number">1678043.12</span>, <span class="number">0.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> mc2ll = [<span class="number">6</span>][<span class="number">10</span>]<span class="keyword">float64</span>&#123;</span><br><span class="line">&#123;<span class="number">1.410526172116255e-8</span>, <span class="number">0.00000898305509648872</span>, <span class="number">-1.9939833816331</span>,</span><br><span class="line"><span class="number">200.9824383106796</span>, <span class="number">-187.2403703815547</span>, <span class="number">91.6087516669843</span>, <span class="number">-23.38765649603339</span>,</span><br><span class="line"><span class="number">2.57121317296198</span>, <span class="number">-0.03801003308653</span>, <span class="number">17337981.2</span>&#125;,</span><br><span class="line">&#123;<span class="number">-7.435856389565537e-9</span>, <span class="number">0.000008983055097726239</span>, <span class="number">-0.78625201886289</span>,</span><br><span class="line"><span class="number">96.32687599759846</span>, <span class="number">-1.85204757529826</span>, <span class="number">-59.36935905485877</span>, <span class="number">47.40033549296737</span>,</span><br><span class="line"><span class="number">-16.50741931063887</span>, <span class="number">2.28786674699375</span>, <span class="number">10260144.86</span>&#125;,</span><br><span class="line">&#123;<span class="number">-3.030883460898826e-8</span>, <span class="number">0.00000898305509983578</span>, <span class="number">0.30071316287616</span>,</span><br><span class="line"><span class="number">59.74293618442277</span>, <span class="number">7.357984074871</span>, <span class="number">-25.38371002664745</span>, <span class="number">13.45380521110908</span>,</span><br><span class="line"><span class="number">-3.29883767235584</span>, <span class="number">0.32710905363475</span>, <span class="number">6856817.37</span>&#125;,</span><br><span class="line">&#123;<span class="number">-1.981981304930552e-8</span>, <span class="number">0.000008983055099779535</span>, <span class="number">0.03278182852591</span>, <span class="number">40.31678527705744</span>,</span><br><span class="line"><span class="number">0.65659298677277</span>, <span class="number">-4.44255534477492</span>, <span class="number">0.85341911805263</span>, <span class="number">0.12923347998204</span>,</span><br><span class="line"><span class="number">-0.04625736007561</span>, <span class="number">4482777.06</span>&#125;,</span><br><span class="line">&#123;<span class="number">3.09191371068437e-9</span>, <span class="number">0.000008983055096812155</span>, <span class="number">0.00006995724062</span>, <span class="number">23.10934304144901</span>,</span><br><span class="line"><span class="number">-0.00023663490511</span>, <span class="number">-0.6321817810242</span>, <span class="number">-0.00663494467273</span>, <span class="number">0.03430082397953</span>,</span><br><span class="line"><span class="number">-0.00466043876332</span>, <span class="number">2555164.4</span>&#125;,</span><br><span class="line">&#123;<span class="number">2.890871144776878e-9</span>, <span class="number">0.000008983055095805407</span>, <span class="number">-3.068298e-8</span>, <span class="number">7.47137025468032</span>,</span><br><span class="line"><span class="number">-0.00000353937994</span>, <span class="number">-0.02145144861037</span>, <span class="number">-0.00001234426596</span>, <span class="number">0.00010322952773</span>,</span><br><span class="line"><span class="number">-0.00000323890364</span>, <span class="number">826088.5</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159265358979324</span> * <span class="number">3000.0</span> / <span class="number">180.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ConvertMCT_2_BD09 将墨卡托坐标转换被BD09坐标（百度地图专用）</span></span><br><span class="line"><span class="comment">// log 经度 lat纬度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertMCT_2_BD09</span><span class="params">(lon, lat <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lat &lt; <span class="number">0.0</span>) || (lon &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line"><span class="comment">//国内经纬度都是正数</span></span><br><span class="line">log.Fatal(<span class="string">"lat and lon must greater than 0!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ax [<span class="number">10</span>]<span class="keyword">float64</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> mcband &#123;</span><br><span class="line"><span class="keyword">if</span> lat &gt;= v &#123;</span><br><span class="line">ax = mc2ll[i]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">e := ax[<span class="number">0</span>] + ax[<span class="number">1</span>]*lon</span><br><span class="line">i := lat / ax[<span class="number">9</span>]</span><br><span class="line">aw := ax[<span class="number">2</span>] + ax[<span class="number">3</span>]*i + ax[<span class="number">4</span>]*math.Pow(i, <span class="number">2</span>) + ax[<span class="number">5</span>]*math.Pow(i, <span class="number">3</span>) +</span><br><span class="line">ax[<span class="number">6</span>]*math.Pow(i, <span class="number">4</span>) + ax[<span class="number">7</span>]*math.Pow(i, <span class="number">5</span>) + ax[<span class="number">8</span>]*math.Pow(i, <span class="number">6</span>)</span><br><span class="line">fmt.Println(e, aw)</span><br><span class="line"><span class="keyword">return</span> e, aw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConvertBD09_2GCJ03 用于把BD09坐标转成GCJ03</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertBD09_2_GCJ03</span><span class="params">(lon, lat <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">x := lon - <span class="number">0.0065</span></span><br><span class="line">y := lat - <span class="number">0.006</span></span><br><span class="line">z := math.Sqrt(x*x+y*y) - <span class="number">0.00002</span>*math.Sin(y*pi)</span><br><span class="line">theta := math.Atan2(y, x) - <span class="number">0.000003</span>*math.Cos(x*pi)</span><br><span class="line">ggLon := z * math.Cos(theta)</span><br><span class="line">ggLat := z * math.Sin(theta)</span><br><span class="line"><span class="keyword">return</span> ggLon, ggLat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(ConvertBD09_2_GCJ03(ConvertMCT_2_BD09(<span class="number">12945050.96</span>, <span class="number">4826978.52</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">116.28610602331416 39.92229605145939</span><br><span class="line">116.27973999840552 39.915952179109595</span><br></pre></td></tr></table></figure><p></p><p>python2版本的在<a href="https://gist.github.com/JobsDong/8313339" target="_blank" rel="noopener">这里</a>，本文也是由这个方法改(chao)写(xi)的，python3使用时把<code>xrange</code>改成<code>range</code>即可。</p><p>最后记录一个百度查询地址接口<code>https://api.map.baidu.com/?qt=s&amp;c=340&amp;wd=地名&amp;rn=10&amp;ie=utf-8&amp;oue=1&amp;res=api</code>，其中参数<code>c</code>代表城市代码，如果不传递的话接口返回的是可能存在这个地名的城市，城市代码可以自行百度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天获取百度地图数据时候发现其坐标都是类似&lt;code&gt;12945050.96,4826978.52&lt;/code&gt;这种而非常见的经纬度，之前获取百度外面商家信息时就发现了这个问题但没深入研究，搜索后发现这种表示方法叫做&lt;code&gt;墨卡托坐标&lt;/code&gt;。不得不说，关于坐标的标准还真是挺多的，根据经纬度查询位置可以使用&lt;a href=&quot;http://www.gpsspg.com/maps.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个网站&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>200行GO代码实现区块链3</title>
    <link href="http://www.hi-roy.com/2018/06/22/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE3/"/>
    <id>http://www.hi-roy.com/2018/06/22/200行GO代码实现区块链3/</id>
    <published>2018-06-22T09:35:36.000Z</published>
    <updated>2019-09-16T08:11:51.451Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-mining-algorithm-in-go-82c6a71aba1f" target="_blank" rel="noopener">原文</a>，阅读之前请先看<a href="http://www.hi-roy.com/2018/05/18/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE1/">200行GO代码实现区块链1</a> 和 <a href="http://www.hi-roy.com/2018/05/21/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE2/">200行GO代码实现区块链2</a>。</p><p>如果看到这了相信你已经知道什么是加密算法等背景了，所以忽略关于这部分的翻译，直接从编码开始。这篇文章在前两篇的文章基础上添加了工作量证明(POW)挖矿算法。</p><a id="more"></a><p>首先创建<code>.env</code>文件来定义环境变量，里面只有一行<code>ADDR=8080</code>，然后创建<code>main.go</code>并引入相关依赖：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"crypto/sha256"</span></span><br><span class="line">        <span class="string">"encoding/hex"</span></span><br><span class="line">        <span class="string">"encoding/json"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"io"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"os"</span></span><br><span class="line">        <span class="string">"strconv"</span></span><br><span class="line">        <span class="string">"strings"</span></span><br><span class="line">        <span class="string">"sync"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">        <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">        <span class="string">"github.com/joho/godotenv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>如果你阅读过之前的文章，你应该知道区块链中的区块通过比较本区块记录的<code>PrevHash</code>和前一个区块的<code>Hash</code>来进行验证，这也是保证区块链完整性和坏人无法改变区块链历史的原因。</p><p><code>BMP</code>代表心跳速率，我们使用这个作为存储在区块中的数据，接下来定义数据模型和需要的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> difficulty = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">        Index      <span class="keyword">int</span></span><br><span class="line">        Timestamp  <span class="keyword">string</span></span><br><span class="line">        BPM        <span class="keyword">int</span></span><br><span class="line">        Hash       <span class="keyword">string</span></span><br><span class="line">        PrevHash   <span class="keyword">string</span></span><br><span class="line">        Difficulty <span class="keyword">int</span></span><br><span class="line">        Nonce      <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">        BPM <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>difficulty</code>定义了难度，即hash值开头0的数量。0数量越多，则难度越大，这里我们要求开头有1个0。</p><p><code>Block</code>是区块的数据结构，别忘了<code>Nonce</code>，我们晚一些解释这个。</p><p><code>Blockchain</code>是<code>Block</code>组成的列表(Roy注：准确的说是slice，不过翻译成切片有点拗口)，用来存储区块链。</p><p><code>Message</code>用来接收我们向REST API使用<code>POST</code>方式生成新区块的数据。</p><p>我们声明了<code>mutex</code>来数据冲突并且确保区块不会同一时刻生成多个。</p><p>接下来创建web服务，首先创建<code>run()</code>函数晚些将在<code>main</code>函数中调用，同时生成了<code>makeMuxRouter()</code>来管理路由。记住，我们使用<code>GET</code>来检索区块<code>POST</code>来添加新区块，由于区块链是不可变的所以我们不需要删除或编辑功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        mux := makeMuxRouter()</span><br><span class="line">        httpAddr := os.Getenv(<span class="string">"ADDR"</span>)</span><br><span class="line">        log.Println(<span class="string">"Listening on "</span>, os.Getenv(<span class="string">"ADDR"</span>))</span><br><span class="line">        s := &amp;http.Server&#123;</span><br><span class="line">                Addr:           <span class="string">":"</span> + httpAddr,</span><br><span class="line">                Handler:        mux,</span><br><span class="line">                ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">                WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">                MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := s.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMuxRouter</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">        muxRouter := mux.NewRouter()</span><br><span class="line">        muxRouter.HandleFunc(<span class="string">"/"</span>, handleGetBlockchain).Methods(<span class="string">"GET"</span>)</span><br><span class="line">        muxRouter.HandleFunc(<span class="string">"/"</span>, handleWriteBlock).Methods(<span class="string">"POST"</span>)</span><br><span class="line">        <span class="keyword">return</span> muxRouter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>httpAddr := os.Getenv(&quot;ADDR&quot;)</code>这行代码从<code>.env</code>文件中读取我们定义的<code>:8080</code>，这样就可以通过浏览器访问<code>http://localhost:8080</code>来查看应用了。(Roy注:注意这里的<code>1 &lt;&lt; 20</code>这个位移操作，正好是1KB。)</p><p>现在编写处理<code>GET</code>请求的函数来在浏览器展示我们的区块链，同时添加<code>respondwithJSON</code>函数来打印错误信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGetBlockchain</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        bytes, err := json.MarshalIndent(Blockchain, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        io.WriteString(w, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">respondWithJSON</span><span class="params">(w http.ResponseWriter, r *http.Request, code <span class="keyword">int</span>, payload <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        response, err := json.MarshalIndent(payload, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">                w.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP 500: Internal Server Error"</span>))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(code)</span><br><span class="line">        w.Write(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果你觉得一头雾水，请先看之前的文章。</em></p><p>接下来编写处理生成区块的<code>POST</code>请求函数，我们通过发送JSON类型的数据比如<code>{&quot;BMP&quot;:60}</code>到<code>http://localhost:8080</code>来生成新区块：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWriteBlock</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        <span class="keyword">var</span> m Message</span><br><span class="line"></span><br><span class="line">        decoder := json.NewDecoder(r.Body)</span><br><span class="line">        <span class="keyword">if</span> err := decoder.Decode(&amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                respondWithJSON(w, r, http.StatusBadRequest, r.Body)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ensure atomicity when creating new block</span></span><br><span class="line">        mutex.Lock()</span><br><span class="line">        newBlock := generateBlock(Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>], m.BPM)</span><br><span class="line">        mutex.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isBlockValid(newBlock, Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]) &#123;</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, newBlock)</span><br><span class="line">                spew.Dump(Blockchain)</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        respondWithJSON(w, r, http.StatusCreated, newBlock)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意<code>mutex</code>加锁和解锁的地方，我们在写新区块之前加锁，否则将可能造成数据冲突。有些读者可能注意到了<code>generateBlock</code>函数，这是实现工作量证明的关键函数，我们一会再说。</p><p>首先添加<code>isBlockValid</code>函数来确保区块链的索引递增并且每个区块的<code>PrevHash</code>和前一个区块的<code>Hash</code>相匹配。</p><p>然后添加<code>calculateHash</code>函数来计算创建Hash值，这里我们使用SHA256来链接Index、Timestamp，BMP，PrevHash和Nonce（我们晚一点解释这个）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> calculateHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        record := strconv.Itoa(block.Index) + block.Timestamp + strconv.Itoa(block.BPM) + block.PrevHash + block.Nonce</span><br><span class="line">        h := sha256.New()</span><br><span class="line">        h.Write([]<span class="keyword">byte</span>(record))</span><br><span class="line">        hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写挖矿算法——工作量证明(POW)，我们要确保在新区块添加到区块链之前工作量证明已经完成，让我们先写一个简单的函数来检查生成的散列是否满足条件：</p><ul><li>生成的散列是否以0开头</li><li>开头0的数量是否和我们常量<code>difficulty</code>中定义的一致(本例中为1)</li><li>我们可以通过增大难度来使挖矿变难</li></ul><p>函数<code>isHashValid</code>如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHashValid</span><span class="params">(hash <span class="keyword">string</span>, difficulty <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        prefix := strings.Repeat(<span class="string">"0"</span>, difficulty)</span><br><span class="line">        <span class="keyword">return</span> strings.HasPrefix(hash, prefix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>GO在<code>strings</code>包中提供了<code>Repeat</code>和<code>HasPrefix</code>函数，变量<code>prefix</code>是重复了<code>difficulty</code>次的0组成的字符串，接下来我们判断散列是否以这个字符串开头，如果是返回<code>True</code>否则返回<code>False</code>。</p><p>接下来构建<code>generateBlock</code>函数：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>)</span> <span class="title">Block</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">        t := time.Now()</span><br><span class="line"></span><br><span class="line">        newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">        newBlock.Timestamp = t.String()</span><br><span class="line">        newBlock.BPM = BPM</span><br><span class="line">        newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">        newBlock.Difficulty = difficulty</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">                hex := fmt.Sprintf(<span class="string">"%x"</span>, i)</span><br><span class="line">                newBlock.Nonce = hex</span><br><span class="line">                <span class="keyword">if</span> !isHashValid(calculateHash(newBlock), newBlock.Difficulty) &#123;</span><br><span class="line">                        fmt.Println(calculateHash(newBlock), <span class="string">" do more work!"</span>)</span><br><span class="line">                        time.Sleep(time.Second)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fmt.Println(calculateHash(newBlock), <span class="string">" work done!"</span>)</span><br><span class="line">                        newBlock.Hash = calculateHash(newBlock)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里创建新区块并将前一个区块的Hash存储到本区块的PrevHash中来确保连续性，其他字段也很明显：</p><ul><li><code>Index</code>自增</li><li><code>Timestamp</code>记录当前时间</li><li><code>BMP</code>记录心跳数据</li><li><code>Difficulty</code>简单的记录了程序最上面定义的常量。本文中不会使用，但未来如果我们需要确保难度和当前散列结果一致（比如散列前面有Ｎ位0，这个值应该和Difficulty相等）时将要用到。</li></ul><p><code>for</code>循环在这里是很关键的一步，我们来看看这里都做了些什么：</p><ul><li>首先我们将16进制的<code>i</code>值赋值给了<code>Nonce</code>，我们的<code>calculateHash</code>函数需要这个变量来进行Hash计算，如果计算结果0的个数不满足要求，我们则尝试一个新值。</li><li>我们从0开始循环，并判断其结果0开头的个数是否和<code>difficulty</code>规定的一样，如果不同则进行下一次循环。</li><li>我们添加了<code>sleep</code>1秒钟来模拟工作量证明算法中某些耗时操作。</li><li>进行循环直到获得一个开头0的个数满足我们需求的数值，也就意味着工作量证明算法成功执行。此时才准许新区块通过<code>handleWriteBlock</code>添加到区块链中。</li></ul><p>所有需要的函数都完成了，现在编写<code>main</code>函数：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := godotenv.Load()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                t := time.Now()</span><br><span class="line">                genesisBlock := Block&#123;&#125;</span><br><span class="line">                genesisBlock = Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, calculateHash(genesisBlock), <span class="string">""</span>, difficulty, <span class="string">""</span>&#125;</span><br><span class="line">                spew.Dump(genesisBlock)</span><br><span class="line"></span><br><span class="line">                mutex.Lock()</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">        log.Fatal(run())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过调用<code>godotenv.Load()</code>来载入环境变量，这里是<code>:8080</code>端口。然后创建一个go routine 创建了创世块作为整个区块链的起始，最后调用<code>run()</code>函数来运行web服务。</p><p>完整代码在<a href="https://github.com/mycoralhealth/blockchain-tutorial/blob/master/proof-work/main.go" target="_blank" rel="noopener">这里</a>。</p><hr><p>核心部分就翻译到这，原文还有一些如何使用<code>postman</code>进行测试以及测试输出的部分就不翻译了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://medium.com/@mycoralhealth/code-your-own-blockchain-mining-algorithm-in-go-82c6a71aba1f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，阅读之前请先看&lt;a href=&quot;http://www.hi-roy.com/2018/05/18/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE1/&quot;&gt;200行GO代码实现区块链1&lt;/a&gt; 和 &lt;a href=&quot;http://www.hi-roy.com/2018/05/21/200%E8%A1%8CGO%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE2/&quot;&gt;200行GO代码实现区块链2&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果看到这了相信你已经知道什么是加密算法等背景了，所以忽略关于这部分的翻译，直接从编码开始。这篇文章在前两篇的文章基础上添加了工作量证明(POW)挖矿算法。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger-Fabric环境搭建笔记</title>
    <link href="http://www.hi-roy.com/2018/06/15/Hyperledger-Fabric%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.hi-roy.com/2018/06/15/Hyperledger-Fabric环境搭建笔记/</id>
    <published>2018-06-15T02:43:49.000Z</published>
    <updated>2019-09-16T08:11:51.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>前提需要电脑中存在<code>git</code>、<code>docker</code>、<code>docker-compose</code>命令以及有<code>golang</code>开发环境。</p><p>首先创建目录存放Fabric代码，<strong>注意路径和权限</strong>，在启动服务时候会向其中写一些文件，最开始我就是没注意到这点报错了。<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /opt/gopath/src/github.com/hyperledger/</span><br></pre></td></tr></table></figure><p></p><p>进入刚才创建的目录后拉取代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/gopath/src/github.com/hyperledger</span><br><span class="line">git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure><p></p><p>当前版本是1.1。</p><a id="more"></a><p>然后拉取所需镜像，这步速度慢需要耐心等待。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /opt/gopath/src/github.com/hyperledger/fabric/scripts/bootstrap.sh</span><br></pre></td></tr></table></figure><p></p><p>完成后进入<code>/opt/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli</code>目录，执行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash network_setup.sh up</span><br></pre></td></tr></table></figure><p></p><p>这个文件干了几件事：</p><ol><li>编译生成Fabric公私钥、证书的程序，程序在目录：/opt/gopath/src/github.com/hyperledger/fabric/release/linux-amd64/bin</li><li>基于configtx.yaml生成创世区块和通道相关信息，并保存在channel-artifacts文件夹。</li><li>基于crypto-config.yaml生成公私钥和证书信息，并保存在crypto-config文件夹中。</li><li>基于docker-compose-cli.yaml启动1Orderer+2org*2Peer+1CLI的Fabric容器。</li><li>在CLI启动的时候，会运行scripts/script.sh文件，这个脚本文件包含了创建Channel，加入Channel，安装Example02，运行Example02等功能。</li></ol><p>成功后会看到提示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">===================== All GOOD, End-2-End execution completed =====================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> _____   _   _   ____            _____   ____    _____</span><br><span class="line">| ____| | \ | | |  _ \          | ____| |___ \  | ____|</span><br><span class="line">|  _|   |  \| | | | | |  _____  |  _|     __) | |  _|  </span><br><span class="line">| |___  | |\  | | |_| | |_____| | |___   / __/  | |___</span><br><span class="line">|_____| |_| \_| |____/          |_____| |_____| |_____|</span><br></pre></td></tr></table></figure><p></p><p>查看创建的容器：<br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker ps --format <span class="string">"&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Names&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line">a2adbbe090ce:dev-peer1.org2.example.com-mycc-1.0</span><br><span class="line">434f146382d3:dev-peer0.org1.example.com-mycc-1.0</span><br><span class="line">f07e03296c11:dev-peer0.org2.example.com-mycc-1.0</span><br><span class="line">6eee69b127ff:cli</span><br><span class="line">f323f3bf5b0e:orderer.example.com</span><br><span class="line">f8eae1488dce:kafka3</span><br><span class="line">3b79d89b3928:kafka0</span><br><span class="line">dd5cd1d8c35a:kafka2</span><br><span class="line">c7953a8951f1:kafka1</span><br><span class="line">7d28f6dc8c3b:peer0.org1.example.com</span><br><span class="line">aeb4ce4d57c3:zookeeper2</span><br><span class="line">734e25a4430e:zookeeper0</span><br><span class="line">6b051d7edb2e:peer1.org2.example.com</span><br><span class="line">f19e5663a764:zookeeper1</span><br><span class="line">9494e1f87c56:peer1.org1.example.com</span><br><span class="line">7bada708f807:peer0.org2.example.com</span><br></pre></td></tr></table></figure><p></p><blockquote><p>默认安装了：4个peer（2个是org1的，2个是org2的）节点、4节点构成的kafka集群、3节点构成的zookeeper集群、1个orderer节点。这是因为：fabric提供的共识机制，PBFT目前还未达到生产级别的应用，只能靠kafka+zookeeper实现PAXOS算法下的共识机制（不能有作恶结点）</p></blockquote><h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><p>先进入容器中<code>docker exec -it cli sh</code>，然后看看<code>peer</code>命令都支持什么操作：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it cli sh</span><br><span class="line"></span><br><span class="line"># pwd</span><br><span class="line">/opt/gopath/src/github.com/hyperledger/fabric/peer</span><br><span class="line"># peer -h</span><br><span class="line">Usage:</span><br><span class="line">  peer [flags]</span><br><span class="line">  peer [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  chaincode   Operate a chaincode: install|instantiate|invoke|package|query|signpackage|upgrade|list.</span><br><span class="line">  channel     Operate a channel: create|fetch|join|list|update|signconfigtx|getinfo.</span><br><span class="line">  logging     Log levels: getlevel|setlevel|revertlevels.</span><br><span class="line">  node        Operate a peer node: start|status.</span><br><span class="line">  version     Print fabric peer version.</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --logging-level string   Default logging level and overrides, see core.yaml for full syntax</span><br><span class="line">  -v, --version                Display current version of fabric peer server</span><br><span class="line"></span><br><span class="line">Use &quot;peer [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p></p><p>和以太坊类似，fabric中交易也要通过chaincode操作。chancode支持的命令如下：</p><ul><li>package 智能合约需要打包后才能使用</li><li>install 智能合约必须安装后才能使用</li><li>instantiate 置初始状态。比如设系统一开始用户a有100元，用户b有200元</li><li>invoke 调用智能合约</li><li>query 查询状态</li><li>signpackage 包签名</li><li>upgrade 智能合约升级</li><li>list 显示智能合约</li></ul><p>首先执行命令查询余额：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br><span class="line">2018-06-15 03:16:39.226 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-06-15 03:16:39.226 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-06-15 03:16:39.226 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-06-15 03:16:39.227 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-06-15 03:16:39.227 UTC [chaincodeCmd] getChaincodeSpec -&gt; DEBU 005 java chaincode disabled</span><br><span class="line">2018-06-15 03:16:39.227 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: plaintext: 0ABE070A6608031A0B0897DF8CD90510...6D7963631A0A0A0571756572790A0161</span><br><span class="line">2018-06-15 03:16:39.227 UTC [msp/identity] Sign -&gt; DEBU 007 Sign: digest: 916F0EE6336EADD59FEBF6538B30645BED4C60C64AD65255ABFCADD189655300</span><br><span class="line">Query Result: 90</span><br></pre></td></tr></table></figure><p></p><p>等等，为什么我们什么安装操作都没做就能执行查询命令而且还有结果呢？原因在启动服务的过程中有这么一段：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Installing chaincode on org1/peer0...</span><br><span class="line">....</span><br><span class="line">2018-06-15 02:35:10.647 UTC [container] WriteFileToPackage -&gt; DEBU 00c Writing file to tarball: src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02/chaincode_example02.go</span><br><span class="line">2018-06-15 02:35:10.648 UTC [container] WriteFileToPackage -&gt; DEBU 00d Writing file to tarball: src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02/chaincode_example02_test.go</span><br><span class="line">2018-06-15 02:35:10.648 UTC [msp/identity] Sign -&gt; DEBU 00e Sign: plaintext: 0AB4070A5C08031A0C08DECB8CD90510...83C77F030000FFFF1E416A37002E0000</span><br><span class="line">2018-06-15 02:35:10.648 UTC [msp/identity] Sign -&gt; DEBU 00f Sign: digest: 45EC14B3196DC03ACB6A413DED651FBBAF8BEF4B109DA6F0D8E821F150DA7ED1</span><br><span class="line">2018-06-15 02:35:10.650 UTC [chaincodeCmd] install -&gt; DEBU 010 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">2018-06-15 02:35:10.650 UTC [main] main -&gt; INFO 011 Exiting.....</span><br><span class="line">===================== Chaincode is installed on remote peer PEER0 =====================</span><br></pre></td></tr></table></figure><p></p><p>启动脚本中已经帮我们安装好<code>src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02/chaincode_example02.go</code>这个Chaincode并且初始化了。<br>如果后续需要创建或修改代码，则需要重新安装：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</span><br></pre></td></tr></table></figure><p></p><p>其中<code>-n</code>表示合约名字，<code>-p</code>指向合约文件目录路径，<code>-v</code>是版本号。</p><p>而初始化则需要注意，是否开启了<code>tls</code>方法不同，见<code>/opt/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli/scripts/script.sh</code>中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">instantiateChaincode</span></span> () &#123;</span><br><span class="line">    PEER=<span class="variable">$1</span></span><br><span class="line">    setGlobals <span class="variable">$PEER</span></span><br><span class="line">    <span class="comment"># while 'peer chaincode' command can get the orderer endpoint from the peer (if join was successful),</span></span><br><span class="line">    <span class="comment"># lets supply it directly as we know it using the "-o" option</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$CORE_PEER_TLS_ENABLED</span>"</span> -o <span class="string">"<span class="variable">$CORE_PEER_TLS_ENABLED</span>"</span> = <span class="string">"false"</span> ]; <span class="keyword">then</span></span><br><span class="line">        peer chaincode instantiate -o orderer.example.com:7050 -C <span class="variable">$CHANNEL_NAME</span> -n mycc -v 1.0 -c <span class="string">'&#123;"Args":["init","a","100","b","200"]&#125;'</span> -P <span class="string">"OR    ('Org1MSP.member','Org2MSP.member')"</span> &gt;&amp;log.txt</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        peer chaincode instantiate -o orderer.example.com:7050 --tls <span class="variable">$CORE_PEER_TLS_ENABLED</span> --cafile <span class="variable">$ORDERER_CA</span> -C <span class="variable">$CHANNEL_NAME</span> -n mycc -v 1.0 -c <span class="string">'&#123;"Args":["init","a","100","b","200"]&#125;'</span> -P <span class="string">"OR  ('Org1MSP.member','Org2MSP.member')"</span> &gt;&amp;log.txt</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    res=$?</span><br><span class="line">    cat log.txt</span><br><span class="line">    verifyResult <span class="variable">$res</span> <span class="string">"Chaincode instantiation on PEER<span class="variable">$PEER</span> on channel '<span class="variable">$CHANNEL_NAME</span>' failed"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"===================== Chaincode Instantiation on PEER<span class="variable">$PEER</span> on channel '<span class="variable">$CHANNEL_NAME</span>' is successful ===================== "</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如没开启<code>tls</code>初始化代码就是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n mycc -v 1.0 -c &apos;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]&#125;&apos; -P &quot;OR    (&apos;Org1MSP.peer&apos;,&apos;Org2MSP.peer&apos;)&quot;</span><br></pre></td></tr></table></figure><p></p><p>其中，-C指向channel名字，-c则是初始构造json格式的消息，-P是背书策略，-o指定共识节点。这里置帐户a初始余额为100，帐户b初始余额为200。</p><p>每个chaincode都要实现Init和Invoke两个方法，其中前者用于初始化，后者是日常调用。 以我们调用的<code>Example02.go</code>代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ex02 Init"</span>)</span><br><span class="line">_, args := stub.GetFunctionAndParameters() <span class="comment">//获取传入的参数并解析</span></span><br><span class="line"><span class="keyword">var</span> A, B <span class="keyword">string</span>    <span class="comment">// Entities</span></span><br><span class="line"><span class="keyword">var</span> Aval, Bval <span class="keyword">int</span> <span class="comment">// Asset holdings</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">4</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Incorrect number of arguments. Expecting 4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the chaincode</span></span><br><span class="line">A = args[<span class="number">0</span>]</span><br><span class="line">Aval, err = strconv.Atoi(args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Expecting integer value for asset holding"</span>)</span><br><span class="line">&#125;</span><br><span class="line">B = args[<span class="number">2</span>]</span><br><span class="line">Bval, err = strconv.Atoi(args[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Expecting integer value for asset holding"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Aval = %d, Bval = %d\n"</span>, Aval, Bval)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the state to the ledger</span></span><br><span class="line">err = stub.PutState(A, []<span class="keyword">byte</span>(strconv.Itoa(Aval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = stub.PutState(B, []<span class="keyword">byte</span>(strconv.Itoa(Bval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke</code>函数如下，可以理解为所有日常操作的入口：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ex02 Invoke"</span>)</span><br><span class="line">function, args := stub.GetFunctionAndParameters()</span><br><span class="line"><span class="keyword">if</span> function == <span class="string">"invoke"</span> &#123;</span><br><span class="line"><span class="comment">// Make payment of X units from A to B</span></span><br><span class="line"><span class="keyword">return</span> t.invoke(stub, args)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> function == <span class="string">"delete"</span> &#123;</span><br><span class="line"><span class="comment">// Deletes an entity from its state</span></span><br><span class="line"><span class="keyword">return</span> t.<span class="built_in">delete</span>(stub, args)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> function == <span class="string">"query"</span> &#123;</span><br><span class="line"><span class="comment">// the old "Query" is now implemtned in invoke</span></span><br><span class="line"><span class="keyword">return</span> t.query(stub, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Invalid invoke function name. Expecting \"invoke\" \"delete\" \"query\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到实现了3种操作，转帐、删除用户、查询余额。</p><p>先看查询余额，函数定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query callback representing the query of a chaincode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">query</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> A <span class="keyword">string</span> <span class="comment">// Entities</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Incorrect number of arguments. Expecting name of the person to query"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = args[<span class="number">0</span>] <span class="comment">//帐户名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the state from the ledger</span></span><br><span class="line">Avalbytes, err := stub.GetState(A)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">jsonResp := <span class="string">"&#123;\"Error\":\"Failed to get state for "</span> + A + <span class="string">"\"&#125;"</span></span><br><span class="line"><span class="keyword">return</span> shim.Error(jsonResp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Avalbytes == <span class="literal">nil</span> &#123;</span><br><span class="line">jsonResp := <span class="string">"&#123;\"Error\":\"Nil amount for "</span> + A + <span class="string">"\"&#125;"</span></span><br><span class="line"><span class="keyword">return</span> shim.Error(jsonResp)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 返回json格式结果</span></span><br><span class="line">jsonResp := <span class="string">"&#123;\"Name\":\""</span> + A + <span class="string">"\",\"Amount\":\""</span> + <span class="keyword">string</span>(Avalbytes) + <span class="string">"\"&#125;"</span></span><br><span class="line">fmt.Printf(<span class="string">"Query Response:%s\n"</span>, jsonResp)</span><br><span class="line"><span class="keyword">return</span> shim.Success(Avalbytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>先正常从b给a支付50，这里注意我们开启了tls（<em>疑问：查询时候为啥不用指定tls而转帐不指定则会报错？</em>）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o orderer.example.com:7050  --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;b&quot;,&quot;a&quot;,&quot;50&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><p></p><p>查看a的余额：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-06-15 03:31:01.268 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-06-15 03:31:01.268 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-06-15 03:31:01.268 UTC [chaincodeCmd] getChaincodeSpec -&gt; DEBU 005 java chaincode disabled</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: plaintext: 0ABF070A6708031A0C08F5E58CD90510...6D7963631A0A0A0571756572790A0161</span><br><span class="line">2018-06-15 03:31:01.268 UTC [msp/identity] Sign -&gt; DEBU 007 Sign: digest: 6BAE5E272C5A3FD13D3921B98F0C4C35D6BBD6433DD66CFFF42B04561CDBE688</span><br><span class="line">Query Result: 140</span><br></pre></td></tr></table></figure><p></p><p>再看b的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;b&quot;]&#125;&apos;</span><br><span class="line">2018-06-15 03:48:24.458 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-06-15 03:48:24.458 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-06-15 03:48:24.458 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-06-15 03:48:24.458 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-06-15 03:48:24.458 UTC [chaincodeCmd] getChaincodeSpec -&gt; DEBU 005 java chaincode disabled</span><br><span class="line">2018-06-15 03:48:24.459 UTC [msp/identity] Sign -&gt; DEBU 006 Sign: plaintext: 0ABF070A6708031A0C0888EE8CD90510...6D7963631A0A0A0571756572790A0162</span><br><span class="line">2018-06-15 03:48:24.459 UTC [msp/identity] Sign -&gt; DEBU 007 Sign: digest: B422147DF2CBDF964CAFA860B2FEF3E0928F1B317F599188284860D5EA5902A2</span><br><span class="line">Query Result: 160</span><br></pre></td></tr></table></figure><p></p><p>a有140，b有160。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o orderer.example.com:7050  --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;150&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><p></p><p>这里我们从a向b转150，结果也成功执行了，a余额变成-10，因为<code>invoke</code>代码中并没有对余额和转帐金额的大小进行判断。</p><p>转帐函数<code>invoke</code>定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction makes payment of X units from A to B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">invoke</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> A, B <span class="keyword">string</span>    <span class="comment">// Entities</span></span><br><span class="line"><span class="keyword">var</span> Aval, Bval <span class="keyword">int</span> <span class="comment">// Asset holdings</span></span><br><span class="line"><span class="keyword">var</span> X <span class="keyword">int</span>          <span class="comment">// Transaction value</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Incorrect number of arguments. Expecting 3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = args[<span class="number">0</span>] <span class="comment">//转出帐户</span></span><br><span class="line">B = args[<span class="number">1</span>] <span class="comment">//转入帐户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the state from the ledger</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> will be nice to have a GetAllState call to ledger</span></span><br><span class="line">Avalbytes, err := stub.GetState(A)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Failed to get state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> Avalbytes == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Entity not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Aval, _ = strconv.Atoi(<span class="keyword">string</span>(Avalbytes))</span><br><span class="line"></span><br><span class="line">Bvalbytes, err := stub.GetState(B)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Failed to get state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> Bvalbytes == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Entity not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Bval, _ = strconv.Atoi(<span class="keyword">string</span>(Bvalbytes))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform the execution</span></span><br><span class="line">X, err = strconv.Atoi(args[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Invalid transaction amount, expecting a integer value"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//关键在于这里缺少判断</span></span><br><span class="line">Aval = Aval - X</span><br><span class="line">Bval = Bval + X</span><br><span class="line">fmt.Printf(<span class="string">"Aval = %d, Bval = %d\n"</span>, Aval, Bval)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the state back to the ledger</span></span><br><span class="line">err = stub.PutState(A, []<span class="keyword">byte</span>(strconv.Itoa(Aval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = stub.PutState(B, []<span class="keyword">byte</span>(strconv.Itoa(Bval)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样，我们就可以尝试修改这个chaincode并重新安装部署初始化了，具体操作下次记录。</p><hr><p>参考链接：</p><ol><li><a href="http://www.taohui.pub/530.html" target="_blank" rel="noopener">http://www.taohui.pub/530.html</a></li><li><a href="http://nm1024.com/?p=10" target="_blank" rel="noopener">http://nm1024.com/?p=10</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;p&gt;前提需要电脑中存在&lt;code&gt;git&lt;/code&gt;、&lt;code&gt;docker&lt;/code&gt;、&lt;code&gt;docker-compose&lt;/code&gt;命令以及有&lt;code&gt;golang&lt;/code&gt;开发环境。&lt;/p&gt;&lt;p&gt;首先创建目录存放Fabric代码，&lt;strong&gt;注意路径和权限&lt;/strong&gt;，在启动服务时候会向其中写一些文件，最开始我就是没注意到这点报错了。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mkdir /opt/gopath/src/github.com/hyperledger/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入刚才创建的目录后拉取代码：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /opt/gopath/src/github.com/hyperledger&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/hyperledger/fabric.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当前版本是1.1。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Raft算法</title>
    <link href="http://www.hi-roy.com/2018/06/07/Raft%E7%AE%97%E6%B3%95/"/>
    <id>http://www.hi-roy.com/2018/06/07/Raft算法/</id>
    <published>2018-06-07T14:26:33.000Z</published>
    <updated>2019-09-16T08:11:51.469Z</updated>
    
    <content type="html"><![CDATA[<p>相比与Paxos算法，Raft更容易理解。首先推荐个<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">动画视频</a> (注意这个动画真的基于raft算法，所以每次选举出的节点都是不同的，我观看某些章节时候甚至出现过3次选举过程)，然后是<a href="http://www.infoq.com/cn/articles/raft-paper" target="_blank" rel="noopener">raft论文中文版</a>和<a href="https://raft.github.io/" target="_blank" rel="noopener">raft主页</a>，基本结合这3个网站就能理解raft了。</p><p>在Raft算法中，有3种角色：</p><ul><li>Leader</li><li>Follower</li><li>Candidate</li></ul><p>大体分为2个过程：</p><ol><li>选举(Leader Election)</li><li>日志同步(Log Replication)<a id="more"></a></li></ol><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>选举和现实社会中的民主选举制度很像，当Follower超过选举超时时间(election timeout)没收到来自Leader的心跳报文，则成为Candidate，增加任期(Term)并向其他节点发起新的选举请求。接收到请求的节点如果还没投票则投票给该节点，并重置自己的超时时间。如果获取到了超过一半的赞同票，则成为新的Leader。每隔一定时间向Follower发送心跳报文来维持自己的”统治”地位。</p><p>那么，万一有多个节点获得了同样的投票怎么办呢？</p><p>此时则等待各自的超时时间后，增加Term后再次发起投票。解决这个问题的关键在于 <strong>每个节点的election timeout</strong> 是不同的。</p><h2 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h2><p>当选举完成后，客户端进行的操作都要通过Leader来进行。首先Leader接受到客户端发来的操作请求后记录到日志中，此时为uncommitted状态。然后在下一个心跳报文中通知所有Follower，当大多数Follower响应后，Leader响应客户端，进入committed阶段，并向Follower发送通知应用(apply)操作。</p><h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p>如果由于网络分区(network partition)造成同时有多个Leader，这种情况下某些Leader由于获取不到大多数的投票，所以数据永远不会提交成功。当网络故障恢复后，旧的Leader发现有Term更新的Leader存在，则自动降级为Follower并从最新的Leader同步数据达成集群一致。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果在日志同步阶段，Leader响应客户端后进入committed阶段，但没来得及向Follower发送通知就挂掉了，重新选举后这次修改会不会丢失？</p><p>答案是不会丢失。具体解释可以参考<a href="https://stackoverflow.com/questions/34672331/what-will-happen-to-replicated-but-uncommited-logs-in-raft-protocol" target="_blank" rel="noopener">这里</a>。</p><hr><p>最后再推荐一个<a href="https://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">文章</a>，里面关于什么时候Leader挂掉的图解很清晰。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比与Paxos算法，Raft更容易理解。首先推荐个&lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;动画视频&lt;/a&gt; (注意这个动画真的基于raft算法，所以每次选举出的节点都是不同的，我观看某些章节时候甚至出现过3次选举过程)，然后是&lt;a href=&quot;http://www.infoq.com/cn/articles/raft-paper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raft论文中文版&lt;/a&gt;和&lt;a href=&quot;https://raft.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raft主页&lt;/a&gt;，基本结合这3个网站就能理解raft了。&lt;/p&gt;&lt;p&gt;在Raft算法中，有3种角色：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Leader&lt;/li&gt;&lt;li&gt;Follower&lt;/li&gt;&lt;li&gt;Candidate&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大体分为2个过程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;选举(Leader Election)&lt;/li&gt;&lt;li&gt;日志同步(Log Replication)
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-互斥锁</title>
    <link href="http://www.hi-roy.com/2018/06/07/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <id>http://www.hi-roy.com/2018/06/07/GO语言学习笔记-互斥锁/</id>
    <published>2018-06-07T09:42:11.000Z</published>
    <updated>2019-09-16T08:11:51.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/mutex/" target="_blank" rel="noopener">原文</a>，互斥锁(Mutex)也是go并发系列最后一篇文章。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>在说互斥锁前，理解并发编程中的临界区(Critical section)是十分重要的。当一个程序并发执行时，共享资源不应该在同一时刻被多个goroutine修改。这段修改共享资源的代码就叫做临界区。举个例子，我们有一个代码片段用于修改变量x自增１。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x+1</span><br></pre></td></tr></table></figure><p></p><p>如果上面的代码在唯一的goroutine中执行，不会有任何问题。</p><a id="more"></a><p>让我们看看这段代码当多个goroutine并发执行时会有什么问题，为了简单我们假设有2个goroutine。操作系统执行上面代码时候有3步(其实更复杂，比如寄存器、加法如何进行，但这里我们简化成3步)：</p><ol><li>获取当前的x值</li><li>计算x+1</li><li>把上一步的结果赋值给x</li></ol><p>只有一个goroutine时，一切正常。但有2个goroutine并发执行时，下图展示了可能出现的一种情形：</p><p><img src="https://golangbot.com/content/images/2017/08/cs5.png" alt="img1"></p><p>我们假设初始值为0，goroutine1取得了这个值并计算x+1，但当把结果赋值给x前系统切换到了goroutine2，goroutine2也取得初始值0并计算x+1，然后系统切换到goroutine1，将计算的结果1赋值给x。接下来goroutine2继续执行，把其计算结果1赋值给x。因此，所有goroutine执行完成后x值为1。</p><p>下面让我们来看另一种情况：</p><p><img src="https://golangbot.com/content/images/2017/08/cs-6.png" alt="img2"></p><p>上述情况，goroutine1执行所有步骤后将x值变为1，然后goroutine2继续执行，最终x值为2。</p><p>所以最终x值为１还是２取决于context是如何切换的。这种结果取决于执行顺序的情况叫做竞争条件(Race Condition)。</p><p>上述场景中，如果同时刻只准许一个goroutine进入临界区，则竞争条件可以避免。可以使用互斥锁来达到这个目的。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁提供了一种锁机制来保证同一时刻只有一个goroutine访问临界区，这样就可以避免竞争条件了。</p><p>互斥锁位于<code>sync</code>包，提供了<code>Lock</code>和<code>Unlock</code>2个方法，任何被这２个方法包围在其中的代码同一时刻只能被一个goroutine执行，因此可以避免竞争条件了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex.Lock()  </span><br><span class="line">x = x + <span class="number">1</span>  </span><br><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure><p><strong>如果某个goroutine已经获得了锁，其他的goroutine尝试获取锁时将被阻塞，直到锁被释放。</strong></p><h2 id="一段有竞争条件的代码"><a href="#一段有竞争条件的代码" class="headerlink" title="一段有竞争条件的代码"></a>一段有竞争条件的代码</h2><p>我们先写一个有竞争条件的代码，然后解决它：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> x  = <span class="number">0</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)        </span><br><span class="line">        <span class="keyword">go</span> increment(&amp;w)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"final value of x"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>increment</code>函数将x自增1然后调用<code>wg.Done()</code>来通知<code>WaitGroup</code>完成，然后通过循环生成1000个goroutine，每个goroutine都是并发执行并且并发获取x的值。多次运行程序，你会发现结果每次都不同，比如<code>value of x 941</code>，<code>final value of x 928</code>，<code>final value of x 922</code>等。</p><h2 id="使用互斥锁解决问题"><a href="#使用互斥锁解决问题" class="headerlink" title="使用互斥锁解决问题"></a>使用互斥锁解决问题</h2><p>上面的代码我们生成1000个goroutine，如果每个自增1，结果应该是1000。这里我们使用互斥锁来解决问题。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> x  = <span class="number">0</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;  </span><br><span class="line">    m.Lock()</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    m.Unlock()</span><br><span class="line">    wg.Done()   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)        </span><br><span class="line">        <span class="keyword">go</span> increment(&amp;w, &amp;m)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"final value of x"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>互斥锁是一种<code>struct</code>类型，我们创建了一个默认值互斥锁<code>m</code>，并把其地址传递给了<code>increment</code>，同时把<code>x=x+1</code>这句代码放在<code>m.Lock()</code>和<code>m.Unlock()</code>之间。这样就只有一个goroutine能在同一时刻执行这句代码了。程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final value of x 1000</span><br></pre></td></tr></table></figure><h2 id="使用channel解决问题"><a href="#使用channel解决问题" class="headerlink" title="使用channel解决问题"></a>使用channel解决问题</h2><p>我们也可以使用channel，代码如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> x  = <span class="number">0</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup, ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="literal">true</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    &lt;- ch</span><br><span class="line">    wg.Done()   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)        </span><br><span class="line">        <span class="keyword">go</span> increment(&amp;w, ch)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"final value of x"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码中，我们创建了一个容量为1的带缓冲区的channel并且传递给函数<code>increment</code>，这个缓冲区channel用来确保同时刻只有一个goroutine能进入临界区操作x。先向channel中写入值，由于容量为1，所以其他goroutine将被阻塞。自增操作完成后在从channel中去读数据解除阻塞。这也是控制多个goroutine访问临界区的有效办法。</p><p>程序输出和上面一样。</p><h2 id="互斥锁-vs-Channel"><a href="#互斥锁-vs-Channel" class="headerlink" title="互斥锁 vs Channel"></a>互斥锁 vs Channel</h2><p>(roy注:这段我就选重点翻译了)</p><p>互斥锁和Channel都能解决上述问题，那么什么时候用哪个呢？</p><p><strong>如果各个goroutine之间需要通信，选择channel。否则，选择互斥锁。</strong></p><hr><p>另外下面有评论说goroutine数量多的时候互斥锁更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/mutex/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，互斥锁(Mutex)也是go并发系列最后一篇文章。&lt;/p&gt;&lt;h2 id=&quot;临界区&quot;&gt;&lt;a href=&quot;#临界区&quot; class=&quot;headerlink&quot; title=&quot;临界区&quot;&gt;&lt;/a&gt;临界区&lt;/h2&gt;&lt;p&gt;在说互斥锁前，理解并发编程中的临界区(Critical section)是十分重要的。当一个程序并发执行时，共享资源不应该在同一时刻被多个goroutine修改。这段修改共享资源的代码就叫做临界区。举个例子，我们有一个代码片段用于修改变量x自增１。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x = x+1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果上面的代码在唯一的goroutine中执行，不会有任何问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-Select</title>
    <link href="http://www.hi-roy.com/2018/06/07/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Select/"/>
    <id>http://www.hi-roy.com/2018/06/07/GO语言学习笔记-Select/</id>
    <published>2018-06-07T08:54:28.000Z</published>
    <updated>2019-09-16T08:11:51.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/select/" target="_blank" rel="noopener">原文</a></p><h2 id="什么是Select"><a href="#什么是Select" class="headerlink" title="什么是Select"></a>什么是Select</h2><p><code>select</code>语法用来从多个读／写的channel中选择一个，如果没有任何channel就绪select语句将被阻塞。如果多个就绪，则随机选择一个。语法和<code>switch</code>类似，除了case后面跟随的是channel。</p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">"from server1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">"from server2"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> server1(output1)</span><br><span class="line">    <span class="keyword">go</span> server2(output2)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">        fmt.Println(s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">        fmt.Println(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中<code>server1</code>在6秒钟后向<code>ch</code>写入数据，而<code>server2</code>则3秒钟后写入。<code>main</code>函数中启动这2个goroutine，然后程序阻塞在<code>select</code>处，直到满足一个case的条件。所以程序等待3秒钟后会输出<code>from server2</code>后结束。</p><h2 id="select实践"><a href="#select实践" class="headerlink" title="select实践"></a>select实践</h2><p>假设我们有一个重要的程序需要尽快的返回数据给用户，而数据库是分布式的并且处于世界不同的地方。上面例子中的server1和server2就是这样，响应速度取决于每个服务器的负载和网络延迟，我们向所有服务器发请求，然后使用<code>select</code>来选择接受哪个服务的响应。除了第一个响应外其他的将被忽略，这样我们就可以在多个服务器中选择响应最快的那个结果返回给用户了。</p><h2 id="默认case"><a href="#默认case" class="headerlink" title="默认case"></a>默认case</h2><p><code>select</code>中的默认case将在没有任何其他case满足的情况下被执行，这通常用来阻止<code>select</code>语句阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">10500</span> * time.Millisecond)</span><br><span class="line">    ch &lt;- <span class="string">"process successful"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> process(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">"received value: "</span>, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"no value received"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>process</code>函数等待10.5秒后向<code>ch</code>写入<code>process successful</code>，执行<code>process</code>的goroutine后程序进入死循环，每秒钟尝试一次读取channel中的数据。在10.5秒钟之前程序会进入<code>default</code>分支，之后进入到<code>case v := &lt;-ch</code>分支并跳出循环，所以程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">no value received  </span><br><span class="line">received value:  process successful</span><br></pre></td></tr></table></figure><p></p><h2 id="死锁和默认case"><a href="#死锁和默认case" class="headerlink" title="死锁和默认case"></a>死锁和默认case</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我们创建了一个channel并尝试在<code>select</code>中读取数据，因为没有任何goroutine向其写入数据，<code>select</code>将永远阻塞下去导致死锁，报错如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan receive]:  </span><br><span class="line">main.main()  </span><br><span class="line">    /tmp/sandbox416567824/main.go:6 +0x80</span><br></pre></td></tr></table></figure><p></p><p>如果提供了默认case，程序将不会死锁：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"default case executed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default case executed</span><br></pre></td></tr></table></figure><p></p><p>类似的，如果是一个空channel(roy注:之前学channel时候说过，channel没使用make创建时的值是nil)，默认case也会被执行：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">"received value"</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"default case executed"</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述代码中我们尝试从<code>nil</code>的channel中读取数据，如果没有<code>default</code>，程序将死锁。</p><p>##　随机选择<br>当<code>select</code>中多个case都满足时，将随即选择一个：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="string">"from server1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="string">"from server2"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> server1(output1)</span><br><span class="line">    <span class="keyword">go</span> server2(output2)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">        fmt.Println(s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">        fmt.Println(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述代码中，由于main函数中等待了1秒钟，所以<code>server1</code>和<code>server2</code>都有充足的时间执行完毕，即2个case都满足。如果你多次运行这个程序，输出将在<code>from server1</code>和<code>from server2</code>随机选择。</p><h2 id="空select"><a href="#空select" class="headerlink" title="空select"></a>空select</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你觉得上面的程序输出什么？</p><p>我们知道<code>select</code>将被阻塞直到一个case满足，但上面的<code>select</code>没有任何case，因此程序将死锁，报错如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [select (no cases)]:  </span><br><span class="line">main.main()  </span><br><span class="line">    /tmp/sandbox299546399/main.go:4 +0x20</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/select/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;什么是Select&quot;&gt;&lt;a href=&quot;#什么是Select&quot; class=&quot;headerlink&quot; title=&quot;什么是Select&quot;&gt;&lt;/a&gt;什么是Select&lt;/h2&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;语法用来从多个读／写的channel中选择一个，如果没有任何channel就绪select语句将被阻塞。如果多个就绪，则随机选择一个。语法和&lt;code&gt;switch&lt;/code&gt;类似，除了case后面跟随的是channel。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-缓冲区Channels和线程池</title>
    <link href="http://www.hi-roy.com/2018/06/04/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BC%93%E5%86%B2%E5%8C%BAChannels%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.hi-roy.com/2018/06/04/GO语言学习笔记-缓冲区Channels和线程池/</id>
    <published>2018-06-04T14:11:55.000Z</published>
    <updated>2019-09-16T08:11:51.458Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/buffered-channels-worker-pools/" target="_blank" rel="noopener">原文</a>，这里为了方便理解我把worker pools翻译成线程池。</p><h2 id="什么是缓冲区Channel"><a href="#什么是缓冲区Channel" class="headerlink" title="什么是缓冲区Channel"></a>什么是缓冲区Channel</h2><p>之前讨论的所有channel都是不带缓冲区的，因此读取和写入都会被阻塞。创建一个带缓冲区的channel也是可能的，这种channel只有在缓冲区满后再写入或者读取一个空的channel时才会被阻塞。</p><p>创建一个带缓冲区的channel需要一个额外的参数容量来表明缓冲区大小：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, capacity)</span><br></pre></td></tr></table></figure><p></p><p>上面代码中的 <em>capacity</em>　需要大于０，如果等于０的话则是之前学习的无缓冲区channel。</p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="string">"naveen"</span></span><br><span class="line">    ch &lt;- <span class="string">"paul"</span></span><br><span class="line">    fmt.Println(&lt;- ch)</span><br><span class="line">    fmt.Println(&lt;- ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们创建了一个容量为2的channel，所以在写入２个字符串之前的写操作不会被阻塞。然后分别在12、13行读取，程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">naveen  </span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p></p><h2 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h2><p>我们再来看一个例子，我们在并发执行的goroutine中进行写操作，然后在main goroutine中读取，这个例子帮助我们更好的理解缓冲区channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">        fmt.Println(<span class="string">"successfully wrote"</span>, i, <span class="string">"to ch"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> write(ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read value"</span>, v,<span class="string">"from ch"</span>)</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，我们创建了一个容量是2的缓冲区channel，并把它作为参数传递给<code>write</code>函数，接下来sleep2秒钟。同时<code>write</code>函数并发的执行，在函数中使用<code>for</code>循环向<code>ch</code>写入0-4。由于容量是2，所以可以立即向channel中写入0和１，然后阻塞等待至少一个值被读取。所以程序会立即输出下面２行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">successfully wrote 0 to ch  </span><br><span class="line">successfully wrote 1 to ch</span><br></pre></td></tr></table></figure><p></p><p>当main函数中sleep２秒后，进入<code>for range</code>循环中开始读取数据，然后继续sleep２秒钟。所以程序接下来会输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read value 0 from ch  </span><br><span class="line">successfully wrote 2 to ch</span><br></pre></td></tr></table></figure><p></p><p>如此循环直到channel被关闭为止，程序最终输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">successfully wrote 0 to ch  </span><br><span class="line">successfully wrote 1 to ch  </span><br><span class="line">read value 0 from ch  </span><br><span class="line">successfully wrote 2 to ch  </span><br><span class="line">read value 1 from ch  </span><br><span class="line">successfully wrote 3 to ch  </span><br><span class="line">read value 2 from ch  </span><br><span class="line">successfully wrote 4 to ch  </span><br><span class="line">read value 3 from ch  </span><br><span class="line">read value 4 from ch</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="string">"naveen"</span></span><br><span class="line">    ch &lt;- <span class="string">"paul"</span></span><br><span class="line">    ch &lt;- <span class="string">"steve"</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序，我们想向容量为2的channel中写入３个字符串。程序执行到１１行时候将会被阻塞，因为此时channel缓冲区已经满了。如果没有其他goroutine从中读取数据，程序将会死锁。报错如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:  </span><br><span class="line">main.main()  </span><br><span class="line">    /tmp/sandbox274756028/main.<span class="keyword">go</span>:<span class="number">11</span> +<span class="number">0x100</span></span><br></pre></td></tr></table></figure><p></p><h2 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h2><p>容量是指一个有缓冲区的channel能够最多同时存储多少数据，这个值在使用<code>make</code>关键字用在创建channel时。而长度则是指当前channel中已经存放了多少个数据。我们看下面的代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="string">"naveen"</span></span><br><span class="line">    ch &lt;- <span class="string">"paul"</span></span><br><span class="line">    fmt.Println(<span class="string">"capacity is"</span>, <span class="built_in">cap</span>(ch))</span><br><span class="line">    fmt.Println(<span class="string">"length is"</span>, <span class="built_in">len</span>(ch))</span><br><span class="line">    fmt.Println(<span class="string">"read value"</span>, &lt;-ch)</span><br><span class="line">    fmt.Println(<span class="string">"new length is"</span>, <span class="built_in">len</span>(ch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码中我们创建了一个容量为3的channel，然后向里面写入2个字符串，因此现在channel的长度是２。接下来从channel中读取１个字符串，所以现在长度是１。程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capacity is 3  </span><br><span class="line">length is 2  </span><br><span class="line">read value naveen  </span><br><span class="line">new length is 1</span><br></pre></td></tr></table></figure><p></p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>下一节我们将要介绍线程池(worker pools)，为了更好的理解，我们需要先介绍<code>WaitGroup</code>，然后我们基于这个实现线程池。</p><p>WaitGroup用来等待一组goroutine都执行完毕，在这之前程序都会被阻塞。假设我们有３个goroutine，主程序会等待这3个goroutine都执行结束才会退出。不多说看代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"started Goroutine "</span>, i)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">"Goroutine %d ended\n"</span>, i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    no := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; no; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> process(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"All go routines finished executing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><a href="https://golang.org/pkg/sync/#WaitGroup" target="_blank" rel="noopener">WaitGroup</a>是一种struct类型，我们在18行创建了一个默认值的WaitGroup，其内部是基于计数器实现的。我们调用<code>Add</code>方法并传递给其一个数字作为参数，计数器将增长传入参数的值。当调用<code>Done</code>方法，计数器将自减１。<code>Wait</code>方法阻塞goroutine直到计数器归零。</p><p>上面的代码中通过在循环中调用<code>wg.Add(1)</code>来使计数器变成3，同时启动3个goroutine，然后掉用<code>wg.Wait()</code>阻塞主goroutine，直到计数器归零。在函数<code>process</code>中，调用<code>wg.Done()</code>来减小计数器，一旦三个goroutine执行结束，<code>wg.Done()</code>将被执行3次，计数器归零，主goroutine解除阻塞。</p><p><strong>传递<code>wg</code>的地址给goroutine是非常重要的！如果传递的不是地址，那么每个goroutine都将有一份拷贝，这样的话每个goroutine结束就不能通知到<code>main</code>函数了。</strong></p><p>程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">started Goroutine  2  </span><br><span class="line">started Goroutine  0  </span><br><span class="line">started Goroutine  1  </span><br><span class="line">Goroutine 0 ended  </span><br><span class="line">Goroutine 2 ended  </span><br><span class="line">Goroutine 1 ended  </span><br><span class="line">All go routines finished executing</span><br></pre></td></tr></table></figure><p></p><p>你的输出结果可能和上面略有不同。</p><h2 id="线程池-worker-pools"><a href="#线程池-worker-pools" class="headerlink" title="线程池(worker pools)"></a>线程池(worker pools)</h2><p>缓冲区channel一个重要的使用方法就是实现线程池。</p><p>通常来说，线程池就是一组线程的集合等待任务分配给他们，一旦完成任务，则继续等待下一个任务。</p><p>接下来我们实现一个线程池，来计算输入数字每一位的和。比如输入１２３，则返回９(1+2+3)，输入给线程池的数字由伪随机算法生成。</p><p>下面是我们需要的核心步骤：</p><ul><li>创建一组goroutine集合监听缓冲区channel等待任务。</li><li>向缓冲区channel添加任务。</li><li>任务结束后向另一个缓冲区channel写入结果。</li><li>从存储结果的channel读取数据并输出。</li></ul><p>首先我们创建存储任务和结果的结构：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;  </span><br><span class="line">    id       <span class="keyword">int</span></span><br><span class="line">    randomno <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;  </span><br><span class="line">    job         Job</span><br><span class="line">    sumofdigits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>每个<code>Job</code>都有一个<code>id</code>和一个<code>randomno</code>用来存储将要计算的随机数。而<code>Result</code>类型则包括<code>Job</code>属性和<code>sumofdigits</code>存储结果。</p><p>接下来创建缓冲区channel来接收任务和结果：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">10</span>)  </span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>goroutine从jobs中获取任务，并向results写入结果。</p><p>下面的<code>digits</code>函数用来计算求和并且返回结果，我们通过<code>Sleep</code>来模拟进行耗时的计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digits</span><span class="params">(number <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    no := number</span><br><span class="line">    <span class="keyword">for</span> no != <span class="number">0</span> &#123;</span><br><span class="line">        digit := no % <span class="number">10</span></span><br><span class="line">        sum += digit</span><br><span class="line">        no /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的函数创建goroutine：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        output := Result&#123;job, digits(job.randomno)&#125;</span><br><span class="line">        results &lt;- output</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过读取<code>jobs</code>中的任务来创建<code>Result</code>结构，并存储函数<code>digits</code>计算后的结果，然后再将其写入<code>results</code>这个channel。这个函数接收一个WaitGroup类型的指针参数<code>wg</code>，并且在计算完成后调用<code>wg.Done()</code>。</p><p><code>createWorkerPool</code>这个函数用来创建线程池：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorkerPool</span><span class="params">(noOfWorkers <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfWorkers; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这个函数创建了包含<code>noOfWorkers</code>个goroutine的线程池，创建goroutine之前调用<code>wg.Add(1)</code>来增加计数器，然后将<code>wg</code>的地址传递给<code>worker</code>函数。创建完成后，使用<code>wg.Wait()</code>等待所有的goroutine执行完毕，然后又调用<code>close</code>函数关闭<code>results</code>这个channel，这样以后就没有任何goroutine能写入数据了。</p><p>接下来，我们来编写函数向线程池分配任务：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(noOfJobs <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfJobs; i++ &#123;</span><br><span class="line">        randomno := rand.Intn(<span class="number">999</span>)</span><br><span class="line">        job := Job&#123;i, randomno&#125;</span><br><span class="line">        jobs &lt;- job</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这个函数通过传入的参数决定写入的任务数量，随机数最大值是<code>998</code>，并且使用循环中的计数器<code>i</code>作为ID来创建<code>job</code>结构并写入<code>jobs</code>，完成后关闭<code>jobs</code>。</p><p>接下来创建函数读取<code>results</code>这个channel并且打印输出:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">result</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Job id %d, input random no %d , sum of digits %d\n"</span>, result.job.id, result.job.randomno, result.sumofdigits)</span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这个函数读取<code>results</code>并且打印id、随机数和结果，最后向<code>done</code>这个channel写入数据表明其已经打印了全部的结果。</p><p>万事具备，让我们完成<code>main</code>函数：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    noOfJobs := <span class="number">100</span></span><br><span class="line">    <span class="keyword">go</span> allocate(noOfJobs)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> result(done)</span><br><span class="line">    noOfWorkers := <span class="number">10</span></span><br><span class="line">    createWorkerPool(noOfWorkers)</span><br><span class="line">    &lt;-done</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    diff := endTime.Sub(startTime)</span><br><span class="line">    fmt.Println(<span class="string">"total time taken "</span>, diff.Seconds(), <span class="string">"seconds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先我们记录程序开始执行的时间，最后用结束时间减去开始时间计算程序运行时常，我们需要这个时常来比较不同数量的线程池的差异。</p><p>创建名为<code>done</code>的channel，并传递给<code>result</code>函数，这样就可以打印输出并且在完成全部输出后得到通知了。</p><p>最后创建了10个goroutine的线程池，并通过读取<code>done</code>来等待计算全部完成。</p><p>完整代码如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;  </span><br><span class="line">    id       <span class="keyword">int</span></span><br><span class="line">    randomno <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;  </span><br><span class="line">    job         Job</span><br><span class="line">    sumofdigits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">10</span>)  </span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digits</span><span class="params">(number <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    no := number</span><br><span class="line">    <span class="keyword">for</span> no != <span class="number">0</span> &#123;</span><br><span class="line">        digit := no % <span class="number">10</span></span><br><span class="line">        sum += digit</span><br><span class="line">        no /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        output := Result&#123;job, digits(job.randomno)&#125;</span><br><span class="line">        results &lt;- output</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorkerPool</span><span class="params">(noOfWorkers <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfWorkers; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(noOfJobs <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfJobs; i++ &#123;</span><br><span class="line">        randomno := rand.Intn(<span class="number">999</span>)</span><br><span class="line">        job := Job&#123;i, randomno&#125;</span><br><span class="line">        jobs &lt;- job</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">result</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Job id %d, input random no %d , sum of digits %d\n"</span>, result.job.id, result.job.randomno, result.sumofdigits)</span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    noOfJobs := <span class="number">100</span></span><br><span class="line">    <span class="keyword">go</span> allocate(noOfJobs)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> result(done)</span><br><span class="line">    noOfWorkers := <span class="number">10</span></span><br><span class="line">    createWorkerPool(noOfWorkers)</span><br><span class="line">    &lt;-done</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    diff := endTime.Sub(startTime)</span><br><span class="line">    fmt.Println(<span class="string">"total time taken "</span>, diff.Seconds(), <span class="string">"seconds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Job id 1, input random no 636, sum of digits 15  </span><br><span class="line">Job id 0, input random no 878, sum of digits 23  </span><br><span class="line">Job id 9, input random no 150, sum of digits 6  </span><br><span class="line">...</span><br><span class="line">total time taken  20.01081009 seconds</span><br></pre></td></tr></table></figure><p></p><p>程序会有100行的输出，因为我们创建了100个job，你的输出顺序可能和我不同，并且时间也可能不一样，这取决于硬件配置。在我这总共用时20秒。</p><p>接下来提高<code>noOfWorkers</code>到20，我们提高了线程池中goroutine的数量(翻了一倍)，运行时间绝对应该减少(接近一半)。在我的机器上，程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">total time taken  10.004364685 seconds</span><br></pre></td></tr></table></figure><p></p><p>这样我们可以明白了，线程池中goroutine增加会让程序运行时间减少。你可以随意调整<code>main</code>中的<code>noOfJobs</code>和<code>noOfWorkers</code>的值来分析结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/buffered-channels-worker-pools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，这里为了方便理解我把worker pools翻译成线程池。&lt;/p&gt;&lt;h2 id=&quot;什么是缓冲区Channel&quot;&gt;&lt;a href=&quot;#什么是缓冲区Channel&quot; class=&quot;headerlink&quot; title=&quot;什么是缓冲区Channel&quot;&gt;&lt;/a&gt;什么是缓冲区Channel&lt;/h2&gt;&lt;p&gt;之前讨论的所有channel都是不带缓冲区的，因此读取和写入都会被阻塞。创建一个带缓冲区的channel也是可能的，这种channel只有在缓冲区满后再写入或者读取一个空的channel时才会被阻塞。&lt;/p&gt;&lt;p&gt;创建一个带缓冲区的channel需要一个额外的参数容量来表明缓冲区大小：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;, capacity)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面代码中的 &lt;em&gt;capacity&lt;/em&gt;　需要大于０，如果等于０的话则是之前学习的无缓冲区channel。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-Channels</title>
    <link href="http://www.hi-roy.com/2018/06/04/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Channels/"/>
    <id>http://www.hi-roy.com/2018/06/04/GO语言学习笔记-Channels/</id>
    <published>2018-06-04T06:24:51.000Z</published>
    <updated>2019-09-16T08:11:51.455Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/channels/" target="_blank" rel="noopener">原文</a>，建议先看完goroutine部分再看这篇。</p><h2 id="什么是channels"><a href="#什么是channels" class="headerlink" title="什么是channels"></a>什么是channels</h2><p>channels可以理解成是goroutine之间通信的管道，和水流从管道的一端到另一端类似，数据也可以从管道的一端发送另一端接收。</p><a id="more"></a><h2 id="声明channels"><a href="#声明channels" class="headerlink" title="声明channels"></a>声明channels</h2><p>每个channel都需指定一个类型，这个类型是表明哪种类型的数据可以通过管道传输，而其他类型的不可以。</p><p><code>chan T</code>指接受类型T的channel。</p><p>channel的默认值是<code>nil</code>，<code>nil channel</code>不能被任何类型使用所以和<code>map</code>或者<code>slices</code>一样，要使用<code>make</code>关键字来进行定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"channel a is nil, going to define it"</span>)</span><br><span class="line">        a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"Type of a is %T"</span>, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面声明了变量名为<code>a</code>的channel，并且默认值是<code>nil</code>，因此判断语句成立并且初始化类型为<code>int</code>的channel，程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel a is nil, going to define it  </span><br><span class="line">Type of a is chan int</span><br></pre></td></tr></table></figure><p></p><p>通常我们使用一种更简洁的办法：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p></p><!-- more --><h2 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h2><p>语法如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data := &lt;- a <span class="comment">// read from channel a  </span></span><br><span class="line">a &lt;- data <span class="comment">// write to channel a</span></span><br></pre></td></tr></table></figure><p></p><p>箭头指向的方向表明了是读取还是接收数据。第一行，箭头向外指出，所以代表从<code>a</code>中读取数据并赋值给<code>data</code>变量。第二行，箭头指向<code>a</code>因此是向<code>a</code>中写入数据。</p><h2 id="读写默认是阻塞行为"><a href="#读写默认是阻塞行为" class="headerlink" title="读写默认是阻塞行为"></a>读写默认是阻塞行为</h2><p>对channel进行读写操作默认是阻塞的，什么意思呢？当向channel写入数据时，程序被阻塞在写数据的语句处，直到有其他的goroutine从channel中读取。同样的，当从channel中读数据也会阻塞直到其他goroutine向其中写数据。</p><p>这种特性帮助goroutine之间进行高效通信，而不用像其他编程语言中那样使用显示声明锁或者条件变量来实现。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>说完理论，我们来编写代码看看goroutine如何使用channel进行通信。我们先复习一下上一篇学习goroutine中的代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"Hello world goroutine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"main function"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们使用<code>Sleep</code>来阻塞了<code>main goroutine</code>等待<code>hello goroutine</code>执行完毕，如果你对这个不理解，请看<a href="http://www.hi-roy.com/2018/06/01/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Goroutines/">前一篇文章</a>。</p><p>我们使用channel重写一下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"Hello world goroutine"</span>)</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> hello(done)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">"main function"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面程序中我们创建了名为<code>done</code>的布尔型channel并作为参数传递给了<code>hello</code>这个goroutine，１４行我们从<code>done</code>中读取数据，这行代码将被阻塞直到其他的goroutine向其中写入数据，因此不再需要<code>Sleep</code>来阻止<code>main goroutine</code>继续执行了。</p><p><code>&lt;-done</code>这行代码从channel中读取数据但不使用任何变量存储，这是符合语法的。</p><p>现在<code>main goroutine</code>被阻塞，等待<code>done</code>中的数据，<code>hello</code>接收这个channel作为参数， 输出<code>Hello world goroutine</code>并且向<code>done</code>中写数据。当写入完成后，<code>main goroutine</code>从<code>done</code>中读取数据并且解除阻塞，接下来打印<code>main function</code>。</p><p>程序输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello world goroutine  </span><br><span class="line">main function</span><br></pre></td></tr></table></figure><p></p><p>再次引入<code>Sleep</code>来更好的理解阻塞的概念：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"hello go routine is going to sleep"</span>)</span><br><span class="line">    time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"hello go routine awake and going to write to done"</span>)</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Main going to call hello go goroutine"</span>)</span><br><span class="line">    <span class="keyword">go</span> hello(done)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">"Main received data"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中我们在<code>hello</code>中sleep４秒钟。</p><p>程序首先会输出<code>Main going to call hello go goroutine</code>并且启动goroutine并输出<code>hello go routine is going to sleep</code>。之后<code>hello goroutine</code>被阻塞4秒钟，与此同时<code>main goroutine</code>也会被阻塞，因为它需要在<code>done</code>中读取数据。４秒钟后将输出<code>ello go routine awake and going to write to done</code>和<code>Main received data</code>。</p><h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>让我们来写一个更复杂的例子来理解channel，这个程序要求，输入一个数字，输出其每一位的平方和与立方和，并对这２者求和。比如我们输入123，则</p><p>squares = (1 <em>1) + (2 </em>2) + (3 * 3)</p><p>cubes = (1 <em>1 </em>1) + (2 <em>2 </em>2) + (3 <em>3 </em>3)</p><p>output = squares + cubes = 50</p><p>我们分别在<code>squares goroutine</code>和<code>cubes goroutine</code>中进行计算，并在<code>main goroutine</code>中进行最后求和。(roy注：可以先自己实现再看下面的答案)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcSquares</span><span class="params">(number <span class="keyword">int</span>, squareop <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        sum += digit * digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    squareop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCubes</span><span class="params">(number <span class="keyword">int</span>, cubeop <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        sum += digit * digit * digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    cubeop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    number := <span class="number">589</span></span><br><span class="line">    sqrch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    cubech := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> calcSquares(number, sqrch)</span><br><span class="line">    <span class="keyword">go</span> calcCubes(number, cubech)</span><br><span class="line">    squares, cubes := &lt;-sqrch, &lt;-cubech</span><br><span class="line">    fmt.Println(<span class="string">"Final output"</span>, squares + cubes)</span><br><span class="line">    <span class="comment">//　fmt.Println("Final output ", &lt;-sqrch+&lt;-cubech)　roy注　直接读出来也行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calcSquares</code>和<code>calcCubes</code>进行并发计算并把结果存储到相应的channel中，<code>main goroutine</code>等待计算结果完成后输出：</p><p><code>Final output 1536</code></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>使用channel中一个非常重要的问题就是死锁，如果一个goroutine向channel中写入了数据，那么应该有其他的goroutine读取数据。如果没有，程序将报错<code>Deadlock</code>。类似的，如果goroutine等待从channel中读取数据，那么应该有其他的goroutine向channel中写入数据，否则程序也将报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了channel <code>ch</code>并向其中写入5，但并没有goroutine从<code>ch</code>中读取数据，所以程序报错：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:  </span><br><span class="line">main.main()  </span><br><span class="line">    /tmp/sandbox249677995/main.go:6 +0x80</span><br></pre></td></tr></table></figure><p></p><h2 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h2><p>至今我们讨论的channel都是双向的，既可以写入也可读取数据。创建单向channel也是可以的，单向channel只能写入或者读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(sendch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    sendch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    sendch := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sendData(sendch)</span><br><span class="line">    fmt.Println(&lt;-sendch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们创建了一个只能写入数据的单向channel。<code>chan&lt;- int</code>这个符号表明只能向这个channel写入数据，１２行我们尝试从这个channel中读取数据，程序将会报错：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.go:11: invalid operation: &lt;-sendch (receive from send-only type chan&lt;- int)</span><br></pre></td></tr></table></figure><p></p><p>但是呢，这种只能写入不能读取的channel有毛用啊？</p><p>有一种使用情况就是在channel转换时。我们可以将双向channel转换成单向channel，但反过来则不可以。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(sendch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    sendch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    chnl := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sendData(chnl)</span><br><span class="line">    fmt.Println(&lt;-chnl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面程序中我们创建了一个双向channel <code>chnl</code>，并把他作为参数传递给<code>sendData</code>，第５行函数通过<code>sendch chan&lt;- int</code>将其转换为单向channel，所以在函数内部这个channel只能写入数据，而在<code>main</code>函数里<code>chnl</code>依然是个双向channel。程序将输出<code>10</code>。</p><h2 id="关闭channel和range循环"><a href="#关闭channel和range循环" class="headerlink" title="关闭channel和range循环"></a>关闭channel和range循环</h2><p>发送方可以关闭channel来通知接收方没有更多数据传递了，而接收方可以使用额外的变量获取channel是否被关闭。</p><p><code>v, ok := &lt;- ch</code></p><p>上面的代码中，如果<code>ok</code>的值是true则代表成功从channel获取到了值，为false则代表从一个已经关闭了的channel中读取数据，读取到的值为channel类型的默认值。比如从关闭的int类型的channel读取到的值是<code>0</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(chnl <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        chnl &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(chnl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, ok := &lt;-ch</span><br><span class="line">        <span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Received "</span>, v, ok)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序<code>producer</code>向<code>chnl</code>中写入0-9后关闭channel，<code>main</code>中使用<code>for</code>循环来检查channel是否被关闭，如果<code>ok</code>值为false则代表channel被关闭并且跳出循环，否则输出读取的值和<code>ok</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Received  0 true  </span><br><span class="line">Received  1 true  </span><br><span class="line">Received  2 true  </span><br><span class="line">Received  3 true  </span><br><span class="line">Received  4 true  </span><br><span class="line">Received  5 true  </span><br><span class="line">Received  6 true  </span><br><span class="line">Received  7 true  </span><br><span class="line">Received  8 true  </span><br><span class="line">Received  9 true</span><br></pre></td></tr></table></figure><p></p><p>可以使用<code>for range</code>来读取数据直到channel被关闭：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(chnl <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        chnl &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(chnl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Received "</span>,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一旦channel关闭，循环将自动结束。程序输出和上面一样。</p><p>我们可以使用<code>for range</code>重写上面求和的程序来提高可重用性。如果你仔细观察，你将注意到从数字中提取某一位的代码是重复的，我们将这一步提取出来：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digits</span><span class="params">(number <span class="keyword">int</span>, dchnl <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        dchnl &lt;- digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(dchnl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcSquares</span><span class="params">(number <span class="keyword">int</span>, squareop <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    dch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> digits(number, dch)</span><br><span class="line">    <span class="keyword">for</span> digit := <span class="keyword">range</span> dch &#123;</span><br><span class="line">        sum += digit * digit</span><br><span class="line">    &#125;</span><br><span class="line">    squareop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCubes</span><span class="params">(number <span class="keyword">int</span>, cubeop <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    dch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> digits(number, dch)</span><br><span class="line">    <span class="keyword">for</span> digit := <span class="keyword">range</span> dch &#123;</span><br><span class="line">        sum += digit * digit * digit</span><br><span class="line">    &#125;</span><br><span class="line">    cubeop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    number := <span class="number">589</span></span><br><span class="line">    sqrch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    cubech := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> calcSquares(number, sqrch)</span><br><span class="line">    <span class="keyword">go</span> calcCubes(number, cubech)</span><br><span class="line">    squares, cubes := &lt;-sqrch, &lt;-cubech</span><br><span class="line">    fmt.Println(<span class="string">"Final output"</span>, squares+cubes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>digits</code>函数包含提取数字逻辑并且被<code>calcSquares</code>和<code>calcCubes</code>函数并发调用，一旦没有更多位数需要提取，channel将被关闭。<code>calcSquares</code>和<code>calcCubes</code>函数各自使用<code>for range</code>循环读取channel中的数据，直到其被关闭。其他部分是一样的，程序将输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final output 1536</span><br></pre></td></tr></table></figure><p></p><p>接下来我们还要介绍关于channel更多的概念，比如<code>buffered channels</code>、<code>worker pools</code>、<code>select</code>，欢迎持续关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/channels/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，建议先看完goroutine部分再看这篇。&lt;/p&gt;&lt;h2 id=&quot;什么是channels&quot;&gt;&lt;a href=&quot;#什么是channels&quot; class=&quot;headerlink&quot; title=&quot;什么是channels&quot;&gt;&lt;/a&gt;什么是channels&lt;/h2&gt;&lt;p&gt;channels可以理解成是goroutine之间通信的管道，和水流从管道的一端到另一端类似，数据也可以从管道的一端发送另一端接收。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-Goroutines</title>
    <link href="http://www.hi-roy.com/2018/06/01/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Goroutines/"/>
    <id>http://www.hi-roy.com/2018/06/01/GO语言学习笔记-Goroutines/</id>
    <published>2018-06-01T03:51:33.000Z</published>
    <updated>2019-09-16T08:11:51.455Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/goroutines/" target="_blank" rel="noopener">原文</a>，建议理解并发(concurrency)、并行(parallelism)区别后再看这方面的内容。</p><h2 id="Goroutines是啥？"><a href="#Goroutines是啥？" class="headerlink" title="Goroutines是啥？"></a>Goroutines是啥？</h2><p>Goroutines是一个可以和其他函数或方法并发执行的函数或方法。也可以把它理解为轻量级的线程(roy注:这话听起来和大python中的协程很像啊！)，而创建Goroutine的开销却远远小于线程。因此在大多数的Go程序都可以并发执行成千上万的Goroutine。</p><a id="more"></a><h2 id="Goroutines的优势"><a href="#Goroutines的优势" class="headerlink" title="Goroutines的优势"></a>Goroutines的优势</h2><ul><li>Goroutine和线程相比及其节省开销，它们仅需要占用几kb的栈空间，而且栈空间可以根据程序的需要增加或回收。而同样情形下线程占用的栈空间只能被指定并且不可修改。</li><li>Goroutine采用多路复用的方式来减少对系统线程的占用。程序中一个线程中可能包含几千个Goroutine，如果任何Goroutine在线程中阻塞比如需要等待用户输入，那么将会创建新的系统线程并把剩下的Goroutine转移到新系统线程中。所有的操作都由运行时自动处理，作为开发人员不用纠结于实现这个的细节了，Go为此提供了清晰的API。</li><li>Goroutine之间的通信使用channel，channel被设计用来防止Goroutine之间访问共享内存可能造成的冲突。channel可以理解为Goroutine通信的管道。我们将在后面的文章中讨论channel。</li></ul><!-- more --><h2 id="如何启动一个Goroutine"><a href="#如何启动一个Goroutine" class="headerlink" title="如何启动一个Goroutine"></a>如何启动一个Goroutine</h2><p>在调用函数或者方法时前面加上<code>go</code>你将启动一个新的Goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"Hello world goroutine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    fmt.Println(<span class="string">"main function"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在11行，<code>go hello()</code>启动了一个新的Goroutine，现在<code>hello()</code>函数将和<code>main()</code>函数并发执行，<code>main()</code>函数在其拥有的被称为<code>main Goroutine</code>的Goroutine中执行。</p><p>运行上面代码，你将发现只有<code>main function</code>被输出了，搞毛线？我们需要理解Goroutine的２个主要的属性来解释为什么会这样。</p><ul><li>当一个新Goroutine开始执行时将会立刻返回。和函数不同，程序并不会等待Goroutine执行结束，而是立刻执行下一行代码并且忽略Goroutine的返回值。</li><li>如果<code>main Goroutine</code>结束，那么程序就结束了而且所有的Goroutine都不会运行。</li></ul><p>我猜你已经明白为什么我们的Goroutine没有执行了。１１行程序立刻执行了下一行输出了<code>main function</code>而不是等待Goroutine执行结束。<code>main Goroutine</code>执行结束后其他代码没有机会执行，所以<code>hello</code>Goroutine没机会执行。</p><p>现在我们修复这个问题：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"Hello world goroutine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"main function"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>13行我们调用<code>time</code>包中的<code>Sleep</code>方法，这样<code>main Goroutine</code>被阻塞１秒钟，程序结束前<code>go hello()</code>有足够的时间执行。所以这个程序先输出<code>Hello world goroutine</code>，然后输出<code>main function</code>。</p><p>在<code>main Goroutine</code>中使用<code>Sleep</code>来等待其他Goroutine执行完毕仅仅是用来方便理解Goroutine如何工作，<code>Channel</code>才是用来阻塞<code>main Goroutine</code>等待其他Goroutine执行完毕的主要方式。我们将在下一篇文章解释。</p><h2 id="启动多个Goroutine"><a href="#启动多个Goroutine" class="headerlink" title="启动多个Goroutine"></a>启动多个Goroutine</h2><p>让我们写个启动多个Goroutine的程序来更好的理解：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbers</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">250</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alphabets</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="string">'a'</span>; i &lt;= <span class="string">'e'</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">400</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">"%c "</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> numbers()</span><br><span class="line">    <span class="keyword">go</span> alphabets()</span><br><span class="line">    time.Sleep(<span class="number">3000</span> * time.Millisecond)</span><br><span class="line">    fmt.Println(<span class="string">"main terminated"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的程序启动了２个Goroutine，这２个Goroutine并发执行。<code>numbers</code>sleep　250毫秒后输出<code>1</code>然后再次sleep输出<code>2</code>，直到循环结束输出<code>5</code>。同样的<code>alphabets</code>函数输出<code>a</code>到<code>e</code>，每次sleep　400毫秒。<code>main Goroutine</code>启动上面２个Goroutine后sleep 3000毫秒并结束。</p><p>程序输出如下:</p><p><code>1 a 2 3 b 4 c 5 d e main terminated</code></p><hr><p>原文最后还有个图解释输出为啥是上面那样，这里roy就不翻译了，不明白的可以自己去原文中查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/goroutines/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，建议理解并发(concurrency)、并行(parallelism)区别后再看这方面的内容。&lt;/p&gt;&lt;h2 id=&quot;Goroutines是啥？&quot;&gt;&lt;a href=&quot;#Goroutines是啥？&quot; class=&quot;headerlink&quot; title=&quot;Goroutines是啥？&quot;&gt;&lt;/a&gt;Goroutines是啥？&lt;/h2&gt;&lt;p&gt;Goroutines是一个可以和其他函数或方法并发执行的函数或方法。也可以把它理解为轻量级的线程(roy注:这话听起来和大python中的协程很像啊！)，而创建Goroutine的开销却远远小于线程。因此在大多数的Go程序都可以并发执行成千上万的Goroutine。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>BasicPaxos算法</title>
    <link href="http://www.hi-roy.com/2018/05/31/BasicPaxos%E7%AE%97%E6%B3%95/"/>
    <id>http://www.hi-roy.com/2018/05/31/BasicPaxos算法/</id>
    <published>2018-05-31T08:08:07.000Z</published>
    <updated>2019-09-16T08:11:51.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPA理论"><a href="#CPA理论" class="headerlink" title="CPA理论"></a>CPA理论</h2><p>分布式系统中有个经典的CAP理论，就是说任何分布式系统最多满足一致性(Consistency)，可用性(Availability)，分区容错性(Partition Tolerance)这三者中的两个。</p><p>既然是分布式，必然将节点部署到不同的网络中，而这则会引起一致性问题。想解决一致性，就需要保证每次操作所有节点都成功执行，而这又会降低可用性。既然分区已经是事实，所以工程上应该尽量在保证一致性的前提下提高可用性。</p><p>而一致性又可以分为：</p><ul><li>强一致性：上次写什么，下次就一定能读到什么，这需要牺牲可用性。</li><li>弱一致性：并不保证更新后所有线程都能读到最新值，需要一段时间进行同步。</li><li>最终一致性：弱一致性的一种特例。</li></ul><a id="more"></a><h2 id="二段提交和三段提交"><a href="#二段提交和三段提交" class="headerlink" title="二段提交和三段提交"></a>二段提交和三段提交</h2><p><strong>多个节点之间保持一致性的关键在于让当前节点知道其他节点的执行状态</strong>，所以最容易想到的就是引入一个“协调者”，于是出现了二段提交协议(Two Phase Commitment Protocol)和三段提交协议(Three Phase Commitment Protocol)。</p><p>二段提交可以分成：</p><h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><ol><li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li><li>参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li><li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ol><h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><ol><li>如果协调者节点从所有参与者节点获得的相应消息都为”同意”时:<ol><li>协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息。</li><li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol></li><li>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：<ol><li>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。</li><li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol></li></ol><p>但这种方式存在几个问题：</p><ol><li>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占<strong>有公共资源</strong>时，其他第三方节点访问公共资源不得不处于阻塞状态。</li><li>单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li><li>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li><li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ol><p>而三段提交则在二段提交的基础上增加了一个阶段，分为<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段，并且参与者也引入了超时机制，而二段提交中只有协调者才有超时机制，这样解<strong>决了阻塞问题</strong>。</p><h3 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h3><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><ol><li><em>事务询问</em> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li><li><em>响应反馈</em> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</li></ol><h3 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h3><p>协调者根据参与者的反应情况来决定是否可以执行事务的PreCommit操作。根据响应情况，有以下两种可能。</p><ol><li><p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</p><ol><li><em>发送预提交请求</em> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</li><li><em>事务预提交</em> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</li><li><em>响应反馈</em> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li></ol></li><li><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><ol><li><em>发送中断请求</em> 协调者向所有参与者发送abort请求。</li><li><em>中断事务</em> 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li></ol></li></ol><h3 id="DoCommit阶段"><a href="#DoCommit阶段" class="headerlink" title="DoCommit阶段"></a>DoCommit阶段</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><ol><li><p>执行提交</p><ol><li><em>发送提交请求</em> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送DoCommit请求。</li><li><em>事务提交</em> 参与者接收到DoCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li><li><em>响应反馈</em> 事务提交完之后，向协调者发送Ack响应。</li><li><em>完成事务</em> 协调者接收到所有参与者的ack响应之后，完成事务。</li></ol></li><li><p>中断事务 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><ol><li><em>发送中断请求</em> 协调者向所有参与者发送abort请求</li><li><em>事务回滚</em> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li><li><em>反馈结果</em> 参与者完成事务回滚之后，向协调者发送ACK消息</li><li><em>中断事务</em> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li></ol></li></ol><blockquote><p>在DoCommit阶段，<strong>如果参与者无法及时接收到来自协调者的DoCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。</strong>（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</p></blockquote><p>以上关于二段提交和三段提交的描述摘自<a href="http://www.hollischuang.com/archives/681" target="_blank" rel="noopener">这里</a>，核心一点就是<strong>不论上述中的哪个方法，都没解决数据一致性的问题</strong>。</p><p>另外我个人有个疑问——<strong>为什么二段提交是阻塞的而三段提交引入timeout就是非阻塞的了呢？换言之，为何二段提交中参与者不引入timeout机制？</strong></p><p>猜测如下：</p><p>如果二段提交中参与者引入超时机制，这里就假设超时后回滚。当提交阶段某些机器收到了协调者发来的提交确认，而某些参与者超时直接进行回滚，则会导致数据不一致。也就所说，阻塞问题缓解了，但一致性问题却更恶化了。</p><p>而三段提交中，即便DoCommit阶段参与者没收到协调者发来的请求，也有极大的概率认为这个事务应该被提交，进而提高了一致性。</p><p>以上纯属猜测，欢迎拍砖。</p><h2 id="BasicPaxos算法"><a href="#BasicPaxos算法" class="headerlink" title="BasicPaxos算法"></a>BasicPaxos算法</h2><p>Paxos算法有很多变种，这里记录最基本的BasicPaxos。</p><p>Paxos算法中涉及到３种角色：</p><h4 id="Proposer-提案者"><a href="#Proposer-提案者" class="headerlink" title="Proposer:提案者"></a>Proposer:提案者</h4><p>Proposer可以有多个，Proposer提出议案(value)。所谓value，在工程中可以是任何操作，例如“修改某个变量的值为某个值”、“设置当前primary为某个节点”等等。Paxos协议中统一将这些操作抽象为value。不同的Proposer可以提出不同的甚至矛盾的value，例如某个Proposer提议“将变量 X 设置为1”，另一个Proposer提议“将变量X设置为2”，但对同一轮Paxos过程，最多只有一个value被批准。</p><h4 id="Acceptor-批准者"><a href="#Acceptor-批准者" class="headerlink" title="Acceptor:批准者"></a>Acceptor:批准者</h4><p>Acceptor有N个，Proposer提出的value必须获得超过半数(N/2+1)的Acceptor批准后才能通过。Acceptor之间完全对等独立。</p><h4 id="Learner-学习者"><a href="#Learner-学习者" class="headerlink" title="Learner:学习者"></a>Learner:学习者</h4><p>Learner学习被批准的value。所谓学习就是通过读取各个Proposer对value的选择结果，如果某个value被超过半数Proposer通过，则Learner学习到了这个value。这里类似Quorum议会机制，某个value需要获得W=N/2 + 1的Acceptor批准，Learner需要至少读取N/2+1个Accpetor，至多读取N个Acceptor的结果后，能学习到一个通过的value。</p><p>算法中涉及的主要是Proposer和Acceptor，简单说逻辑如下：</p><p>准备阶段</p><ol><li>proposer向网络内超过半数的acceptor发送prepare消息</li><li>acceptor正常情况下回复promise消息</li></ol><p>选举阶段</p><ol><li>在有足够多acceptor回复promise消息时，proposer发送accept消息</li><li>正常情况下acceptor回复accepted消息</li></ol><p>我们假设最简单的情况2个Proposer和3个Acceptor，首先P1、P2分别向A1、A2、A3发送<code>perpare</code>请求，由于网络原因，A3接收不到P1的消息，A1接收不到P2的消息。<br><img src="http://mypic-1252424367.coshk.myqcloud.com/paxos/1.png" alt="1"></p><p>Acceptor接收到请求后回复<code>promise</code>信息，这里我们假定A2先收到了P1的消息后收到P2的消息，所以A2此时存储的提案号是2：<br><img src="http://mypic-1252424367.coshk.myqcloud.com/paxos/2.png" alt="2"></p><p>接下来进入选举阶段，Proposer分别向Acceptor提交<code>accept</code>请求并带上value，A1和A3这里不细说，分别存储了相应的value后返回<code>accepted</code>，重点是A2。由于A2中存储的提案号码大于P1发送的accept中的提案号1，所以返回了reject。而P2已经获得了大多数的accepted，达成了一致。<br><img src="http://mypic-1252424367.coshk.myqcloud.com/paxos/3.png" alt="3"></p><p>由于P1没接受到大多数的accpeted，便增加提案号发送prepare消息：<br><img src="http://mypic-1252424367.coshk.myqcloud.com/paxos/4.png" alt="4"></p><p>此时A1和A2发现新提案号大于自己以存在的提案号，于是更新并返回已经存在的提案号和对应的value。</p><p>接下来，P1收到了<code>promise(1,p1)</code>和<code>promise(2,p2)</code>，2大于1,所以选择p2为接下来发送提案的值：<br><img src="http://mypic-1252424367.coshk.myqcloud.com/paxos/5.png" alt="5"></p><p>A1和A2发现P1的提案号和存储的一致，于是返回<code>accepted</code>消息，此时P1也达成了一致。</p><p>一个简单的BasicPaxos算法流程就结束了，但是真是环境多个节点时，很有可能出现”活锁(live lock)”的问题，即提案号不停增长但始终无法达成一致。于是便增加了一个新角色’leader’，multi paxos算法诞生了。但是呢，谁能保证选leader时候不会活锁呢？那就加个随机计时器吧——于是，raft算法诞生了。</p><p>关于raft，那就又是另外一个故事了。</p><hr><p>参考资料：</p><ul><li><a href="https://mp.weixin.qq.com/s/RkjtbHZN9ZDV7z0RhWS9yQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RkjtbHZN9ZDV7z0RhWS9yQ</a></li><li><a href="http://iunknown.iteye.com/blog/2246484?from=message&amp;isappinstalled=0" target="_blank" rel="noopener">http://iunknown.iteye.com/blog/2246484?from=message&amp;isappinstalled=0</a></li></ul><p>Lamport的两篇论文《The Part-Time Parliament》和《Paxos Made Simple》</p><p>视频《paxos和分布式系统》，这个很详细建议多看几遍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CPA理论&quot;&gt;&lt;a href=&quot;#CPA理论&quot; class=&quot;headerlink&quot; title=&quot;CPA理论&quot;&gt;&lt;/a&gt;CPA理论&lt;/h2&gt;&lt;p&gt;分布式系统中有个经典的CAP理论，就是说任何分布式系统最多满足一致性(Consistency)，可用性(Availability)，分区容错性(Partition Tolerance)这三者中的两个。&lt;/p&gt;&lt;p&gt;既然是分布式，必然将节点部署到不同的网络中，而这则会引起一致性问题。想解决一致性，就需要保证每次操作所有节点都成功执行，而这又会降低可用性。既然分区已经是事实，所以工程上应该尽量在保证一致性的前提下提高可用性。&lt;/p&gt;&lt;p&gt;而一致性又可以分为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;强一致性：上次写什么，下次就一定能读到什么，这需要牺牲可用性。&lt;/li&gt;&lt;li&gt;弱一致性：并不保证更新后所有线程都能读到最新值，需要一段时间进行同步。&lt;/li&gt;&lt;li&gt;最终一致性：弱一致性的一种特例。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker的以太坊开发环境搭建</title>
    <link href="http://www.hi-roy.com/2018/05/25/%E5%9F%BA%E4%BA%8EDocker%E7%9A%84%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.hi-roy.com/2018/05/25/基于Docker的以太坊开发环境搭建/</id>
    <published>2018-05-25T13:06:00.000Z</published>
    <updated>2019-09-16T08:11:51.522Z</updated>
    
    <content type="html"><![CDATA[<p>本地开发环境可以使用<code>geth</code>和<code>testrpc</code>(已经改名成ganache-cli)2种，如果只是进行测试或者学习智能合约开发的话，建议使用第二个。至于docker怎么安装网上很多这里不再赘述。</p><a id="more"></a><h2 id="ganache-cli"><a href="#ganache-cli" class="headerlink" title="ganache-cli"></a>ganache-cli</h2><p><a href="https://github.com/trufflesuite/ganache-cli" target="_blank" rel="noopener">ganache-cli</a>是专门用来测试的单节点服务，大大简化了初学者的学习门槛。我们使用docker直接拉取镜像并且运行容器即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull trufflesuite/ganache-cli</span><br><span class="line">docker run -d -p 8545:8545 trufflesuite/ganache-cli:latest</span><br></pre></td></tr></table></figure><p></p><p>注意这里暴露rpc端口8545以便后续使用。查看容器log发现有如下输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">0 % docker ps                                                 </span><br><span class="line">CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ab32d69568d5        trufflesuite/ganache-cli:latest   &quot;node ./build/cli.no…&quot;   2 seconds ago       Up 1 second         0.0.0.0:8545-&gt;8545/tcp   determined_lalande</span><br><span class="line"></span><br><span class="line">bigdata@localhost ~</span><br><span class="line">0 % docker logs ab32</span><br><span class="line">Ganache CLI v6.1.0 (ganache-core: 2.1.0)</span><br><span class="line"></span><br><span class="line">Available Accounts</span><br><span class="line">==================</span><br><span class="line">(0) 0xc2f8b7721aecd04f0eec86312922be6a7c76c0b5</span><br><span class="line">(1) 0x9ef2dbfa5858ec3df4056cd3bf042901eace1624</span><br><span class="line">(2) 0x5da72a88644fc685d83d80ff4eb762c6e3cfb09e</span><br><span class="line">(3) 0x031052fe58207ddd45a126fb6a2aeac1e6a2023d</span><br><span class="line">(4) 0x96f332a4c9c39b2c0dd852fa7d4297a3adfd8d34</span><br><span class="line">(5) 0x12792fdd051069721f7cc775947e30be16392f74</span><br><span class="line">(6) 0xf203479478e035be68a6672e7fe9039be246be2e</span><br><span class="line">(7) 0xb3bba9d62a8ca96a2869f5993dab9653b24c8be6</span><br><span class="line">(8) 0x52cb7b373f47ac88b6f2ab02367c13487ed7902e</span><br><span class="line">(9) 0xdf2fadf330fe872d9c68029a71988d27bb0df2a3</span><br><span class="line"></span><br><span class="line">Private Keys</span><br><span class="line">==================</span><br><span class="line">(0) db2cd03a33d3229064c9f130681901f02fe92a74e0d498617a0ce200260d50d3</span><br><span class="line">(1) 0934d8d2ccdb9b2c79e6bba9a2845aefc9822a0d0ba25be4223271c318ef4cfb</span><br><span class="line">(2) c151a140505e23cc11d6ad3376f227f434a3799a614e88fa3d5af61c2000c6c0</span><br><span class="line">(3) 0f5ff60acd03808222ec78460d213677dd4d313973e0ee8e8206248f1e217c9c</span><br><span class="line">(4) c8ccb7783be8396ad5074d414a9dc75c900a2950635b0aaf11ef08049c6a67b1</span><br><span class="line">(5) c2b7ab621545f844caa12468bd8305de7a25c3752db2558742f2b86af0992088</span><br><span class="line">(6) 29e6d35ef0c1a75bb9ff908899eb29dc1b9ebbf54a6fff889dacbd7131048164</span><br><span class="line">(7) cda3c058c06db1a71226236baf0ce1df4cc86b2ba1dc16e1ef780b3f25a5ba1a</span><br><span class="line">(8) d5560a41df67cb5e74cc30a8a3ce99274c1e3c93c7181ad867f10dc44de85ac3</span><br><span class="line">(9) 0bdd9da376f2fab0eaf4d8ddba4294fbb3f84a824087ff592740228ab57a3e2d</span><br><span class="line"></span><br><span class="line">HD Wallet</span><br><span class="line">==================</span><br><span class="line">Mnemonic:      shaft travel notable balcony mystery text vast eight cycle armed affair vessel</span><br><span class="line">Base HD Path:  m/44&apos;/60&apos;/0&apos;/0/&#123;account_index&#125;</span><br><span class="line"></span><br><span class="line">Listening on localhost:8545</span><br></pre></td></tr></table></figure><p></p><p>完事，用docker就是这么简单。镜像中自动创建账户并且分配了100eth到每个账户中。</p><h2 id="geth"><a href="#geth" class="headerlink" title="geth"></a>geth</h2><p>另一种就是官网的golang客户端<a href="https://github.com/ethereum/go-ethereum/" target="_blank" rel="noopener">geth</a>，当然也可以通过<code>go get</code>命令在直接安装，但我这里还是使用docker：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull ethereum/client-go</span><br><span class="line"></span><br><span class="line">docker run -d --name ethereum-node -v /mnt/files/myethereum:/root -p 8545:8545 -p 30303:30303 ethereum/client-go --rpcaddr 0.0.0.0 --rpc --rpccorsdomain &quot;*&quot; --rpcapi &quot;web3,eth&quot; --testnet</span><br></pre></td></tr></table></figure><p></p><p>根据情况修改-v后面的参数，运行容器时记得添加后面的各种参数，否则在使用remix连接时候可能会报错<code>Not possible to connect to the Web3 Provider</code>。</p><p>运行成功后进入容器中:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ethereum-node sh</span><br><span class="line"></span><br><span class="line">/ # ls /root/.ethereum/testnet/</span><br><span class="line">geth      geth.ipc  keystore</span><br><span class="line">/ # geth attach ipc://root/.ethereum/testnet/geth.ipc</span><br><span class="line">Welcome to the Geth JavaScript console!</span><br><span class="line"></span><br><span class="line">instance: Geth/v1.8.9-unstable-be22ee8d/linux-amd64/go1.10.2</span><br><span class="line">modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><br></pre></td></tr></table></figure><p></p><p>使用<code>geth attach</code>命令进入终端后，查看账户：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.listAccounts</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p></p><p>目前是没有账户的，来创建新账户：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount(&quot;123456&quot;)</span><br><span class="line">&quot;0x732aed1c5dfba79712698ddd7a2724a13b719975&quot;</span><br><span class="line">&gt; personal.listAccounts</span><br><span class="line">[&quot;0x732aed1c5dfba79712698ddd7a2724a13b719975&quot;]</span><br></pre></td></tr></table></figure><p></p><p>123456是密码，返回的是账户地址。查看余额：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.eth.getBalance(personal.listAccounts[0])</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>当前账户余额为０。</p><p>开始挖矿<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start()</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p></p><p>使用<code>docker logs</code>命令查看日志，发现如下输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INFO [05-25|07:31:07] Commit new mining work                   number=37      txs=0 uncles=0 elapsed=193.682µs</span><br><span class="line">INFO [05-25|07:31:07] Imported new block headers               count=0   elapsed=10.525ms  number=7888    hash=047277…30a270 ignored=192</span><br><span class="line">INFO [05-25|07:31:08] Generating DAG in progress               epoch=1 percentage=86 elapsed=2m9.829s</span><br><span class="line">INFO [05-25|07:31:09] Imported new block receipts              count=0   elapsed=2.569ms   number=7697    hash=c10545…927b36 size=0.00B   ignored=193</span><br><span class="line">INFO [05-25|07:31:09] Imported new block headers               count=0   elapsed=21.729ms  number=8080    hash=eaf61a…16348d ignored=192</span><br><span class="line">INFO [05-25|07:31:09] Successfully sealed new block            number=37      hash=2c9711…69fe1e</span><br><span class="line">INFO [05-25|07:31:09] 🔗 block reached canonical chain          number=32      hash=a1b397…5057b3</span><br><span class="line">INFO [05-25|07:31:09] 🔨 mined potential block                  number=37      hash=2c9711…69fe1e</span><br><span class="line">INFO [05-25|07:31:09] Commit new mining work                   number=38      txs=0 uncles=0 elapsed=360.395µs</span><br><span class="line">INFO [05-25|07:31:10] Generating DAG in progress               epoch=1 percentage=87 elapsed=2m11.381s</span><br><span class="line">INFO [05-25|07:31:11] Imported new state entries               count=768 elapsed=2.977ms   processed=4883618 pending=3083 retry=0 duplicate=0 unexpected=0</span><br><span class="line">INFO [05-25|07:31:11] Imported new block receipts              count=0   elapsed=1.716ms   number=7891    hash=6af5d1…008a67 size=0.00B   ignored=194</span><br><span class="line">INFO [05-25|07:31:11] Imported new block headers               count=0   elapsed=10.914ms  number=8272    hash=b4afad…9154f0 ignored=192</span><br><span class="line">INFO [05-25|07:31:11] Successfully sealed new block            number=38      hash=e84cd2…0ba05b</span><br></pre></td></tr></table></figure><p></p><p>再看钱包余额:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.eth.getBalance(personal.listAccounts[0])</span><br><span class="line">105000000000000000000</span><br></pre></td></tr></table></figure><p>接下来解锁钱包，这样才能用于智能合约:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; addr = eth.accounts[0]</span><br><span class="line">&quot;0x732aed1c5dfba79712698ddd7a2724a13b719975&quot;</span><br><span class="line">&gt; personal.unlockAccount(addr,&apos;123456&apos;,1000000)</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p></p><p>其中<code>unlockAccount</code>函数第二个参数是账户密码，第三个参数是解锁时间。这里设定1000000秒内账户都是活跃状态，这样再次操作时候就不用解锁了。</p><h2 id="remix"><a href="#remix" class="headerlink" title="remix"></a>remix</h2><p><a href="http://remix.ethereum.org" target="_blank" rel="noopener">remix</a>是一个在线智能合约IDE，注意打开这个网站时候使用http而不是https，否则也可能会报错<code>Not possible to connect to the Web3 Provider</code>。</p><p>打开网站后在右上角<code>run</code>面板中修改<code>Environment</code>选项为<code>web3 provider</code>，然后打开<code>settings</code>面版，选择<code>Solidity</code>的版本，否则可能会报错<code>mock compiler: source not found</code></p><p>编写一个最简单的合约：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract MyfirstContract &#123;</span><br><span class="line"> uint storeData;</span><br><span class="line"> function set(uint x)&#123;</span><br><span class="line">     storeData = x;</span><br><span class="line"> &#125;</span><br><span class="line"> function get() constant returns (uint retVal)&#123;</span><br><span class="line">     return storeData;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译完成后点击<code>deploy</code>进行部署，然后设置一个数值点击<code>set</code>调用即可：</p><p><img src="http://mypic-1252424367.coshk.myqcloud.com/remix.png" alt="remix"></p><p>从上图看到这次交易消耗了41733个gas。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地开发环境可以使用&lt;code&gt;geth&lt;/code&gt;和&lt;code&gt;testrpc&lt;/code&gt;(已经改名成ganache-cli)2种，如果只是进行测试或者学习智能合约开发的话，建议使用第二个。至于docker怎么安装网上很多这里不再赘述。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.hi-roy.com/source/all-tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="docker" scheme="http://www.hi-roy.com/source/all-tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>GO语言学习笔记-接口2</title>
    <link href="http://www.hi-roy.com/2018/05/22/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A32/"/>
    <id>http://www.hi-roy.com/2018/05/22/GO语言学习笔记-接口2/</id>
    <published>2018-05-22T14:29:47.000Z</published>
    <updated>2019-09-16T08:11:51.457Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golangbot.com/interfaces-part-2/" target="_blank" rel="noopener">原文</a></p><h2 id="传指针vs传值"><a href="#传指针vs传值" class="headerlink" title="传指针vs传值"></a>传指针vs传值</h2><p>上篇文章中所有接口实现我们都使用的传值，当然也可以使用传指针这种方式来实现接口。但使用传指针这种方式有一点需要注意，我们来看下面这个代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Describe</span><span class="params">()</span></span> &#123; <span class="comment">//implemented using value receiver  </span></span><br><span class="line">    fmt.Printf(<span class="string">"%s is %d years old\n"</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    state   <span class="keyword">string</span></span><br><span class="line">    country <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Address)</span> <span class="title">Describe</span><span class="params">()</span></span> &#123; <span class="comment">//implemented using pointer receiver  </span></span><br><span class="line">    fmt.Printf(<span class="string">"State %s Country %s"</span>, a.state, a.country)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    p1 := Person&#123;<span class="string">"Sam"</span>, <span class="number">25</span>&#125;</span><br><span class="line">    d1 = p1</span><br><span class="line">    d1.Describe()</span><br><span class="line">    p2 := Person&#123;<span class="string">"James"</span>, <span class="number">32</span>&#125;</span><br><span class="line">    d1 = &amp;p2</span><br><span class="line">    d1.Describe()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d2 Describer</span><br><span class="line">    a := Address&#123;<span class="string">"Washington"</span>, <span class="string">"USA"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* compilation error if the following line is</span></span><br><span class="line"><span class="comment">       uncommented</span></span><br><span class="line"><span class="comment">       cannot use a (type Address) as type Describer</span></span><br><span class="line"><span class="comment">       in assignment: Address does not implement</span></span><br><span class="line"><span class="comment">       Describer (Describe method has pointer</span></span><br><span class="line"><span class="comment">       receiver)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//d2 = a</span></span><br><span class="line"></span><br><span class="line">    d2 = &amp;a <span class="comment">//This works since Describer interface</span></span><br><span class="line">    <span class="comment">//is implemented by Address pointer in line 22</span></span><br><span class="line">    d2.Describe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的代码中，结构体<code>Person</code>使用传值的方式实现了接口<code>Describer</code>。</p><p>在之前的<a href="https://golangbot.com/methods/#valuereceiversinmethodsvsvalueargumentsinfunctions" target="_blank" rel="noopener">文章</a>中我们介绍过，一个接受值传递的方法同时也接受指针。<em>所以使用传值或者传指针的方法调用这种方法都是合法的</em>。</p><p>在２９行将<code>Person</code>类型的变量<code>p1</code>赋值给了<code>d1</code>。因为<code>Person</code>实现了d1代表的接口所以会输出<code>Sam is 25 years old</code>。</p><p>同样，接下来将<code>&amp;p2</code>也赋值给了<code>d1</code>，所以接下来输出<code>James is 32 years old</code>。</p><p>而<code>Address</code>采用传指针的方式实现接口<code>Describer</code>。如果取消４５行的注释程序将会报错 <strong>main.go:42: cannot use a (type Address) as type Describer in assignment: Address does not implement Describer (Describe method has pointer receiver)</strong>。这是因为<code>Describer</code>是被<code>Address</code>类型的指针传递实现，而<code>a</code>是一个值类型并没有实现<code>Describer</code>接口。你一定很吃惊，因为<a href="https://golangbot.com/methods/#pointerreceiversinmethodsvspointerargumentsinfunctions" target="_blank" rel="noopener">之前</a>我们曾经讲过，接受指针的方法也可使用值类型调用，那么为什么会报错呢？</p><p><strong>这是因为，调用一个指针－值方法在任何指针或者可寻址的值上都是合法的，而接口中存储的具体值是不可寻址的，因此编译器不能自动的找到内存地址所以４５行会报错。</strong></p><p>４７行可以执行是因为我们把<code>a</code>的地址<code>&amp;a</code>传递给了<code>d2</code>。代码输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sam is 25 years old  </span><br><span class="line">James is 32 years old  </span><br><span class="line">State Washington Country USA</span><br></pre></td></tr></table></figure><p></p><h2 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h2><p>一个类型可以实现多个接口，代码如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    DisplaySalary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LeaveCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateLeavesLeft() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="keyword">string</span></span><br><span class="line">    lastName <span class="keyword">string</span></span><br><span class="line">    basicPay <span class="keyword">int</span></span><br><span class="line">    pf <span class="keyword">int</span></span><br><span class="line">    totalLeaves <span class="keyword">int</span></span><br><span class="line">    leavesTaken <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DisplaySalary</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"%s %s has salary $%d"</span>, e.firstName, e.lastName, (e.basicPay + e.pf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">CalculateLeavesLeft</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.totalLeaves - e.leavesTaken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := Employee &#123;</span><br><span class="line">        firstName: <span class="string">"Naveen"</span>,</span><br><span class="line">        lastName: <span class="string">"Ramanathan"</span>,</span><br><span class="line">        basicPay: <span class="number">5000</span>,</span><br><span class="line">        pf: <span class="number">200</span>,</span><br><span class="line">        totalLeaves: <span class="number">30</span>,</span><br><span class="line">        leavesTaken: <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s SalaryCalculator = e</span><br><span class="line">    s.DisplaySalary()</span><br><span class="line">    <span class="keyword">var</span> l LeaveCalculator = e</span><br><span class="line">    fmt.Println(<span class="string">"\nLeaves left ="</span>, l.CalculateLeavesLeft())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码<code>Employee</code>实现了２个接口<code>SalaryCalculator</code>和<code>LeaveCalculator</code>，并把<code>Employee</code>类型的变量<code>e</code>分别转换成２种接口类型，代码输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Naveen Ramanathan has salary $5200  </span><br><span class="line">Leaves left = 25</span><br></pre></td></tr></table></figure><p></p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>尽管GO中不支持继承，但可以通过嵌套来定义新接口：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    DisplaySalary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LeaveCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateLeavesLeft() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmployeeOperations <span class="keyword">interface</span> &#123;  </span><br><span class="line">    SalaryCalculator</span><br><span class="line">    LeaveCalculator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="keyword">string</span></span><br><span class="line">    lastName <span class="keyword">string</span></span><br><span class="line">    basicPay <span class="keyword">int</span></span><br><span class="line">    pf <span class="keyword">int</span></span><br><span class="line">    totalLeaves <span class="keyword">int</span></span><br><span class="line">    leavesTaken <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DisplaySalary</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"%s %s has salary $%d"</span>, e.firstName, e.lastName, (e.basicPay + e.pf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">CalculateLeavesLeft</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.totalLeaves - e.leavesTaken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := Employee &#123;</span><br><span class="line">        firstName: <span class="string">"Naveen"</span>,</span><br><span class="line">        lastName: <span class="string">"Ramanathan"</span>,</span><br><span class="line">        basicPay: <span class="number">5000</span>,</span><br><span class="line">        pf: <span class="number">200</span>,</span><br><span class="line">        totalLeaves: <span class="number">30</span>,</span><br><span class="line">        leavesTaken: <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> empOp EmployeeOperations = e</span><br><span class="line">    empOp.DisplaySalary()</span><br><span class="line">    fmt.Println(<span class="string">"\nLeaves left ="</span>, empOp.CalculateLeavesLeft())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过嵌套<code>SalaryCalculator</code>和<code>LeaveCalculator</code>这２个接口，我们创建了新接口<code>EmployeeOperations</code>。如果某个类型同时实现了定义在<code>SalaryCalculator</code>和<code>LeaveCalculator</code>中的函数，则可以说它实现了接口<code>EmployeeOperations</code>。</p><p>４６行将<code>Employee</code>类型的变量e转换为了<code>EmployeeOperations</code>类型，并且分别调用了<code>DisplaySalary()</code>和<code>CalculateLeavesLeft()</code>方法。输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Naveen Ramanathan has salary $5200  </span><br><span class="line">Leaves left = 25</span><br></pre></td></tr></table></figure><p></p><p>(roy补充：把e转换成<code>SalaryCalculator</code>或<code>LeaveCalculator</code>也可以。)</p><h2 id="接口零值-空接口"><a href="#接口零值-空接口" class="headerlink" title="接口零值/空接口"></a>接口零值/空接口</h2><p>接口的零值是<code>nil</code>，nil接口的隐含值和实际类型都是<code>nil</code>。(roy注：零值指没被实现的接口)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    <span class="keyword">if</span> d1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"d1 is nil and has type %T value %v\n"</span>, d1, d1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1 is nil and has type &lt;nil&gt; value &lt;nil&gt;</span><br></pre></td></tr></table></figure><p></p><p>如果我们尝试在nil接口上调用方法，则会引发错误，因为nil接口没有隐含值也没有实际类型。<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    d1.Describe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>d1</code>是一个nil，所以将会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xc8527]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://golangbot.com/interfaces-part-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;传指针vs传值&quot;&gt;&lt;a href=&quot;#传指针vs传值&quot; class=&quot;headerlink&quot; title=&quot;传指针vs传值&quot;&gt;&lt;/a&gt;传指针vs传值&lt;/h2&gt;&lt;p&gt;上篇文章中所有接口实现我们都使用的传值，当然也可以使用传指针这种方式来实现接口。但使用传指针这种方式有一点需要注意，我们来看下面这个代码。&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Describer &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Describe()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Person &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(p Person)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Describe&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;//implemented using value receiver  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%s is %d years old\n&quot;&lt;/span&gt;, p.name, p.age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Address &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    state   &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    country &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(a *Address)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Describe&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;//implemented using pointer receiver  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;State %s Country %s&quot;&lt;/span&gt;, a.state, a.country)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; d1 Describer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p1 := Person&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Sam&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d1 = p1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d1.Describe()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p2 := Person&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;James&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d1 = &amp;amp;p2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d1.Describe()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; d2 Describer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a := Address&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Washington&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;USA&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* compilation error if the following line is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       uncommented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       cannot use a (type Address) as type Describer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       in assignment: Address does not implement&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       Describer (Describe method has pointer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       receiver)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//d2 = a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d2 = &amp;amp;a &lt;span class=&quot;comment&quot;&gt;//This works since Describer interface&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//is implemented by Address pointer in line 22&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d2.Describe()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
</feed>
