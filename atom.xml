<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi!Roy!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.hi-roy.com/"/>
  <updated>2021-01-15T12:59:54.033Z</updated>
  <id>http://www.hi-roy.com/</id>
  
  <author>
    <name>Roy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新手可能会犯的50个Golang错误</title>
    <link href="http://www.hi-roy.com/2020/12/16/%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%8450%E4%B8%AAGolang%E9%94%99%E8%AF%AF/"/>
    <id>http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/</id>
    <published>2020-12-16T13:32:59.000Z</published>
    <updated>2021-01-15T12:59:54.033Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html" target="_blank" rel="noopener">原文</a>，向原作者表示感谢。这里省略了一些无关的介绍说明以及过于简单的说明，直接看代码就懂了。</p><h2 id="左花括号不能单独一行"><a href="#左花括号不能单独一行" class="headerlink" title="左花括号不能单独一行"></a>左花括号不能单独一行</h2><p>在大多数语言中你可以随便放置花括号的位置，但go语言不一样，你可以理解为为go会自动注入分号（automatic semicolon injection）：</p><p>错误代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//error, can't have the opening brace on a separate line</span></span><br><span class="line">    fmt.Println(<span class="string">"hello there!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/sandbox826898458/main.<span class="keyword">go</span>:<span class="number">6</span>: syntax error: unexpected semicolon or newline before &#123;</span><br></pre></td></tr></table></figure><p>正确代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"works!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="未使用的变量"><a href="#未使用的变量" class="headerlink" title="未使用的变量"></a>未使用的变量</h2><p>在go中如果有未使用的变量，即便对其进行了赋值，编译时也会报错。只有全局变量和函数参数可以声明而不使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gvar <span class="keyword">int</span> <span class="comment">//not an error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> one <span class="keyword">int</span>   <span class="comment">//error, unused variable</span></span><br><span class="line">    two := <span class="number">2</span>      <span class="comment">//error, unused variable</span></span><br><span class="line">    <span class="keyword">var</span> three <span class="keyword">int</span> <span class="comment">//error, even though it's assigned 3 on the next line</span></span><br><span class="line">    three = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(unused <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Unused arg. No compile error"</span>)</span><br><span class="line">    &#125;(<span class="string">"what?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未使用的包"><a href="#未使用的包" class="headerlink" title="未使用的包"></a>未使用的包</h2><p>如果引用了某个包而又不使用其中的任何函数、结构体、接口或者变量，则会编译报错。</p><p>如果真的需要引入这些包(Roy注：比如仅想执行这些包的init函数时)，可以使用<code>_</code>作为包的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    _ <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = log.Println</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简短声明的变量只能在函数内部使用"><a href="#简短声明的变量只能在函数内部使用" class="headerlink" title="简短声明的变量只能在函数内部使用"></a>简短声明的变量只能在函数内部使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">myvar := <span class="number">1</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用简短声明来重复声明变量"><a href="#使用简短声明来重复声明变量" class="headerlink" title="使用简短声明来重复声明变量"></a>使用简短声明来重复声明变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    one,two = two,one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="短声明不能用于给结构体赋值"><a href="#短声明不能用于给结构体赋值" class="headerlink" title="短声明不能用于给结构体赋值"></a>短声明不能用于给结构体赋值</h2><p>错误代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;  </span><br><span class="line">  result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>,error)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span>,<span class="literal">nil</span>  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data info</span><br><span class="line"></span><br><span class="line">  data.result, err := work() <span class="comment">//error</span></span><br><span class="line">  fmt.Printf(<span class="string">"info: %+v\n"</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译错误：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog.<span class="keyword">go</span>:<span class="number">18</span>: non-name data.result on left side of :=</span><br></pre></td></tr></table></figure><p></p><p>即使有方法可以解决这个问题，但go语言之父挺喜欢目前这样的。<br>可以使用临时变量或预先声明所有变量并使用标准赋值操作。</p><p>正确代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;  </span><br><span class="line">  result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>,error)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span>,<span class="literal">nil</span>  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data info</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> err error</span><br><span class="line">  data.result, err = work() <span class="comment">//ok</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"info: %+v\n"</span>,data) <span class="comment">//prints: info: &#123;result:13&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="意外的变量修改"><a href="#意外的变量修改" class="headerlink" title="意外的变量修改"></a>意外的变量修改</h2><p>短声明语法对于从动态语言转go的人来说太方便了，但很容易被误认为是赋值操作，如果你在新的代码块中犯了这个错误，编译不会报错，但也不会如预期那样工作：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    fmt.Println(x)     <span class="comment">//prints 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        fmt.Println(x) <span class="comment">//prints 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        fmt.Println(x) <span class="comment">//prints 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(x)     <span class="comment">//prints 1 (bad if you need 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>对于有一定经验的开发人员这都是一个常见的陷阱，而且很难调试出来。</strong></p><p>可以通过<code>go tool vet -shadow your_file.go</code>命令来进行检测，但注意<code>vet</code>命令并不能检测出所有被覆盖的变量，可以使用<a href="https://github.com/barakmich/go-nyet" target="_blank" rel="noopener">go-nyet</a>来进一步检测。(Roy注：这个已经集成到vet中了，这里仅仅为了保持原文)</p><h2 id="显式类型的变量无法使用nil来初始化"><a href="#显式类型的变量无法使用nil来初始化" class="headerlink" title="显式类型的变量无法使用nil来初始化"></a>显式类型的变量无法使用nil来初始化</h2><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用值为-nil-的-slice、map"><a href="#使用值为-nil-的-slice、map" class="headerlink" title="使用值为 nil 的 slice、map"></a>使用值为 nil 的 slice、map</h2><p>允许对值为<code>nil</code>的slice添加元素，但对值为<code>nil</code>的map添加元素则会造成运行时错误:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    m[<span class="string">"one"</span>] = <span class="number">1</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map容量"><a href="#map容量" class="headerlink" title="map容量"></a>map容量</h2><p>在创建map类型的变量时可以指定容量，但不能像slice一样使用 cap() 来检测分配空间的大小：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>,<span class="number">99</span>)</span><br><span class="line">    <span class="built_in">cap</span>(m) <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="string类型的变量值不能为nil"><a href="#string类型的变量值不能为nil" class="headerlink" title="string类型的变量值不能为nil"></a>string类型的变量值不能为nil</h2><p>string类型的初始值为””而不是<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">string</span> = <span class="literal">nil</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">//error</span></span><br><span class="line">        x = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">string</span> <span class="comment">//defaults to "" (zero value)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">        x = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><p>如果是c或者c++程序，传递数组作为函数参数时是传指针，所以可以在函数内部对数组进行修改。而go中，传递的是值，是一份原始数组的拷贝。所以在函数内部对数组的修改无法影响到外部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x) <span class="comment">//prints [1 2 3] (not ok if you need [7 2 3])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要的话可以使用传递指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr) <span class="comment">//prints &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用slice，即便函数得到的是一份副本，但由于副本指向底层的指针和原来一样，所以可以修改数据：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(Roy注：这里需要了解一下slice的构造，由指向底层数组的指针、len、cap构成，但这个例子里如果超出cap引起底层数组变化，还是有问题。这里原意是修改里面的数据值，而非添加数据。)</p><h2 id="混淆了range遍历slice和array时的返回值"><a href="#混淆了range遍历slice和array时的返回值" class="headerlink" title="混淆了range遍历slice和array时的返回值"></a>混淆了range遍历slice和array时的返回值</h2><p>与其他编程语言中的<code>for-in</code>、<code>foreach</code>语句不同，go中的<code>range</code>在遍历时会返回2个值，第一个是元素索引，第二个是元素的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v) <span class="comment">//prints 0, 1, 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v) <span class="comment">//prints a, b, c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice和array是一维数据"><a href="#slice和array是一维数据" class="headerlink" title="slice和array是一维数据"></a>slice和array是一维数据</h2><p>看上去go中支持多维数组或切片，但实际上并不是。尽管可以创建多维数组或切片，但对于依赖动态多维数组的数值计算型程序，go是远远不够的。</p><p>可以使用原始的一维数组、“独立的”切片、“共享数据”的切片来创建动态的多维数组。</p><p>如果使用原始的一维数组，则需要在数组需要增长时负责索引、边界检查和内存重新分配。</p><p>使用独立的切片来创建动态多维数组分2步：首先创建一个外部切片，然后再分配每个内部切片。内部切片相互独立，所以可以独立的增大或减小他们而不互相影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>,x)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>,y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用共享数据的切片来创建动态多维数组分3步：首先创建一个数据容器切片来存储所有数据，然后创建外部切片，最后切割原始的容器切片来初始化内部切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">int</span>,h*w)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(raw,&amp;raw[<span class="number">4</span>])</span><br><span class="line">    <span class="comment">//prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>,h)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = raw[i*w:i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table,&amp;table[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//prints: [[0 1 2 3] [4 5 6 7]] &lt;ptr_addr_x&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前有增加多维数组和切片的提议，不过优先级比较低。</p><h2 id="访问字典中不存在的key"><a href="#访问字典中不存在的key" class="headerlink" title="访问字典中不存在的key"></a>访问字典中不存在的key</h2><p>这对于习惯使用返回值是否是默认值来判断key是否存在的开发人员来说是个陷阱，go中可以使用第二个返回值来确定key是否存在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>:<span class="string">"a"</span>,<span class="string">"two"</span>:<span class="string">""</span>,<span class="string">"three"</span>:<span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">"two"</span>]; v == <span class="string">""</span> &#123; <span class="comment">//incorrect two是存在的，值为''</span></span><br><span class="line">        fmt.Println(<span class="string">"no entry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>:<span class="string">"a"</span>,<span class="string">"two"</span>:<span class="string">""</span>,<span class="string">"three"</span>:<span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _,ok := x[<span class="string">"two"</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"no entry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串是不可变的"><a href="#字符串是不可变的" class="headerlink" title="字符串是不可变的"></a>字符串是不可变的</h2><p>尝试使用下标改变字符串中的某个字符会报错，字符串是只读的byte slice，如果确实需要更新一个字符串，那么在必要时使用byte slice而不是字符串类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">'T'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xbytes := []<span class="keyword">byte</span>(x)</span><br><span class="line">    xbytes[<span class="number">0</span>] = <span class="string">'T'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(xbytes)) <span class="comment">//prints Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，上面的代码并不是修改字符串中字符的正确方法，</strong> 因为某些字符可能占用多个字节。如果需要的话先将字符串转换为rune切片。即使使用了rune切片，单个字符也可能会占用多个rune，比如字符有grave accent，这种“字符”的复杂和模棱两可的性质是Go字符串被表示为字节序列的原因。</p><h2 id="string和-byte相互转换"><a href="#string和-byte相互转换" class="headerlink" title="string和[]byte相互转换"></a>string和[]byte相互转换</h2><p>当进行string和[]byte的相互转换时得到的是原始数据的完整拷贝，而不是其他语言中的强制转换或分配一个新的切片变量指针指向原始数据同一个底层数组。</p><p>go中做了2点优化来避免转换时分配额外的内存分配：</p><ol><li>在<code>map[string]</code>字典<code>m[string(key)]</code>上使用[]byte来获取内容时。</li><li>在<code>for range</code>操作中将string转换为[]byte时：<code>for i,v := range []byte(str) {...}</code>。</li></ol><h2 id="字符串和索引操作"><a href="#字符串和索引操作" class="headerlink" title="字符串和索引操作"></a>字符串和索引操作</h2><p>在字符串上使用索引下标操作反回的是byte类型，而不是字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>]) <span class="comment">//print 116</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T"</span>,x[<span class="number">0</span>]) <span class="comment">//prints uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要访问字符串中的“字符”(unicode code points/runes)，使用<code>for range</code>操作。内置的<code>unicode/utf8</code>包和实验性的<code>golang.org/x/exp/utf8string</code>包都可以用，utf8string包中有个<code>At()</code>方法。当然把字符串转换成[]runes也可以达到目的。</p><h2 id="字符串并不总是utf8格式"><a href="#字符串并不总是utf8格式" class="headerlink" title="字符串并不总是utf8格式"></a>字符串并不总是utf8格式</h2><p>string的值不必是UTF8文本，可以包含任意的值。只有使用字符串文字字面值时才一定是UTF8文本，字串可以通过转义来包含其他数据。</p><p>判断字符串是否是UTF8文本，可使用”unicode/utf8”包中的<code>ValidString()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data1 := <span class="string">"ABC"</span></span><br><span class="line">    fmt.Println(utf8.ValidString(data1)) <span class="comment">//prints: true</span></span><br><span class="line"></span><br><span class="line">    data2 := <span class="string">"A\xfeC"</span></span><br><span class="line">    fmt.Println(utf8.ValidString(data2)) <span class="comment">//prints: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>假设你是一个python开发者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">u'♥'</span>  </span><br><span class="line">print(len(data)) <span class="comment">#prints: 1</span></span><br></pre></td></tr></table></figure><p>但在go中：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data)) <span class="comment">//prints: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>内置的<code>len()</code>函数返回字节长度替代了字符长度。</p><p>想得到同样的结果使用<code>unicode/utf8</code>包的<code>RuneCountInString()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(data)) <span class="comment">//prints: 1</span></span><br></pre></td></tr></table></figure><p>注意这个函数反悔的并不是字符长度，因为单个字符可能占用多个rune：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"é"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data))                    <span class="comment">//prints: 3</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(data)) <span class="comment">//prints: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="在多行array、slice、map语句中缺少逗号"><a href="#在多行array、slice、map语句中缺少逗号" class="headerlink" title="在多行array、slice、map语句中缺少逗号"></a>在多行array、slice、map语句中缺少逗号</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span> <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    x = x</span><br><span class="line"></span><br><span class="line">    y := []<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">4</span>,&#125; <span class="comment">//no error</span></span><br><span class="line">    y = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将声明写为一行时最后的逗号，不会报编译错误。</p><h2 id="log-Fatal和log-Painc"><a href="#log-Fatal和log-Painc" class="headerlink" title="log.Fatal和log.Painc"></a>log.Fatal和log.Painc</h2><p>logging库通常提供不同的日志等级，而go中的<code>Fatal*()</code>和<code>Panic*()</code>函数不仅仅输出日志还会停止程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    log.Fatalln(<span class="string">"Fatal Level: log entry"</span>) <span class="comment">//app exits here</span></span><br><span class="line">    log.Println(<span class="string">"Normal Level: log entry"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对内置数据结构的操作并不是同步的"><a href="#对内置数据结构的操作并不是同步的" class="headerlink" title="对内置数据结构的操作并不是同步的"></a>对内置数据结构的操作并不是同步的</h2><p>尽管go天生支持并发编程，但并不保证并发操作数据安全。开发人员需要自己负责确保数据操作的原子性。goroutine和channel是实现原子操做的推荐方法，当然需要的话也可以使用<code>sync</code>包。</p><h2 id="对string使用range操作得到的值"><a href="#对string使用range操作得到的值" class="headerlink" title="对string使用range操作得到的值"></a>对string使用range操作得到的值</h2><p>使用range对string进行迭代时，得到的索引(返回的第一个值)时当前“字符”（返回的第二个值）的第一个字节位置，而非当前字符的位置。而一个字符可以由多个rune组成。如果需要对字符进行操作，确保使用<code>norm</code>（golang.org/x/text/unicode/norm）包来进行检查。</p><p><code>for range</code>操作会尝试将字符串当utf8类型，对于任何它不理解的字节序列都会返回<code>0xfffd</code>来替代真实数值。如果你有特殊值存在字符串中，确保转换成byte切片来获取全部数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"A\xfe\x02\xff\x04"</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> []<span class="keyword">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prints: 0x41 0xfe 0x2 0xff 0x4 (good)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对map进行range操作"><a href="#对map进行range操作" class="headerlink" title="对map进行range操作"></a>对map进行range操作</h2><p><strong>map是无序的！！</strong> go运行时会尽可能的打乱返回顺序，但这并不能每次都成功。所以连续得到5个相同的顺序也有可能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>:<span class="number">1</span>,<span class="string">"two"</span>:<span class="number">2</span>,<span class="string">"three"</span>:<span class="number">3</span>,<span class="string">"four"</span>:<span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在go playground来执行上面的代码，你总会得到同样的顺序，因为这个网站除非你改了代码，否则并不会重新编译代码。</p><h2 id="switch中的fallthrough语句"><a href="#switch中的fallthrough语句" class="headerlink" title="switch中的fallthrough语句"></a>switch中的fallthrough语句</h2><p>switch语句中case分支默认自带break，这和默认执行下一个case的语言略有不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>: <span class="comment">//error</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>)) <span class="comment">//prints true (ok)</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">' '</span>))  <span class="comment">//prints false (not ok)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>fallthrough</code>关键字来强制当前case块执行完成后执行下一个case块，当然也可以改写case条件为表达式列表来实现同样功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'\t'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>)) <span class="comment">//prints true (ok)</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">' '</span>))  <span class="comment">//prints true (ok)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自增和自减操作"><a href="#自增和自减操作" class="headerlink" title="自增和自减操作"></a>自增和自减操作</h2><p>自增自减操作在很多语言中都提供，不过go中不支持前置的这两种操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i <span class="comment">//error</span></span><br><span class="line">    fmt.Println(data[i++]) <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h2><p>很多语言中使用<code>~</code>来进行取反，但go中复用了XOR操作符<code>^</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(~<span class="number">2</span>) <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d <span class="keyword">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%08b\n"</span>,^d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能让人困惑，如果你愿意，可以使用XOR操作来代替一元的取反操作，比如使用<code>0x02 XOR 0xFF</code> 替代 <code>NOT 0x02</code>，这也解释了为什么<code>^</code>可以重用来进行取反操作了。</p><p>go中也提供了一个特殊的操作符<code>&amp;^</code>来执行<code>AND NOT</code>操作，但这增加了NOT操作的混乱性。这看上去就像是没有括号的<code>A AND (NOT B)</code>操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">"%08b [A]\n"</span>,a)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b [B]\n"</span>,b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%08b (NOT B)\n"</span>,^b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b ^ %08b = %08b [B XOR 0xff]\n"</span>,b,<span class="number">0xff</span>,b ^ <span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%08b ^ %08b = %08b [A XOR B]\n"</span>,a,b,a ^ b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b &amp; %08b = %08b [A AND B]\n"</span>,a,b,a &amp; b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b &amp;^%08b = %08b [A 'AND NOT' B]\n"</span>,a,b,a &amp;^ b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n"</span>,a,b,a &amp; (^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>除了<code>&amp;^</code>，go也提供了和其他语言一样的标准运算符，但优先级并不总和其他的一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"0x2 &amp; 0x2 + 0x4 -&gt; %#x\n"</span>,<span class="number">0x2</span> &amp; <span class="number">0x2</span> + <span class="number">0x4</span>)</span><br><span class="line">    <span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">    <span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n"</span>,<span class="number">0x2</span> + <span class="number">0x2</span> &lt;&lt; <span class="number">0x1</span>)</span><br><span class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"0xf | 0x2 ^ 0x2 -&gt; %#x\n"</span>,<span class="number">0xf</span> | <span class="number">0x2</span> ^ <span class="number">0x2</span>)</span><br><span class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不导出的struct字段无法被encode"><a href="#不导出的struct字段无法被encode" class="headerlink" title="不导出的struct字段无法被encode"></a>不导出的struct字段无法被encode</h2><p>小写字母开头的字段成员是无法被外部直接访问的，所以<code>struct</code>在进行json、xml、gob等格式的encode操作时，这些私有字段会被忽略，导出时得到零值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyData <span class="keyword">struct</span> &#123;  </span><br><span class="line">    One <span class="keyword">int</span></span><br><span class="line">    two <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    in := MyData&#123;<span class="number">1</span>,<span class="string">"two"</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>,in) <span class="comment">//prints main.MyData&#123;One:1, two:"two"&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded,_ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(encoded)) <span class="comment">//prints &#123;"One":1&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded,&amp;out)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>,out) <span class="comment">//prints main.MyData&#123;One:1, two:""&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序结束时还有goroutine在运行"><a href="#程序结束时还有goroutine在运行" class="headerlink" title="程序结束时还有goroutine在运行"></a>程序结束时还有goroutine在运行</h2><p>程序并不等待所有的goroutine运行完才结束，这是一个新手常见的错误，不需要觉得害羞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doit(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doit</span><span class="params">(workerId <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0] is running </span><br><span class="line">[1] is running </span><br><span class="line">all done!</span><br></pre></td></tr></table></figure><p>一个常见的解决方案是使用<code>WaitGroup</code>，他将阻塞主goroutine等待其他goroutine执行完成。如果goroutine需要长时间运行的来处理消息，可以直接发送kill命令给每个goroutine,或者关闭所有goroutin都需要接收的channel，这里有个简单的方法一次性通知所有goroutine:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doit(i,done,wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doit</span><span class="params">(workerId <span class="keyword">int</span>,done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,wg sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;- done</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>] is running </span><br><span class="line">[<span class="number">0</span>] is done </span><br><span class="line">[<span class="number">1</span>] is running </span><br><span class="line">[<span class="number">1</span>] is done</span><br></pre></td></tr></table></figure><p>看起来好像是所有的goroutine都已经执行完成了，然而你会看到报错：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>WTF??这个问题的主要原因在于每个goroutine得到的都是原始WaitGroup的一个副本，当goroutine内部执行<code>wg.Done()</code>时，并不会影响主goroutine中的WaitGroup：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    wq := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doit(i,wq,done,&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wq &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doit</span><span class="params">(workerId <span class="keyword">int</span>, wq &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;- wq:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] m =&gt; %v\n"</span>,workerId,m)</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码才是正确的姿势。（Roy注：总之一句话，当把WaitGroup传递给goroutine时请传递指针）</p><h2 id="向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行"><a href="#向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行" class="headerlink" title="向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行"></a>向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行</h2><p>发送方不会阻塞直到接收方处理这个消息。取决于运行下列代码的环境，接收方可能有时间处理消息也可能来不及处理消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">"processed:"</span>,m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">"cmd.1"</span></span><br><span class="line">    ch &lt;- <span class="string">"cmd.2"</span> <span class="comment">//won't be processed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Roy注：上面的代码可能执行多次结果不同，有时候可以看到”processed cmd.2”，有时候主goroutine把cmd.2丢掉channel里就结束退出了。但如果goroutine中一直没有处理channel中的消息，那么程序就会一直阻塞等待channel中cmd.1这个数据被消费而报错)</p><h2 id="向close的channel发送数据会panic"><a href="#向close的channel发送数据会panic" class="headerlink" title="向close的channel发送数据会panic"></a>向close的channel发送数据会panic</h2><p>从一个已经关闭的channel读取数据时安全的，如果<code>ok</code>字段接收到的值为<code>false</code>则代表没有数据可以接受了（Roy注：这里应该是指channel关闭了），对于有缓冲的channel，会将缓存中的数据全部取出后<code>ok</code>返回<code>false</code>。</p><p>向一个关闭的channel发送数据会引发panic，虽然文档中记录很清楚，但很多新人还是会掉进这个坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the first result</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(ch) <span class="comment">//not ok (you still have other senders)</span></span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据程序不同，修改方法也是不同的，可以大改也可以小改，但不论如何都要保证程序不会向关闭的channel发送数据。</p><p>上面的例子可以使用一个专门用于通知取消的channel来进行修复：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>: fmt.Println(idx,<span class="string">"sent result"</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;- done: fmt.Println(idx,<span class="string">"exiting"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get first result</span></span><br><span class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nil值的channel"><a href="#nil值的channel" class="headerlink" title="nil值的channel"></a>nil值的channel</h2><p>对一个nil值的channel读取或发送数据会永远阻塞，文档里也写的挺清楚，不过还是有新手会跳进这个坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get first result</span></span><br><span class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个代码将会报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p><p>不过这个特性也可以作为一种实现动态启停case块的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    inch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    outch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;- <span class="keyword">chan</span> <span class="keyword">int</span> = inch</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span> &lt;- <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inch</span><br><span class="line">            <span class="keyword">case</span> val = &lt;- in:</span><br><span class="line">                out = outch</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outch &#123;</span><br><span class="line">            fmt.Println(<span class="string">"result:"</span>,r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inch &lt;- <span class="number">1</span></span><br><span class="line">    inch &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用值传递的方法不能改变参数原有值"><a href="#使用值传递的方法不能改变参数原有值" class="headerlink" title="使用值传递的方法不能改变参数原有值"></a>使用值传递的方法不能改变参数原有值</h2><p>结构体方法的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p><p>例外是map或slice类型的变量，并且是以指针方式更新map中的字段、slice中的元素的，才会更新原有值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">    key *<span class="keyword">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span> <span class="title">pmethod</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span> <span class="title">vmethod</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">"v.key"</span></span><br><span class="line">    this.items[<span class="string">"vmethod"</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    key := <span class="string">"key.1"</span></span><br><span class="line">    d := data&#123;<span class="number">1</span>,&amp;key,<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items)</span><br><span class="line">    <span class="comment">//prints num=1 key=key.1 items=map[]</span></span><br><span class="line"></span><br><span class="line">    d.pmethod()</span><br><span class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items) </span><br><span class="line">    <span class="comment">//prints num=7 key=key.1 items=map[]</span></span><br><span class="line"></span><br><span class="line">    d.vmethod()</span><br><span class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items)</span><br><span class="line">    <span class="comment">//prints num=7 key=v.key items=map[vmethod:true]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭HTTP响应体"><a href="#关闭HTTP响应体" class="headerlink" title="关闭HTTP响应体"></a>关闭HTTP响应体</h2><p>当使用标准http库获取响应时，即便不需要获取响应体的内容也需要手动关闭它，即便是一个空响应也是如此。这点很容易忘记，或者方法不对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()<span class="comment">//not ok</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在响应成功时没问题，但如果响应失败，<code>resp</code>为nil，就会引发运行时错误。</p><p>最常见的方法是在检查响应后使用<code>defer</code>关闭响应体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()<span class="comment">//ok, most of the time :-)</span></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况，当http请求失败时resp将会是nil，err是非空值。然而如果得到的是重定向失败这2者都是非空值，也就是说程序还会泄露。</p><p>可以通过在http响应错误时的处理代码中来进行关闭，另一个方法则是使用一次<code>defer</code>调用来处理所有成功或失败的响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早先版本的<code>resp.Body.Close()</code>实现是读取响应体的数据之后丢弃，保证了keep-alive的HTTP连接能重用处理不止一个请求。但Go的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP连接可能会直接关闭而非重用，参考在Go1.5版本文档。</p><p>如果重用http链接对你的程序是否重要，你也许需要添加类似下面的代码在响应处理逻辑中：</p><p><code>_, err = io.Copy(ioutil.Discard, resp.Body)</code></p><p>如果使用正确的方法读取全部的响应体，这是非常重要的。比如你处理一个json api的响应时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)</span><br></pre></td></tr></table></figure><h2 id="关闭HTTP连接"><a href="#关闭HTTP连接" class="headerlink" title="关闭HTTP连接"></a>关闭HTTP连接</h2><p>有些HTTP服务器会通过使用<code>keep-alive</code>来保持连接，而默认情况下标准http库只有当服务器要求时才会关闭连接。也就是说，你的程序可能会在某种场景下耗尽socket描述符。</p><p>可以通过设置<code>Close</code>字段的值为true，来要求标准http库在请求完成后关闭连接。</p><p>另一个选项是添加<code>Connection</code>请求头并设置为<code>close</code>。目标服务器收到后会返回响应并在header中携带<code>Connection: close</code>，当标准库收到这个响应头就会关闭连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>,<span class="string">"http://golang.org"</span>,<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.Close = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//or do this:</span></span><br><span class="line">    <span class="comment">//req.Header.Add("Connection", "close")</span></span><br><span class="line"></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="keyword">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以全局禁用掉http连接复用功能，这需要创建一个自定义http transport：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    tr := &amp;http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := client.Get(<span class="string">"http://golang.org"</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(resp.StatusCode)</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="keyword">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要发送很多请求到同一个HTTP服务器，保持连接是没问题的。然而，如果程序在短时间内向许多不同的HTTP服务器发送请求，那么收到响应后立即关闭网络连接是一个好主意。</p><p>或者提高文件描述符数量限制也是个好主意，取决于实际情况来选择解决方案。</p><h2 id="JSON解码时会添加换行符"><a href="#JSON解码时会添加换行符" class="headerlink" title="JSON解码时会添加换行符"></a>JSON解码时会添加换行符</h2><p>当使用JSON Encoder 对象时，那么将在编码后的JSON对象的末尾获得一个额外的换行符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"key"</span>: <span class="number">1</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">  json.NewEncoder(&amp;b).Encode(data)</span><br><span class="line"></span><br><span class="line">  raw,_ := json.Marshal(data)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> b.String() == <span class="keyword">string</span>(raw) &#123;</span><br><span class="line">    fmt.Println(<span class="string">"same encoded data"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"'%s' != '%s'\n"</span>,raw,b.String())</span><br><span class="line">    <span class="comment">//prints:</span></span><br><span class="line">    <span class="comment">//'&#123;"key":1&#125;' != '&#123;"key":1&#125;\n'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON encoder对象是为了流设计的，使用JSON流通常意味着以换行符分隔的JSON对象，这就是Encode方法添加换行符的原因。文档中有写，不过通常被忽略。</p><h2 id="JSON包转义键和字符串值中的特殊HTML字符"><a href="#JSON包转义键和字符串值中的特殊HTML字符" class="headerlink" title="JSON包转义键和字符串值中的特殊HTML字符"></a>JSON包转义键和字符串值中的特殊HTML字符</h2><p>这也是文档里有的，不过需要特别仔细的查看所有JSON相关的文档才能发现这个。 <code>SetEscapeHTML</code>方法描述了关于一些特殊字符的encoding默认行为。</p><p>这是一个很糟糕的设计，首先你不能禁用这个行为在<code>json.Marshal</code>时，其次这引起很糟糕的安全问题因为它假设所有的web程序都能够做出充足的xss漏洞检测。最后它假设所有的用例都是为了web页面的，打破了默认的REST/HTTP APIs配置库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data := <span class="string">"x &lt; y"</span></span><br><span class="line">  </span><br><span class="line">  raw,_ := json.Marshal(data)</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(raw))</span><br><span class="line">  <span class="comment">//prints: "x \u003c y" &lt;- probably not what you expected</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> b1 bytes.Buffer</span><br><span class="line">  json.NewEncoder(&amp;b1).Encode(data)</span><br><span class="line">  fmt.Println(b1.String())</span><br><span class="line">  <span class="comment">//prints: "x \u003c y" &lt;- probably not what you expected</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> b2 bytes.Buffer</span><br><span class="line">  enc := json.NewEncoder(&amp;b2)</span><br><span class="line">  enc.SetEscapeHTML(<span class="literal">false</span>)</span><br><span class="line">  enc.Encode(data)</span><br><span class="line">  fmt.Println(b2.String())</span><br><span class="line">  <span class="comment">//prints: "x &lt; y" &lt;- looks better</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将JSON中的数字解码为interface类型"><a href="#将JSON中的数字解码为interface类型" class="headerlink" title="将JSON中的数字解码为interface类型"></a>将JSON中的数字解码为interface类型</h2><p>默认情况下，go在编码、解码时将JSON中的数值型数据转化为<code>float64</code>类型，也就是说下面的代码会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status = result[<span class="string">"status"</span>].(<span class="keyword">int</span>) <span class="comment">//error</span></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几种方法处理：</p><p>使用float类型声明字典值的类型。</p><p>将float类型转换为需要的整型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status = <span class="keyword">uint64</span>(result[<span class="string">"status"</span>].(<span class="keyword">float64</span>)) <span class="comment">//ok</span></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Decoder</code>来解码并指定使用数字类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">  decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status,_ = result[<span class="string">"status"</span>].(json.Number).Int64() <span class="comment">//ok</span></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用字符串来表示数值类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">  decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status <span class="keyword">uint64</span></span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(result[<span class="string">"status"</span>].(json.Number).String()), &amp;status); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用结构体来接收转码后的数据并定义需要的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status <span class="keyword">uint64</span> <span class="string">`json:"status"`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"result =&gt; %+v"</span>,result)</span><br><span class="line">  <span class="comment">//prints: result =&gt; &#123;Status:200&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要延时解码或某个字段类型是可变的，可以使用结构体结合<code>json.RawMessage</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  records := [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">    []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200, "tag":"one"&#125;`</span>),</span><br><span class="line">    []<span class="keyword">byte</span>(<span class="string">`&#123;"status":"ok", "tag":"two"&#125;`</span>),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">      StatusCode <span class="keyword">uint64</span></span><br><span class="line">      StatusName <span class="keyword">string</span></span><br><span class="line">      Status json.RawMessage <span class="string">`json:"status"`</span></span><br><span class="line">      Tag <span class="keyword">string</span>             <span class="string">`json:"tag"`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sstatus <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(result.Status, &amp;sstatus); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      result.StatusName = sstatus</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nstatus <span class="keyword">uint64</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(result.Status, &amp;nstatus); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      result.StatusCode = nstatus</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"[%v] result =&gt; %+v\n"</span>,idx,result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON字符串值不适合十六进制或其他非utf8转义序列"><a href="#JSON字符串值不适合十六进制或其他非utf8转义序列" class="headerlink" title="JSON字符串值不适合十六进制或其他非utf8转义序列"></a>JSON字符串值不适合十六进制或其他非utf8转义序列</h2><p>go期望所有的字符串都是utf8编码，这意味着不能在JSON字符串中使用任意十六进制转义的二进制数据(还必须转义反斜杠字符)，这是一个非常常见的坑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="keyword">string</span> <span class="string">`json:"data"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  raw := []<span class="keyword">byte</span>(<span class="string">`&#123;"data":"\xc2"&#125;`</span>)</span><br><span class="line">  <span class="keyword">var</span> decoded config</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(raw, &amp;decoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    <span class="comment">//prints: invalid character 'x' in string escape code</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你确实需要在字符串中使用反斜杠，确保用另一个反斜杠来转义它。如果想使用十六进制编码的二进制数据，可以转义反斜杠，然后将十六进制转义与解码数据存在JSON字符串中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="keyword">string</span> <span class="string">`json:"data"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  raw := []<span class="keyword">byte</span>(<span class="string">`&#123;"data":"\\xc2"&#125;`</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> decoded config</span><br><span class="line">  </span><br><span class="line">  json.Unmarshal(raw, &amp;decoded)</span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"%#v"</span>,decoded) <span class="comment">//prints: main.config&#123;Data:"\\xc2"&#125;</span></span><br><span class="line">  <span class="comment">//todo: do your own hex escape decoding for decoded.Data  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方式就是在json中使用byte数组或切片，但这需要将数据进行base64编码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data []<span class="keyword">byte</span> <span class="string">`json:"data"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  raw := []<span class="keyword">byte</span>(<span class="string">`&#123;"data":"wg=="&#125;`</span>)</span><br><span class="line">  <span class="keyword">var</span> decoded config</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(raw, &amp;decoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"%#v"</span>,decoded) <span class="comment">//prints: main.config&#123;Data:[]uint8&#123;0xc2&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他需要注意的是Unicode替换字符(U+FFFD)。go将使用替换字符而不是无效的UTF8，因此Unmarshal/Decode调用不会失败，但获得的字符串值可能不是预期的。</p><h2 id="比较结构体、数组、切片和字典"><a href="#比较结构体、数组、切片和字典" class="headerlink" title="比较结构体、数组、切片和字典"></a>比较结构体、数组、切片和字典</h2><p>可以使用相等运算符<code>==</code>来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">    fp <span class="keyword">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">complex64</span></span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">    char <span class="keyword">rune</span></span><br><span class="line">    yes <span class="keyword">bool</span></span><br><span class="line">    events &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref *<span class="keyword">byte</span></span><br><span class="line">    raw [<span class="number">10</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,v1 == v2) <span class="comment">//prints: v1 == v2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果任何成员是不可比较的，则会报错。需要注意，只有在其中元素是可以比较的类型时数组才是可以比较的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span>                <span class="comment">//ok</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span> //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">doit</span> <span class="title">func</span><span class="params">()</span> <span class="title">bool</span>       //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">m</span> <span class="title">map</span>[<span class="title">string</span>] <span class="title">string</span>   //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">bytes</span> []<span class="title">byte</span>           //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go中也提供了很多函数来进行比较操作，最常用的就是reflect包中的<code>DeepEqual()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span>                <span class="comment">//ok</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span> //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">doit</span> <span class="title">func</span><span class="params">()</span> <span class="title">bool</span>       //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">m</span> <span class="title">map</span>[<span class="title">string</span>] <span class="title">string</span>   //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">bytes</span> []<span class="title">byte</span>           //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,reflect.DeepEqual(v1,v2)) <span class="comment">//prints: v1 == v2: true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"a"</span>,<span class="string">"two"</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"two"</span>: <span class="string">"b"</span>, <span class="string">"one"</span>: <span class="string">"a"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"m1 == m2:"</span>,reflect.DeepEqual(m1, m2)) <span class="comment">//prints: m1 == m2: true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"s1 == s2:"</span>,reflect.DeepEqual(s1, s2)) <span class="comment">//prints: s1 == s2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了速度慢一点外，这个函数也有个小陷阱：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="keyword">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"b1 == b2:"</span>,reflect.DeepEqual(b1, b2)) <span class="comment">//prints: b1 == b2: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DeepEqual()</code>并不认为空切片和nil切片相同。这个行为和<code>bytes.Equal()</code>不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="keyword">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"b1 == b2:"</span>,bytes.Equal(b1, b2)) <span class="comment">//prints: b1 == b2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>DeepEqual()</code>不推荐用来比较切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"one"</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">"one"</span></span><br><span class="line">    fmt.Println(<span class="string">"str == in:"</span>,str == in,reflect.DeepEqual(str, in)) </span><br><span class="line">    <span class="comment">//prints: str == in: true true</span></span><br><span class="line"></span><br><span class="line">    v1 := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125;</span><br><span class="line">    v2 := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,reflect.DeepEqual(v1, v2)) </span><br><span class="line">    <span class="comment">//prints: v1 == v2: false (not ok)</span></span><br><span class="line"></span><br><span class="line">    data := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">"value"</span>: []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    encoded, _ := json.Marshal(data)</span><br><span class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">    fmt.Println(<span class="string">"data == decoded:"</span>,reflect.DeepEqual(data, decoded)) </span><br><span class="line">    <span class="comment">//prints: data == decoded: false (not ok)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要大小写不敏感来比较byte或string中的英文文本，可以使用bytes或strings包的<code>ToUpper()</code>和<code>ToLower()</code>函数将大小写统一后再使用<code>==</code>、<code>bytes.Equal()</code>或<code>bytes.Compare()</code>比较。比较非英语的byte或string，应使用<code>bytes.EqualFold()</code>和<code>strings.EqualFold()</code>。</p><p>如果byte切片中含有验证用户身份的数据（密文哈希、token 等），不应再使用<code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、<code>bytes.Compare()</code>。这三个函数容易对程序造成<a href="http://en.wikipedia.org/wiki/Timing_attack" target="_blank" rel="noopener">timing attacks</a>，此时应使用<code>crypto/subtle</code>包中的<code>subtle.ConstantTimeCompare()</code>等函数。</p><h2 id="从panic中恢复"><a href="#从panic中恢复" class="headerlink" title="从panic中恢复"></a>从panic中恢复</h2><p>在defer函数中 <strong>直接调用</strong> <code>recover()</code>函数可以捕获、中断panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="built_in">recover</span>() <span class="comment">//doesn't do anything</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">    <span class="built_in">recover</span>() <span class="comment">//won't be executed :)</span></span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"recovered:"</span>,<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"recovered =&gt;"</span>,<span class="built_in">recover</span>()) <span class="comment">//prints: recovered =&gt; &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover() <span class="comment">//panic is not recovered</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice-Array-Map在range语句中更新引用元素的值"><a href="#Slice-Array-Map在range语句中更新引用元素的值" class="headerlink" title="Slice,Array,Map在range语句中更新引用元素的值"></a>Slice,Array,Map在range语句中更新引用元素的值</h2><p>在range操作中得到的值是原始元素的拷贝，也就是说对其修改并不会影响原始数据，换言之得到的指针也不会指向原始数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span> <span class="comment">//original item is not changed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"data:"</span>,data) <span class="comment">//prints data: [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想修改原始数据，可以通过索引的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i,_ := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"data:"</span>,data) <span class="comment">//prints data: [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的集合保存的是指针，那规则会稍有不同。</p><p>如果要更新原有记录指向的数据，你依然需要使用索引操作，但你可以使用for range语句中的第二个值来更新存储在目标位置的数据:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123;num <span class="keyword">int</span>&#125; &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data[<span class="number">0</span>],data[<span class="number">1</span>],data[<span class="number">2</span>]) <span class="comment">//prints &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice中的隐藏数据"><a href="#slice中的隐藏数据" class="headerlink" title="slice中的隐藏数据"></a>slice中的隐藏数据</h2><p>当你重新划分一个slice时，新的slice将引用原有slice的数组。如果你忘了这个行为的话，在你的应用分配大量临时的slice用于创建新的slice来引用原有数据的一小部分时，会导致难以预期的内存使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;  </span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw),<span class="built_in">cap</span>(raw),&amp;raw[<span class="number">0</span>]) <span class="comment">//prints: 10000 10000 &lt;byte_addr_x&gt;</span></span><br><span class="line">    <span class="keyword">return</span> raw[:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data),<span class="built_in">cap</span>(data),&amp;data[<span class="number">0</span>]) <span class="comment">//prints: 3 10000 &lt;byte_addr_x&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这样要确保从临时的slice中拷贝数据（而不是重新划分slice）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;  </span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw),<span class="built_in">cap</span>(raw),&amp;raw[<span class="number">0</span>]) <span class="comment">//prints: 10000 10000 &lt;byte_addr_x&gt;</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res,raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data),<span class="built_in">cap</span>(data),&amp;data[<span class="number">0</span>]) <span class="comment">//prints: 3 3 &lt;byte_addr_y&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice数据“损坏”"><a href="#slice数据“损坏”" class="headerlink" title="slice数据“损坏”"></a>slice数据“损坏”</h2><p>假设需要重新一个路径（在slice中保存）。你通过修改第一个文件夹的名字，然后把名字合并来创建新的路劲，来重新划分指向各个文件夹的路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    path := []<span class="keyword">byte</span>(<span class="string">"AAAA/BBBBBBBBB"</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path,<span class="string">'/'</span>)</span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1,<span class="string">"suffix"</span>...)</span><br><span class="line">    path = bytes.Join([][]<span class="keyword">byte</span>&#123;dir1,dir2&#125;,[]<span class="keyword">byte</span>&#123;<span class="string">'/'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB (not ok)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"new path =&gt;"</span>,<span class="keyword">string</span>(path))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果与你想的不一样。与”AAAAsuffix/BBBBBBBBB”相反，你将会得到”AAAAsuffix/uffixBBBB”。这个情况的发生是因为两个文件夹的slice都潜在的引用了同一个原始的路径slice。这意味着原始路径也被修改了。根据你的应用，这也许会是个问题。</p><p>通过分配新的slice并拷贝需要的数据，你可以修复这个问题。另一个选择是使用完整的slice表达式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    path := []<span class="keyword">byte</span>(<span class="string">"AAAA/BBBBBBBBB"</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path,<span class="string">'/'</span>)</span><br><span class="line">    dir1 := path[:sepIndex:sepIndex] <span class="comment">//full slice expression</span></span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1,<span class="string">"suffix"</span>...)</span><br><span class="line">    path = bytes.Join([][]<span class="keyword">byte</span>&#123;dir1,dir2&#125;,[]<span class="keyword">byte</span>&#123;<span class="string">'/'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB (ok now)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"new path =&gt;"</span>,<span class="keyword">string</span>(path))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的slice表达式中的额外参数可以控制新的slice的容量。现在在那个slice后添加元素将会触发一个新的buffer分配，而不是覆盖第二个slice中的数据。</p><h2 id="陈旧的slices"><a href="#陈旧的slices" class="headerlink" title="陈旧的slices"></a>陈旧的slices</h2><p>多个slice可以引用同一个数据。比如，当从一个已有的slice创建一个新的slice时，这就会发生。如果你的应用功能需要这种行为，那么你将需要关注下“陈旧的”slice。</p><p>在某些情况下，在一个slice中添加新的数据，在原有数组无法保持更多新的数据时，将导致分配一个新的数组。而现在其他的slice还指向老的数组（和老的数据）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1),s1) <span class="comment">//prints 3 3 [1 2 3]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2),<span class="built_in">cap</span>(s2),s2) <span class="comment">//prints 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123; s2[i] += <span class="number">20</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//still referencing the same array</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//prints [1 22 23]</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//prints [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123; s2[i] += <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1 is now "stale"</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//prints [1 22 23]</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//prints [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Roy注：凡是用到slice操作的时候一定要注意底层指向的数组是不是同一个。）</p><h2 id="类型声明和方法"><a href="#类型声明和方法" class="headerlink" title="类型声明和方法"></a>类型声明和方法</h2><p>当使用旧类型（非interface）创建新的类型时，新类型并不会继承旧类型的方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> mtx myMutex</span><br><span class="line">    mtx.Lock() <span class="comment">//error</span></span><br><span class="line">    mtx.Unlock() <span class="comment">//error  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你确实需要原有类型的方法，你可以定义一个新的struct类型，用匿名方式把原有类型嵌入其中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;  </span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> lock myLocker</span><br><span class="line">    lock.Lock() <span class="comment">//ok</span></span><br><span class="line">    lock.Unlock() <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型声明也会继承原有的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> lock myLocker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">    lock.Lock() <span class="comment">//ok</span></span><br><span class="line">    lock.Unlock() <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从”for-switch”和”for-select”代码块中跳出"><a href="#从”for-switch”和”for-select”代码块中跳出" class="headerlink" title="从”for switch”和”for select”代码块中跳出"></a>从”for switch”和”for select”代码块中跳出</h2><p>没有标签的“break”声明只能从内部的switch/select代码块中跳出来。如果无法使用“return”声明的话，那就为外部循环定义一个标签是另一个好的选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    loop:</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">                fmt.Println(<span class="string">"breaking out..."</span>)</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"out!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goto</code>语句也是同理。</p><h2 id="for循环中的迭代和闭包"><a href="#for循环中的迭代和闭包" class="headerlink" title="for循环中的迭代和闭包"></a>for循环中的迭代和闭包</h2><p>这是一个很常见的陷阱，for语句中的迭代变量在每次迭代时被重新使用，也就是for循环中每个闭包（又名函数字面量）都会引用相同的变量（并且goroutine执行时会得到这个变量）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: three, three, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的解决办法（不需要改goroutine）就是在for循环语句中创建一个本地变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        vcopy := v <span class="comment">//</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(vcopy)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决办法就是把变量当做参数传递给goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个陷阱还有个复杂的版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: three, three, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v := v</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>猜猜下面的代码输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []*field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Roy注：会输出 one tow three 顺序随机，因为传递的是地址)</p><h2 id="Defer函数调用参数的求值"><a href="#Defer函数调用参数的求值" class="headerlink" title="Defer函数调用参数的求值"></a>Defer函数调用参数的求值</h2><p>对defer延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"result =&gt;"</span>,<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">    <span class="comment">//prints: result =&gt; 2 (not ok if you expected 4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但对于指针类型又有所不同：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">(in *<span class="keyword">int</span>)</span></span> &#123; fmt.Println(<span class="string">"result =&gt;"</span>, *in) &#125;(&amp;i)</span><br><span class="line">  </span><br><span class="line">  i = <span class="number">2</span></span><br><span class="line">  <span class="comment">//prints: result =&gt; 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="defer函数执行时机"><a href="#defer函数执行时机" class="headerlink" title="defer函数执行时机"></a>defer函数执行时机</h2><p>对defer延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p><p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start, err := os.Stat(os.Args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir()&#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="keyword">string</span></span><br><span class="line">    filepath.Walk(os.Args[<span class="number">1</span>], <span class="function"><span class="keyword">func</span><span class="params">(fpath <span class="keyword">string</span>, fi os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fi.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets,fpath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"bad target:"</span>,target,<span class="string">"error:"</span>,err) <span class="comment">//prints error: too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">//will not be closed at the end of this code block</span></span><br><span class="line">        <span class="comment">//do something with the file...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法之一就是增加一层函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start, err := os.Stat(os.Args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir()&#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="keyword">string</span></span><br><span class="line">    filepath.Walk(os.Args[<span class="number">1</span>], <span class="function"><span class="keyword">func</span><span class="params">(fpath <span class="keyword">string</span>, fi os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fi.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets,fpath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"bad target:"</span>,target,<span class="string">"error:"</span>,err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close() <span class="comment">//ok</span></span><br><span class="line">            <span class="comment">//do something with the file...</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者去掉defer，直接调用<code>f.Close()</code>。</p><h2 id="失败的类型断言"><a href="#失败的类型断言" class="headerlink" title="失败的类型断言"></a>失败的类型断言</h2><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int] value =&gt;"</span>,data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int] value =&gt;"</span>,data) </span><br><span class="line">        <span class="comment">//prints: [not an int] value =&gt; 0 (not "great")</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int] value =&gt;"</span>,res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int] value =&gt;"</span>,data) </span><br><span class="line">        <span class="comment">//prints: [not an int] value =&gt; great (as expected)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞的Goroutine和资源泄露"><a href="#阻塞的Goroutine和资源泄露" class="headerlink" title="阻塞的Goroutine和资源泄露"></a>阻塞的Goroutine和资源泄露</h2><p>Rob Pike在2012年的Google I/O大会上所做的“Go Concurrency Patterns”的演讲上，说道过几种基础的并发模式。从一组目标中获取第一个结果就是其中之一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数每次循环时都会启动goroutine来进行数据处理，将第一个值写入到channel中。</p><p>那么其他的goroutine的搜索结果怎么处理？关于这些goroutine本身又会如何？</p><p>Frist函数中result这个channel是无缓冲的，也就是说只有第一个goroutine会返回并结束，而其他的goroutine将阻塞到向channel中写数据的地方。也就是说造成了资源泄露。</p><p>避免这个问题需要保证所有的goroutine都退出，一种解决方案就是使用有缓冲的channel确保每个goroutine都能写入数据后退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决方案就是使用select结合default语句来解决goroutine阻塞的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用一个取消channel来通知goroutine退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何在演讲中会包含这些bug？Rob Pike仅仅是不想把演示复杂化。这么作是合理的，但对于Go新手而言，可能会直接使用代码，而不去思考它可能有问题。</p><h2 id="0大小的变量初始地址相同"><a href="#0大小的变量初始地址相同" class="headerlink" title="0大小的变量初始地址相同"></a>0大小的变量初始地址相同</h2><p>不同的变量不应该有不同的内存地址么？go中有个小陷阱，0大小(zero-size)的变量可能指向了同一个内存地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := &amp;data&#123;&#125;</span><br><span class="line">  b := &amp;data&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> a == b &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"same address - a=%p b=%p\n"</span>,a,b)</span><br><span class="line">    <span class="comment">//prints: same address - a=0x1953e4 b=0x1953e4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iota不一定总是从0开始"><a href="#iota不一定总是从0开始" class="headerlink" title="iota不一定总是从0开始"></a>iota不一定总是从0开始</h2><p>看起来iota像是个自增操作，当第一次使用iota创建常量时候会得到0，第二次会得到1…但并不是总会如此：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  azero = <span class="literal">iota</span></span><br><span class="line">  aone  = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  info  = <span class="string">"processing"</span></span><br><span class="line">  bzero = <span class="literal">iota</span></span><br><span class="line">  bone  = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(azero,aone) <span class="comment">//prints: 0 1</span></span><br><span class="line">  fmt.Println(bzero,bone) <span class="comment">//prints: 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iota</code>实际上是定义常量语句块内部的行数，所以如果不在第一行使用的话，他的值就不会是0。</p><h2 id="使用指针作为方法的receiver"><a href="#使用指针作为方法的receiver" class="headerlink" title="使用指针作为方法的receiver"></a>使用指针作为方法的receiver</h2><p>只要值是可取址的，那在这个值上调用指针接收方法是没问题的。换句话说，在某些情况下，你不需要在有一个接收值的方法版本。</p><p>然而并不是所有的变量是可取址的。Map的元素就不是。通过interface引用的变量也不是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"name:"</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    d1 := data&#123;<span class="string">"one"</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>() <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">"two"</span>&#125; <span class="comment">//error</span></span><br><span class="line">    in.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data &#123;<span class="string">"x"</span>:data&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"x"</span>].<span class="built_in">print</span>() <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新Map的值"><a href="#更新Map的值" class="headerlink" title="更新Map的值"></a>更新Map的值</h2><p>如果你有一个struct值的map，你无法更新单个的struct值，因为 <strong>Map类型是无法寻址的</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"two"</span> <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下：<code>/tmp/sandbox380452744/main.go:9: cannot assign to m[&quot;x&quot;].name</code>。</p><p>更让人困惑得是，slice是可以寻址的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := []data &#123;&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">"two"</span> <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(s)    <span class="comment">//prints: [&#123;two&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不久前gccgo编译器可更新map struct元素的字段值，不过很快便修复了，官方认为是Go1.3的潜在特性，无需及时实现，依旧在todo list中。</p><p>更新map中struct元素的字段值，第一个方法是使用临时变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    r := m[<span class="string">"x"</span>]</span><br><span class="line">    r.name = <span class="string">"two"</span></span><br><span class="line">    m[<span class="string">"x"</span>] = r</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>,m) <span class="comment">//prints: map[x:&#123;two&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个是使用指向map的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"two"</span> <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(m[<span class="string">"x"</span>]) <span class="comment">//prints: &amp;&#123;two&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便，你猜下面的代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"z"</span>].name = <span class="string">"what?"</span> <span class="comment">//???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Roy注：会报错<code>panic: runtime error: invalid memory address or nil pointer dereference</code>)</p><h2 id="“nil”-Interfaces和”nil”-Interfaces的值"><a href="#“nil”-Interfaces和”nil”-Interfaces的值" class="headerlink" title="“nil” Interfaces和”nil” Interfaces的值"></a>“nil” Interfaces和”nil” Interfaces的值</h2><p>这在Go中是第二最常见的陷阱，因为interface虽然看起来像指针，但并不是指针。interface变量仅在类型和值为“nil”时才为“nil”。</p><p>interface的类型和值会根据用于创建对应interface变量的类型和值的变化而变化。当你检查一个interface变量是否等于“nil”时，这就会导致未预期的行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> data *<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data,data == <span class="literal">nil</span>) <span class="comment">//prints: &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in,in == <span class="literal">nil</span>)     <span class="comment">//prints: &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in,in == <span class="literal">nil</span>)     <span class="comment">//prints: &lt;nil&gt; false</span></span><br><span class="line">    <span class="comment">//'data' is 'nil', but 'in' is not 'nil'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要小心这个陷阱当你的函数返回interface时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 错误代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    doit := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doit(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"good result:"</span>,res) <span class="comment">//prints: good result: &lt;nil&gt;</span></span><br><span class="line">        <span class="comment">//'res' is not 'nil', but its value is 'nil'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    doit := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//return an explicit 'nil'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doit(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"good result:"</span>,res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"bad result (res is nil)"</span>) <span class="comment">//here as expected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈和堆变量"><a href="#栈和堆变量" class="headerlink" title="栈和堆变量"></a>栈和堆变量</h2><p>你并不总是知道变量是分配到栈还是堆上。在C++中，使用new创建的变量总是在堆上。在Go中，即使是使用<code>new()</code>或者<code>make()</code>函数来分配，变量的位置还是由编译器决定。编译器根据变量的大小和“泄露分析”的结果来决定其位置。这也意味着在局部变量上返回引用是没问题的，而这在C或者C++这样的语言中是不行的。</p><p>如果你想知道变量分配的位置，在“go build”或“go run”上传入“-m” gc标志（即，<code>go run -gcflags -m app.go</code>）。</p><h2 id="GOMAXPROCS、并发和并行"><a href="#GOMAXPROCS、并发和并行" class="headerlink" title="GOMAXPROCS、并发和并行"></a>GOMAXPROCS、并发和并行</h2><p>Go1.4及以下版本，程序只会使用1个执行上下文/OS线程，即任何时间都最多只有1个goroutine在执行。</p><p>Go1.5版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑CPU核心数，这个数与系统实际总的CPU逻辑核心数是否一致，取决于你的CPU分配给程序的核心数，可以使用GOMAXPROCS环境变量或者动态的使用<code>runtime.GOMAXPROCS()</code>来调整。</p><p>一个常见的误解是，GOMAXPROCS表示用来运行goroutineCPU的数量，<code>runtime.GOMAXPROCS()</code>函数文档更让人困惑。</p><p>GOMAXPROCS变量<a href="https://golang.org/pkg/runtime/" target="_blank" rel="noopener">描述</a>更好的解释了关于OS线程问题。</p><p>你可以设置GOMAXPROCS的值大于CPU数量，在1.10版本已经不再对这个进行限制。最大值从256提升到了1024。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: X (1 on play.golang.org)</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())       <span class="comment">//prints: X (1 on play.golang.org)</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: 256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写操作的顺序重排"><a href="#读写操作的顺序重排" class="headerlink" title="读写操作的顺序重排"></a>读写操作的顺序重排</h2><p>go也许会对某些操作进行重新排序，但它能保证在一个goroutine内的所有行为顺序是不变的。然而，它并不保证多goroutine的执行顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> u1()</span><br><span class="line">    <span class="keyword">go</span> u2()</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你多运行几次上面的代码，你可能会发现a和b变量有多个不同的组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3 </span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">0 </span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">0 </span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">1 </span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>最有趣的组合式是”02”。这表明b在a之前更新了。</p><p>如果你需要在多goroutine内放置读写顺序的变化，你将需要使用channel，或者使用”sync”包构建合适的结构体。</p><h2 id="优先调度"><a href="#优先调度" class="headerlink" title="优先调度"></a>优先调度</h2><p>有可能会出现这种情况，一个无耻的goroutine阻止其他goroutine运行。当你有一个不让调度器运行的for循环时，这就会发生。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环并不需要是空的。只要它包含了不会触发调度执行的代码，就会发生这种问题。</p><p>调度器会在GC、“go”声明、阻塞channel操作、阻塞系统调用和lock操作后运行。它也会在非内联函数调用后执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        fmt.Println(<span class="string">"not done!"</span>) <span class="comment">//not inlined</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想知道你在for循环中调用的函数是否是内联的，你可以在“go build”或“go run”时传入“-m” gc标志（如，<code>go build -gcflags -m</code>）。</p><p>也可以使用 runtime 包中的 Gosched() 来 手动启动调度器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的代码存在竞态条件(race condition)，这里仅仅为了演示这个坑。</p><h2 id="引入C模块和多行导入"><a href="#引入C模块和多行导入" class="headerlink" title="引入C模块和多行导入"></a>引入C模块和多行导入</h2><p>你需要引入C包来使用Cgo，你可以使用单行import或者使用import块:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"C"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cs := C.CString(<span class="string">"my go string"</span>)</span><br><span class="line">  C.free(unsafe.Pointer(cs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入C包不能和其他包一起：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"C"</span></span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cs := C.CString(<span class="string">"my go string"</span>)</span><br><span class="line">  C.free(unsafe.Pointer(cs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下<code>./main.go:13:2: could not determine kind of name for C.free</code>。</p><h2 id="import-C包和Cgo注释之间不要有空行"><a href="#import-C包和Cgo注释之间不要有空行" class="headerlink" title="import C包和Cgo注释之间不要有空行"></a>import C包和Cgo注释之间不要有空行</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cs := C.CString(<span class="string">"my go string"</span>)</span><br><span class="line">  C.free(unsafe.Pointer(cs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错<code>./main.go:15:2: could not determine kind of name for C.free</code>,确保不会有任何空行。</p><h2 id="使用可变参数不能调用C函数"><a href="#使用可变参数不能调用C函数" class="headerlink" title="使用可变参数不能调用C函数"></a>使用可变参数不能调用C函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cstr := C.CString(<span class="string">"go"</span>)</span><br><span class="line">  C.printf(<span class="string">"%s\n"</span>,cstr) <span class="comment">//not ok</span></span><br><span class="line">  C.free(unsafe.Pointer(cstr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下<code>./main.go:15:2: unexpected type: ...</code></p><p>您必须将可变参数C函数包装在具有已知参数数量的函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void out(char* in) &#123;</span></span><br><span class="line"><span class="comment">  printf("%s\n", in);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cstr := C.CString(<span class="string">"go"</span>)</span><br><span class="line">  C.out(cstr) <span class="comment">//ok</span></span><br><span class="line">  C.free(unsafe.Pointer(cstr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，向原作者表示感谢。这里省略了一些无关的介绍说明以及过于简单的说明，直接看代码就懂了。&lt;/p&gt;&lt;h2 id=&quot;左花括号不能单独一行&quot;&gt;&lt;a href=&quot;#左花括号不能单独一行&quot; class=&quot;headerlink&quot; title=&quot;左花括号不能单独一行&quot;&gt;&lt;/a&gt;左花括号不能单独一行&lt;/h2&gt;&lt;p&gt;在大多数语言中你可以随便放置花括号的位置，但go语言不一样，你可以理解为为go会自动注入分号（automatic semicolon injection）：&lt;/p&gt;&lt;p&gt;错误代码：&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;//error, can&#39;t have the opening brace on a separate line&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;hello there!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;编译错误：&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/tmp/sandbox826898458/main.&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;: syntax error: unexpected semicolon or newline before &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;正确代码：&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;works!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang小技巧</title>
    <link href="http://www.hi-roy.com/2020/12/16/golang%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.hi-roy.com/2020/12/16/golang小技巧/</id>
    <published>2020-12-16T13:32:59.000Z</published>
    <updated>2020-12-17T06:23:26.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下划线的妙用"><a href="#下划线的妙用" class="headerlink" title="下划线的妙用"></a>下划线的妙用</h2><p>大多数情况下，下划线<code>_</code>都用于忽略函数返回值的情况。最近查看<code>authboss</code>这个开源库的代码时，发现<a href="https://github.com/volatiletech/authboss-sample/blob/c13bdabe709387b66806bf12dbe12ad71bb17d17/storer.go#L63" target="_blank" rel="noopener">这样</a>一种用法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> User &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    assertUser   = &amp;User&#123;&#125;</span><br><span class="line">    assertStorer = &amp;MemStorer&#123;&#125;</span><br><span class="line">    _ authboss.User            = assertUser</span><br><span class="line">    _ authboss.AuthableUser    = assertUser</span><br><span class="line">)</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中<code>authboss.User</code>是一个接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetPID() (pid <span class="keyword">string</span>)</span><br><span class="line">    PutPID(pid <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里下划线的作用就是在<strong>编译时进行检查</strong>，确保<code>User</code>完全实现了<code>authboss.User</code>接口。</p><p>此外还可以在声明结构体时使用这个技巧:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    _ <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a := User&#123;"bob",20&#125;  // 这种会报错too few values in SomeSturct literal</span></span><br><span class="line">b := User&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>,<span class="string">"age"</span>:<span class="number">20</span>&#125; <span class="comment">// 通过检查</span></span><br></pre></td></tr></table></figure><p>比如当开发阶段，接口定义、结构体定义还会经常变动时可以使用这个技巧，在编译阶段就发现问题。</p><p>另外，如果在代码里import了一个包而没使用时，编译会报错。但在某些情况下，比如仅仅需要引用某些包调用其<code>init</code>方法时，可以在包名前添加下划线，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    _ <span class="string">"github.com/xxx/xxxx"</span> <span class="comment">// 这里仅需要执行其init函数而非需要使用其中的方法、结构等。</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="关于errors"><a href="#关于errors" class="headerlink" title="关于errors"></a>关于errors</h2><p>使用<code>github.com/pkg/errors</code>替换原生的<code>errors</code>包，这个包有3个关键函数：</p><ol><li><code>Warp</code>用于对底层错误进行包装，添加上下文以及调用栈信息。通常建议用这个包装其他人的三方库或者标准库错误。</li><li><code>WithMessage</code>这个函数只用于对<strong>包装过</strong>的错误添加信息，注意不要重复<code>Warp</code>。</li><li><code>WithStack</code>这个函数只用于添加调用栈而不用附加额外信息的情况。</li><li><code>Cause</code>用于获取底层错误。</li></ol><p>借用个别人的<a href="https://itnext.io/golang-error-handling-best-practice-a36f47b0b94c" target="_blank" rel="noopener">例子</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.Wrap(sql.ErrNoRows, <span class="string">"foo failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.WithMessage(foo(), <span class="string">"bar failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := bar()</span><br><span class="line">   <span class="keyword">if</span> errors.Cause(err) == sql.ErrNoRows &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"data not found, %v\n"</span>, err)</span><br><span class="line">      fmt.Printf(<span class="string">"%+v\n"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// unknown error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">data not found, bar failed: foo failed: sql: no rows in result set</span></span><br><span class="line"><span class="comment">sql: no rows in result set</span></span><br><span class="line"><span class="comment">foo failed</span></span><br><span class="line"><span class="comment">main.foo</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:11</span></span><br><span class="line"><span class="comment">main.bar</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:15</span></span><br><span class="line"><span class="comment">main.main</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:19</span></span><br><span class="line"><span class="comment">runtime.main</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="优雅结束任务"><a href="#优雅结束任务" class="headerlink" title="优雅结束任务"></a>优雅结束任务</h2><p>对外提供API服务时很重要的一点就是处理完当前链接后再退出程序，这里就可以使用信号机制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gracefulStop = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(gracefulStop, syscall.SIGTERM) <span class="comment">// kill</span></span><br><span class="line">signal.Notify(gracefulStop, syscall.SIGINT) <span class="comment">// ctrl+c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是命令行</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       sig := &lt;-gracefulStop</span><br><span class="line">       <span class="comment">// 一些清理工作</span></span><br><span class="line">       os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是http server</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       sig := &lt;-gracefulStop</span><br><span class="line">       server.Shutdown(ctx)</span><br><span class="line">       <span class="comment">// 一些清理工作</span></span><br><span class="line">       os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>那么问题就是，怎么知道清理完成可以退出了呢？最简单的直接<code>sleep</code>几秒钟，但这个时间设定多久合适呢？</p><p>这里其实可以结合<code>channel</code>来实现，比如这里的<a href="https://github.com/gorilla/websocket/blob/c3dd95aea9779669bb3daafbd84ee0530c8ce1c1/examples/echo/client.go#L68" target="_blank" rel="noopener">例子</a>，这里就不贴代码了。</p><h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><p>关于接口，如果只需要有一种实现的话就别用接口了。另外定义接口时尽量分割成小的部分，保持<code>最小知识原则LOD</code>，或者叫迪米特法则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下划线的妙用&quot;&gt;&lt;a href=&quot;#下划线的妙用&quot; class=&quot;headerlink&quot; title=&quot;下划线的妙用&quot;&gt;&lt;/a&gt;下划线的妙用&lt;/h2&gt;&lt;p&gt;大多数情况下，下划线&lt;code&gt;_&lt;/code&gt;都用于忽略函数返回值的情况。最近查看&lt;code&gt;authboss&lt;/code&gt;这个开源库的代码时，发现&lt;a href=&quot;https://github.com/volatiletech/authboss-sample/blob/c13bdabe709387b66806bf12dbe12ad71bb17d17/storer.go#L63&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这样&lt;/a&gt;一种用法:&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; User &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assertUser   = &amp;amp;User&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assertStorer = &amp;amp;MemStorer&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ authboss.User            = assertUser&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ authboss.AuthableUser    = assertUser&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>集成gin和casbin</title>
    <link href="http://www.hi-roy.com/2020/09/28/%E9%9B%86%E6%88%90gin%E5%92%8Ccasbin/"/>
    <id>http://www.hi-roy.com/2020/09/28/集成gin和casbin/</id>
    <published>2020-09-28T13:32:59.000Z</published>
    <updated>2020-12-16T08:32:57.893Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dev.to/maxwellhertz/tutorial-integrate-gin-with-cabsin-56m0" target="_blank" rel="noopener">原文</a>，省略了一些无关的内容。</p><p>如果你搜到这篇文章，那么什么是gin以及casbin应该不用过多解释了。</p><a id="more"></a><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root/</span><br><span class="line">    main.go              <span class="comment"># entry point of application</span></span><br><span class="line">    handler/             <span class="comment"># Gin handler functions</span></span><br><span class="line">    middleware/          <span class="comment"># Gin middlewares</span></span><br><span class="line">    config/              <span class="comment"># some configuration files like Casbin's rbac_model.conf</span></span><br><span class="line">    component/           <span class="comment"># global components like GORM DB instance</span></span><br></pre></td></tr></table></figure><h2 id="初始化数据库和缓存"><a href="#初始化数据库和缓存" class="headerlink" title="初始化数据库和缓存"></a>初始化数据库和缓存</h2><p>在<code>component</code>目录下创建<code>persistence.go</code>用于初始化，这里使用<code>GORM</code>来处理数据库，<code>BigCache</code>处理缓存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/allegro/bigcache"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">    <span class="string">"github.com/jinzhu/gorm"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    DB           *gorm.DB</span><br><span class="line">    GlobalCache  *bigcache.BigCache</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Connect to DB</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    DB, err = gorm.Open(<span class="string">"mysql"</span>, <span class="string">"your_db_url"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"failed to connect to DB: %v"</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize cache</span></span><br><span class="line">    GlobalCache, err = bigcache.NewBigCache(bigcache.DefaultConfig(<span class="number">30</span> * time.Minute)) <span class="comment">// Set expire time to 30 mins</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"failed to initialize cahce: %v"</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用数据库来存储casbin的polices，使用缓存存储登录用户信息。</p><h2 id="配置Casbin"><a href="#配置Casbin" class="headerlink" title="配置Casbin"></a>配置Casbin</h2><h3 id="Model-Configuration-File"><a href="#Model-Configuration-File" class="headerlink" title="Model Configuration File"></a>Model Configuration File</h3><p>首先，你也许会发现casbin中有些概念让你很困惑，比如<code>Model Configuration File</code>。这里我不想讨论太多原理(因为我也不熟)，直接举个例子，使用基于角色的权限控制(RBAC，Role-based access control)。所以首先在<code>config</code>目录创建<code>rbac_model.conf</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[request_definition]</span><br><span class="line">r = sub, obj, act</span><br><span class="line"></span><br><span class="line">[policy_definition]</span><br><span class="line">p = sub, obj, act</span><br><span class="line"></span><br><span class="line">[role_definition]</span><br><span class="line">g = _, _</span><br><span class="line"></span><br><span class="line">[policy_effect]</span><br><span class="line">e = some(where (p.eft == allow))</span><br><span class="line"></span><br><span class="line">[matchers]</span><br><span class="line">m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</span><br></pre></td></tr></table></figure><p>上面的文件定义了casbin如何判断用户拥有什么权限，例子中我们定义了5个字段：</p><ol><li><code>r = sub, obj, act</code> 定义了一个请求需要由3部分组成：sub=用户，obj=URL或资源，act=操作。</li><li><code>p = sub, obj, act</code> 定义了策略的格式，比如<code>admin,dada,write</code>表示admin有data的写权限。</li><li><code>e = some(where (p.eft == allow))</code> 定义了用户可以做那些策略中定义准许他做的事。</li><li><code>g = _, _</code> 定义了角色的格式，例如<code>bob,admin</code>表示用户bob是admin这个角色。</li><li><code>m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</code> 定义了鉴权时的流程，先检查用户角色，再检查用户访问的资源，最后检查用户行为。</li></ol><p>上面几个部分，仅1、2、3、5是必须的，如果不使用RBAC可以忽略4。</p><blockquote><p>Roy注：下面的这个更常用。程序中判断如果角色是admin则直接传’admin’而非用户名，这样直接有所有权限了。<br>[matchers]<br>m = g(r.sub, p.sub) == true \<br>&amp;&amp; keyMatch2(r.obj, p.obj) == true \<br>&amp;&amp; regexMatch(r.act, p.act) == true \<br>|| r.sub == “admin” \<br>|| keyMatch2(r.obj, “/login”) == true</p></blockquote><h3 id="Polices"><a href="#Polices" class="headerlink" title="Polices"></a>Polices</h3><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, user, data, read</span><br><span class="line">p, admin, data, read</span><br><span class="line">p, admin, data, write</span><br><span class="line">g, Alice, admin</span><br><span class="line">g, Bob, user</span><br></pre></td></tr></table></figure><p>首先我们定义了3个策略：</p><ol><li>user可以读取data</li><li>admin可以写data</li><li>admin可以读data</li></ol><p>以及2个用户角色：</p><ol><li>Alice属于admin</li><li>Bob属于user</li></ol><p>所以Alice有数据的所有权限而Bob只能读取数据。官网教程中casbin使用csv来简单的存储策略，这里我们使用数据库。casbin通常把表名命名为<code>casbin_rule</code>，结构语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> casbin_rule (</span><br><span class="line">    p_type <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    v0 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    v1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    v2 <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> casbin_rule <span class="keyword">VALUES</span>(<span class="string">'p'</span>, <span class="string">'user'</span>, <span class="string">'resource'</span>, <span class="string">'read'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> casbin_rule(p_type, v0, v1) <span class="keyword">VALUES</span>(<span class="string">'g'</span>, <span class="string">'Bob'</span>, <span class="string">'user'</span>);</span><br></pre></td></tr></table></figure><h2 id="实现Gin的Handler"><a href="#实现Gin的Handler" class="headerlink" title="实现Gin的Handler"></a>实现Gin的Handler</h2><p>首先实现登录逻辑<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handler/user_handler.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    username, password := c.PostForm(<span class="string">"username"</span>), c.PostForm(<span class="string">"password"</span>)</span><br><span class="line">        <span class="comment">// Authentication</span></span><br><span class="line">        <span class="comment">// blahblah...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate random session id</span></span><br><span class="line">    u, err := uuid.NewRandom()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    sessionId := fmt.Sprintf(<span class="string">"%s-%s"</span>, u.String(), username)</span><br><span class="line">    <span class="comment">// Store current subject in cache</span></span><br><span class="line">    component.GlobalCache.Set(sessionId, []<span class="keyword">byte</span>(username))</span><br><span class="line">    <span class="comment">// Send cache key back to client in cookie</span></span><br><span class="line">    c.SetCookie(<span class="string">"current_subject"</span>, sessionId, <span class="number">30</span>*<span class="number">60</span>, <span class="string">"/resource"</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">    c.JSON(<span class="number">200</span>, component.RestResponse&#123;Code: <span class="number">1</span>, Message:username + <span class="string">" logged in successfully"</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果登录成功，我们存储用户(或者叫sub)信息到缓存中，这里不要忘记将sessionId写回cookie中。casbin只负责鉴权不负责认证，所以我们要自己实现认证逻辑。接下来实现读、写逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handler/resource_handler.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadResource</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// some stuff</span></span><br><span class="line">        <span class="comment">// blahblah...</span></span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, component.RestResponse&#123;Code: <span class="number">1</span>, Message: <span class="string">"read resource successfully"</span>, Data: <span class="string">"resource"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResource</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// some stuff</span></span><br><span class="line">        <span class="comment">// blahblah...</span></span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, component.RestResponse&#123;Code: <span class="number">1</span>, Message: <span class="string">"write resource successfully"</span>, Data: <span class="string">"resource"</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现<code>main.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    router *gin.Engine</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize gin router</span></span><br><span class="line">    router = gin.Default()</span><br><span class="line">    corsConfig := cors.DefaultConfig()</span><br><span class="line">    corsConfig.AllowAllOrigins = <span class="literal">true</span></span><br><span class="line">    corsConfig.AllowCredentials = <span class="literal">true</span></span><br><span class="line">    router.Use(cors.New(corsConfig)) <span class="comment">// CORS configuraion</span></span><br><span class="line">    router.POST(<span class="string">"/user/login"</span>, handler.Login)</span><br><span class="line">    router.GET(<span class="string">"/resource"</span>, handler.ReadResource)</span><br><span class="line">    router.POST(<span class="string">"/resource"</span>, handler.WriteResource)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> component.DB.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our application</span></span><br><span class="line">    err := router.Run(<span class="string">":8081"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"failed to start gin engin: %v"</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"application is now running..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切就绪，接下来开始集成。</p><h2 id="启用casbin策略"><a href="#启用casbin策略" class="headerlink" title="启用casbin策略"></a>启用casbin策略</h2><h3 id="从数据库加载polices"><a href="#从数据库加载polices" class="headerlink" title="从数据库加载polices"></a>从数据库加载polices</h3><p>第一个问题就是，我们如何从数据库动态加载策略？我们可以使用<code>Casbin Adapters</code>，更精确的说我们使用的是<code>Gorm Adapter</code>。首先进行初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize  casbin adapter</span></span><br><span class="line">    adapter, err := gormadapter.NewAdapterByDB(component.DB)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"failed to initialize casbin adapter: %v"</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize gin router</span></span><br><span class="line">    router = gin.Default()</span><br><span class="line">    corsConfig := cors.DefaultConfig()</span><br><span class="line">    corsConfig.AllowAllOrigins = <span class="literal">true</span></span><br><span class="line">    corsConfig.AllowCredentials = <span class="literal">true</span></span><br><span class="line">    router.Use(cors.New(corsConfig)) <span class="comment">// CORS configuraion</span></span><br><span class="line">        router.POST(<span class="string">"/user/login"</span>, handler.Login)</span><br><span class="line">        router.GET(<span class="string">"/resource"</span>, handler.ReadResource)</span><br><span class="line">        router.POST(<span class="string">"/resource"</span>, handler.WriteResource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然的，在进行任何操作前都需要经过鉴权，所以更优雅的方式是使用gin提供的<code>middlewares</code>和<code>grouping routes</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// middleware/access_control.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Authorize determines if current subject has been authorized to take an action on an object.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Authorize</span><span class="params">(obj <span class="keyword">string</span>, act <span class="keyword">string</span>, adapter *gormadapter.Adapter)</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// Get current user/subject</span></span><br><span class="line">        val, existed := c.Get(<span class="string">"current_subject"</span>)</span><br><span class="line">        <span class="keyword">if</span> !existed &#123;</span><br><span class="line">            c.AbortWithStatusJSON(<span class="number">401</span>, component.RestResponse&#123;Message: <span class="string">"user hasn't logged in yet"</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Casbin enforces policy</span></span><br><span class="line">        ok, err := enforce(val.(<span class="keyword">string</span>), obj, act, adapter)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            c.AbortWithStatusJSON(<span class="number">500</span>, component.RestResponse&#123;Message: <span class="string">"error occurred when authorizing user"</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            c.AbortWithStatusJSON(<span class="number">403</span>, component.RestResponse&#123;Message: <span class="string">"forbidden"</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enforce</span><span class="params">(sub <span class="keyword">string</span>, obj <span class="keyword">string</span>, act <span class="keyword">string</span>, adapter *gormadapter.Adapter)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Load model configuration file and policy store adapter</span></span><br><span class="line">    enforcer, err := casbin.NewEnforcer(<span class="string">"config/rbac_model.conf"</span>, adapter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"failed to create casbin enforcer: %w"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load policies from DB dynamically</span></span><br><span class="line">    err = enforcer.LoadPolicy()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"failed to load policy from DB: %w"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Verify</span></span><br><span class="line">    ok, err := enforcer.Enforce(sub, obj, act)</span><br><span class="line">    <span class="keyword">return</span> ok, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后进行一些修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize  casbin adapter</span></span><br><span class="line">    adapter, err := gormadapter.NewAdapterByDB(component.DB)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"failed to initialize casbin adapter: %v"</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize Gin router</span></span><br><span class="line">    router = gin.Default()</span><br><span class="line">    corsConfig := cors.DefaultConfig()</span><br><span class="line">    corsConfig.AllowAllOrigins = <span class="literal">true</span></span><br><span class="line">    corsConfig.AllowCredentials = <span class="literal">true</span></span><br><span class="line">    router.Use(cors.New(corsConfig)) <span class="comment">// CORS configuraion</span></span><br><span class="line">        router.POST(<span class="string">"/user/login"</span>, handler.Login)</span><br><span class="line">        <span class="comment">// Secure our API</span></span><br><span class="line">    resource := router.Group(<span class="string">"/api"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        resource.GET(<span class="string">"/resource"</span>, middleware.Authorize(<span class="string">"resource"</span>, <span class="string">"read"</span>, adapter), handler.ReadResource)</span><br><span class="line">        resource.POST(<span class="string">"/resource"</span>, middleware.Authorize(<span class="string">"resource"</span>, <span class="string">"write"</span>, adapter), handler.WriteResource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dev.to/maxwellhertz/tutorial-integrate-gin-with-cabsin-56m0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，省略了一些无关的内容。&lt;/p&gt;&lt;p&gt;如果你搜到这篇文章，那么什么是gin以及casbin应该不用过多解释了。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.hi-roy.com/source/all-categories/Golang/"/>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/Golang/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="go" scheme="http://www.hi-roy.com/source/all-tags/go/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码学习笔记6</title>
    <link href="http://www.hi-roy.com/2020/07/20/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/"/>
    <id>http://www.hi-roy.com/2020/07/20/OpenStack源码学习笔记6/</id>
    <published>2020-07-20T09:46:29.000Z</published>
    <updated>2020-07-20T09:16:12.821Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前发现一个现象，在生产环境中配置了保留内存<code>reserved_host_memory_mb</code>以及 <strong>没配置</strong> 内存超分比<code>ram_allocation_ratio</code>的情况下，虚拟机使用的内存居然已经快将物理内存耗尽了。</p><p>比如物理机内存300G，方便举例忽略掉一些系统占用，当设置了<code>reserved_host_memory_mb</code>为20G，那么理论上所有虚拟机最大占用内存量为280G，而查看居然已经使用了290G的内存，还是在虚拟机并没有将各自申请的内存全部使用掉的情况下(比如申请一台4G的虚拟机，但物理机操作系统层面并没有分配4G给对应的进程，除非虚拟机内部把内存占满)。</p><p>单单就nova而言，如果在集群启动时就指定了保留内存大小和超分比为1的话，是不应该出现上述情形的。除非后期对这2个参数进行过修改，但由于年代久远已经没法追溯，这也就成了一桩悬案。</p><p>不过在追踪这个问题的过程中，顺便也学习了下主机热迁移的过程，这里的代码是 <strong><em>N版</em></strong> 。</p><a id="more"></a><p>根据之前文章写过的套路，这里直接定位到<code>api/openstack/compute/migrate_server.py</code>的<code>_migrate_live</code>函数，这个函数很简单就不贴代码了，就是解析请求中的虚拟机ID、目标主机等参数，然后调用<code>compute/api.py</code>中<code>API</code>类的<code>live_migrate</code>函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@check_instance_lock</span></span><br><span class="line"><span class="meta">@check_instance_cell</span></span><br><span class="line"><span class="meta">@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.PAUSED])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">live_migrate</span><span class="params">(self, context, instance, block_migration,</span></span></span><br><span class="line"><span class="function"><span class="params">                    disk_over_commit, host_name, force=None, async=False)</span>:</span></span><br><span class="line">    <span class="string">"""Migrate a server lively to a new host."""</span></span><br><span class="line"></span><br><span class="line">    instance.task_state = task_states.MIGRATING</span><br><span class="line">    instance.save(expected_task_state=[<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">    self._record_action_start(context, instance,</span><br><span class="line">                                instance_actions.LIVE_MIGRATION)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request_spec = objects.RequestSpec.get_by_instance_uuid(</span><br><span class="line">            context, instance.uuid)</span><br><span class="line">    <span class="keyword">except</span> exception.RequestSpecNotFound:</span><br><span class="line">        request_spec = <span class="literal">None</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.compute_task_api.live_migrate_instance(context, instance,</span><br><span class="line">            host_name, block_migration=block_migration,</span><br><span class="line">            disk_over_commit=disk_over_commit,</span><br><span class="line">            request_spec=request_spec, <span class="keyword">async</span>=<span class="keyword">async</span>)</span><br><span class="line">    <span class="keyword">except</span> oslo_exceptions.MessagingTimeout <span class="keyword">as</span> messaging_timeout:</span><br><span class="line">        <span class="keyword">with</span> excutils.save_and_reraise_exception():</span><br><span class="line">            compute_utils.add_instance_fault_from_exc(context,</span><br><span class="line">                                                        instance,</span><br><span class="line">                                                        messaging_timeout)</span><br></pre></td></tr></table></figure><p>这个函数修改了主机状态为migrating，获取虚拟机参数(这里有个细节，request_spec这个东西记录在nova-api库里而非nova库)，创建操作记录，由于我们调用的api版本还不支持force参数这部分代码就不贴了，具体可参考<a href="https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail,migrate-server-migrate-action-detail,live-migrate-server-os-migratelive-action-detail#create-server" target="_blank" rel="noopener">这里</a></p><p>然后调用<code>live_migrate_instance</code>函数位于<code>conductor/api.py</code>中:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">live_migrate_instance</span><span class="params">(self, context, instance, host_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                          block_migration, disk_over_commit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          request_spec=None, async=False)</span>:</span></span><br><span class="line">    scheduler_hint = &#123;<span class="string">'host'</span>: host_name&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">async</span>:</span><br><span class="line">        self.conductor_compute_rpcapi.live_migrate_instance(</span><br><span class="line">            context, instance, scheduler_hint, block_migration,</span><br><span class="line">            disk_over_commit, request_spec)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.conductor_compute_rpcapi.migrate_server(</span><br><span class="line">            context, instance, scheduler_hint, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">None</span>,</span><br><span class="line">            block_migration, disk_over_commit, <span class="literal">None</span>,</span><br><span class="line">            request_spec=request_spec)</span><br></pre></td></tr></table></figure><p>注意这里可能由于代码版本原因，这里就是直接固定为传入的主机名称的。然后进入rpc调用，位于<code>conductor/rpcapi.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">migrate_server</span><span class="params">(self, context, instance, scheduler_hint, live, rebuild,</span></span></span><br><span class="line"><span class="function"><span class="params">                  flavor, block_migration, disk_over_commit,</span></span></span><br><span class="line"><span class="function"><span class="params">                  reservations=None, clean_shutdown=True, request_spec=None)</span>:</span></span><br><span class="line">    kw = &#123;<span class="string">'instance'</span>: instance, <span class="string">'scheduler_hint'</span>: scheduler_hint,</span><br><span class="line">            <span class="string">'live'</span>: live, <span class="string">'rebuild'</span>: rebuild, <span class="string">'flavor'</span>: flavor,</span><br><span class="line">            <span class="string">'block_migration'</span>: block_migration,</span><br><span class="line">            <span class="string">'disk_over_commit'</span>: disk_over_commit,</span><br><span class="line">            <span class="string">'reservations'</span>: reservations,</span><br><span class="line">            <span class="string">'clean_shutdown'</span>: clean_shutdown,</span><br><span class="line">            <span class="string">'request_spec'</span>: request_spec,</span><br><span class="line">            &#125;</span><br><span class="line">    ......</span><br><span class="line">    cctxt = self.client.prepare(version=version)</span><br><span class="line">    <span class="keyword">return</span> cctxt.call(context, <span class="string">'migrate_server'</span>, **kw)</span><br></pre></td></tr></table></figure><p>这个函数进行了一堆版本兼容性判断，然后进入<code>conductor/manager.py</code>的<code>migrate_server</code>函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">migrate_server</span><span class="params">(self, context, instance, scheduler_hint, live, rebuild,</span></span></span><br><span class="line"><span class="function"><span class="params">            flavor, block_migration, disk_over_commit, reservations=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            clean_shutdown=True, request_spec=None)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> live <span class="keyword">and</span> <span class="keyword">not</span> rebuild <span class="keyword">and</span> <span class="keyword">not</span> flavor:</span><br><span class="line">        self._live_migrate(context, instance, scheduler_hint,</span><br><span class="line">                            block_migration, disk_over_commit, request_spec)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>由于这里我们仅关注热迁移就直接跟进<code>_live_migrate</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_live_migrate</span><span class="params">(self, context, instance, scheduler_hint,</span></span></span><br><span class="line"><span class="function"><span class="params">                      block_migration, disk_over_commit, request_spec)</span>:</span></span><br><span class="line">    destination = scheduler_hint.get(<span class="string">"host"</span>)</span><br><span class="line">    migration = objects.Migration(context=context.elevated())</span><br><span class="line">    ......</span><br><span class="line">    migration.create()</span><br><span class="line">    task = self._build_live_migrate_task(context, instance, destination,</span><br><span class="line">                                        block_migration, disk_over_commit,</span><br><span class="line">                                        migration, request_spec)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        task.execute()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_live_migrate_task</span><span class="params">(self, context, instance, destination,</span></span></span><br><span class="line"><span class="function"><span class="params">                            block_migration, disk_over_commit, migration,</span></span></span><br><span class="line"><span class="function"><span class="params">                            request_spec=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> live_migrate.LiveMigrationTask(context, instance,</span><br><span class="line">                                            destination, block_migration,</span><br><span class="line">                                            disk_over_commit, migration,</span><br><span class="line">                                            self.compute_rpcapi,</span><br><span class="line">                                            self.servicegroup_api,</span><br><span class="line">                                            self.scheduler_client,</span><br><span class="line">                                            request_spec)</span><br></pre></td></tr></table></figure><p>这个函数就是创建了一条数据库迁移记录，然后继续跟进到<code>conductor/tasks/live_migrate.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveMigrationTask</span><span class="params">(base.TaskBase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, context, instance, destination,</span></span></span><br><span class="line"><span class="function"><span class="params">                 block_migration, disk_over_commit, migration, compute_rpcapi,</span></span></span><br><span class="line"><span class="function"><span class="params">                 servicegroup_api, scheduler_client, request_spec=None)</span>:</span></span><br><span class="line">        super(LiveMigrationTask, self).__init__(context, instance)</span><br><span class="line">        self.destination = destination</span><br><span class="line">        self.block_migration = block_migration</span><br><span class="line">        self.disk_over_commit = disk_over_commit</span><br><span class="line">        self.migration = migration</span><br><span class="line">        self.source = instance.host</span><br><span class="line">        self.migrate_data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self.compute_rpcapi = compute_rpcapi</span><br><span class="line">        self.servicegroup_api = servicegroup_api</span><br><span class="line">        self.scheduler_client = scheduler_client</span><br><span class="line">        self.request_spec = request_spec</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._check_instance_is_active()</span><br><span class="line">        self._check_host_is_up(self.source)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.destination:</span><br><span class="line">            self.destination = self._find_destination()</span><br><span class="line">            self.migration.dest_compute = self.destination</span><br><span class="line">            self.migration.save()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._check_requested_destination()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.compute_rpcapi.live_migration(self.context,</span><br><span class="line">                host=self.source,</span><br><span class="line">                instance=self.instance,</span><br><span class="line">                dest=self.destination,</span><br><span class="line">                block_migration=self.block_migration,</span><br><span class="line">                migration=self.migration,</span><br><span class="line">                migrate_data=self.migrate_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_requested_destination</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._check_destination_is_not_source()</span><br><span class="line">        self._check_host_is_up(self.destination)</span><br><span class="line">        self._check_destination_has_enough_memory()</span><br><span class="line">        self._check_compatible_with_source_hypervisor(self.destination)</span><br><span class="line">        self._call_livem_checks_on_host(self.destination)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_destination_has_enough_memory</span><span class="params">(self)</span>:</span></span><br><span class="line">        compute = self._get_compute_info(self.destination)</span><br><span class="line">        free_ram_mb = compute.free_ram_mb</span><br><span class="line">        total_ram_mb = compute.memory_mb</span><br><span class="line">        mem_inst = self.instance.memory_mb</span><br><span class="line">        <span class="comment"># NOTE(sbauza): Now the ComputeNode object reports an allocation ratio</span></span><br><span class="line">        <span class="comment"># that can be provided by the compute_node if new or by the controller</span></span><br><span class="line">        ram_ratio = compute.ram_allocation_ratio</span><br><span class="line"></span><br><span class="line">        <span class="comment"># NOTE(sbauza): Mimic the RAMFilter logic in order to have the same</span></span><br><span class="line">        <span class="comment"># ram validation</span></span><br><span class="line">        avail = total_ram_mb * ram_ratio - (total_ram_mb - free_ram_mb)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mem_inst <span class="keyword">or</span> avail &lt;= mem_inst:</span><br><span class="line">            instance_uuid = self.instance.uuid</span><br><span class="line">            dest = self.destination</span><br><span class="line">            reason = _(<span class="string">"Unable to migrate %(instance_uuid)s to %(dest)s: "</span></span><br><span class="line">                       <span class="string">"Lack of memory(host:%(avail)s &lt;= "</span></span><br><span class="line">                       <span class="string">"instance:%(mem_inst)s)"</span>)</span><br><span class="line">            <span class="keyword">raise</span> exception.MigrationPreCheckError(reason=reason % dict(</span><br><span class="line">                    instance_uuid=instance_uuid, dest=dest, avail=avail,</span><br><span class="line">                    mem_inst=mem_inst))</span><br></pre></td></tr></table></figure><p>重点是<code>_execute</code>这个函数，首先进行状态检查，然后判断是否传入了目标计算节点，如果传入了在依次检查源节点和目标节点是否是同一台机器、目标节点是否运行、目标节点内存是否充足、虚拟化类型是否一致、是否准许热迁移；如果没传入则调用<code>scheduler</code>的<code>select_destinations</code>函数来筛选目标节点。</p><p>然后再调用<code>compute/rpcapi.py</code>中<code>ComputeAPI</code>类的<code>live_migrate</code>函数，这个函数又调用了<code>compute/manager.py</code>中<code>ComputeManager</code>类的<code>live_migrate</code>函数，这里设置状态为<code>queued</code>，然后开新线程处理请求：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">live_migration</span><span class="params">(self, context, dest, instance, block_migration,</span></span></span><br><span class="line"><span class="function"><span class="params">                       migration, migrate_data)</span>:</span></span><br><span class="line">    <span class="string">"""Executing live migration.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._set_migration_status(migration, <span class="string">'queued'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch_live_migration</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._live_migration_semaphore:</span><br><span class="line">            self._do_live_migration(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NOTE(danms): We spawn here to return the RPC worker thread back to</span></span><br><span class="line">    <span class="comment"># the pool. Since what follows could take a really long time, we don't</span></span><br><span class="line">    <span class="comment"># want to tie up RPC workers.</span></span><br><span class="line">    utils.spawn_n(dispatch_live_migration,</span><br><span class="line">                    context, dest, instance,</span><br><span class="line">                    block_migration, migration,</span><br><span class="line">                    migrate_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_do_live_migration</span><span class="params">(self, context, dest, instance, block_migration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        migration, migrate_data)</span>:</span></span><br><span class="line">    <span class="comment"># NOTE(danms): We should enhance the RT to account for migrations</span></span><br><span class="line">    <span class="comment"># and use the status field to denote when the accounting has been</span></span><br><span class="line">    <span class="comment"># done on source/destination. For now, this is just here for status</span></span><br><span class="line">    <span class="comment"># reporting</span></span><br><span class="line">    self._set_migration_status(migration, <span class="string">'preparing'</span>)</span><br><span class="line"></span><br><span class="line">    got_migrate_data_object = isinstance(migrate_data,</span><br><span class="line">                                         migrate_data_obj.LiveMigrateData)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> got_migrate_data_object:</span><br><span class="line">        migrate_data = \</span><br><span class="line">            migrate_data_obj.LiveMigrateData.detect_implementation(</span><br><span class="line">                migrate_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ......</span><br><span class="line">        migrate_data = self.compute_rpcapi.pre_live_migration(context, instance,</span><br><span class="line">                                                              block_migration, disk, dest, migrate_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">with</span> excutils.save_and_reraise_exception():</span><br><span class="line">            LOG.exception(_LE(<span class="string">'Pre live migration failed at %s'</span>),</span><br><span class="line">                            dest, instance=instance)</span><br><span class="line">            self._set_migration_status(migration, <span class="string">'error'</span>)</span><br><span class="line">            self._rollback_live_migration(context, instance, dest,</span><br><span class="line">                                            block_migration, migrate_data)</span><br><span class="line"></span><br><span class="line">    self._set_migration_status(migration, <span class="string">'running'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> migrate_data:</span><br><span class="line">        migrate_data.migration = migration</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.driver.live_migration(context, instance, dest,</span><br><span class="line">                                    self._post_live_migration,</span><br><span class="line">                                    self._rollback_live_migration,</span><br><span class="line">                                    block_migration, migrate_data)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>最终的<code>pre_live_migration</code>函数位于<code>compute/manager.py</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_live_migration</span><span class="params">(self, context, instance, block_migration, disk,</span></span></span><br><span class="line"><span class="function"><span class="params">                           migrate_data)</span>:</span></span><br><span class="line">    <span class="string">"""Preparations for live migration at dest host.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    LOG.debug(<span class="string">'pre_live_migration data is %s'</span>, migrate_data)</span><br><span class="line">    <span class="comment"># TODO(tdurakov): remove dict to object conversion once RPC API version</span></span><br><span class="line">    <span class="comment"># is bumped to 5.x</span></span><br><span class="line">    got_migrate_data_object = isinstance(migrate_data,</span><br><span class="line">                                            migrate_data_obj.LiveMigrateData)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> got_migrate_data_object:</span><br><span class="line">        migrate_data = \</span><br><span class="line">            migrate_data_obj.LiveMigrateData.detect_implementation(</span><br><span class="line">                migrate_data)</span><br><span class="line"></span><br><span class="line">    block_device_info = self._get_instance_block_device_info(</span><br><span class="line">                        context, instance, refresh_conn_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    network_info = self.network_api.get_instance_nw_info(context, instance)</span><br><span class="line">    self._notify_about_instance_usage(</span><br><span class="line">                    context, instance, <span class="string">"live_migration.pre.start"</span>,</span><br><span class="line">                    network_info=network_info)</span><br><span class="line"></span><br><span class="line">    migrate_data = self.driver.pre_live_migration(context,</span><br><span class="line">                                    instance,</span><br><span class="line">                                    block_device_info,</span><br><span class="line">                                    network_info,</span><br><span class="line">                                    disk,</span><br><span class="line">                                    migrate_data)</span><br><span class="line">    LOG.debug(<span class="string">'driver pre_live_migration data is %s'</span> % migrate_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NOTE(tr3buchet): setup networks on destination host</span></span><br><span class="line">    self.network_api.setup_networks_on_host(context, instance, self.host)</span><br><span class="line"></span><br><span class="line">    self.driver.ensure_filtering_rules_for_instance(instance, network_info)</span><br><span class="line"></span><br><span class="line">    self._notify_about_instance_usage(</span><br><span class="line">                    context, instance, <span class="string">"live_migration.pre.end"</span>,</span><br><span class="line">                    network_info=network_info)</span><br><span class="line">    <span class="comment"># TODO(tdurakov): remove dict to object conversion once RPC API version</span></span><br><span class="line">    <span class="comment"># is bumped to 5.x</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> got_migrate_data_object <span class="keyword">and</span> migrate_data:</span><br><span class="line">        migrate_data = migrate_data.to_legacy_dict(</span><br><span class="line">            pre_migration_result=<span class="literal">True</span>)</span><br><span class="line">        migrate_data = migrate_data[<span class="string">'pre_live_migration_result'</span>]</span><br><span class="line">    LOG.debug(<span class="string">'pre_live_migration result data is %s'</span>, migrate_data)</span><br><span class="line">    <span class="keyword">return</span> migrate_data</span><br></pre></td></tr></table></figure><p>具体的位于<code>virt/libvirt/driver.py</code>的同名函数我这里就不贴了，就是进行磁盘、网络相关操作。最后依次调用<code>virt/libvirt/driver.py</code>的<code>_live_migration</code>、<code>_live_migration_operation</code>，进入<code>virt/libvirt/guest.py</code>中<code>Guest</code>类的<code>migrate</code>函数，最终交给了libvirt处理。</p><p>至此，nova的使命大部分完成，剩下的就是等待迁移状态回写数据库了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前发现一个现象，在生产环境中配置了保留内存&lt;code&gt;reserved_host_memory_mb&lt;/code&gt;以及 &lt;strong&gt;没配置&lt;/strong&gt; 内存超分比&lt;code&gt;ram_allocation_ratio&lt;/code&gt;的情况下，虚拟机使用的内存居然已经快将物理内存耗尽了。&lt;/p&gt;&lt;p&gt;比如物理机内存300G，方便举例忽略掉一些系统占用，当设置了&lt;code&gt;reserved_host_memory_mb&lt;/code&gt;为20G，那么理论上所有虚拟机最大占用内存量为280G，而查看居然已经使用了290G的内存，还是在虚拟机并没有将各自申请的内存全部使用掉的情况下(比如申请一台4G的虚拟机，但物理机操作系统层面并没有分配4G给对应的进程，除非虚拟机内部把内存占满)。&lt;/p&gt;&lt;p&gt;单单就nova而言，如果在集群启动时就指定了保留内存大小和超分比为1的话，是不应该出现上述情形的。除非后期对这2个参数进行过修改，但由于年代久远已经没法追溯，这也就成了一桩悬案。&lt;/p&gt;&lt;p&gt;不过在追踪这个问题的过程中，顺便也学习了下主机热迁移的过程，这里的代码是 &lt;strong&gt;&lt;em&gt;N版&lt;/em&gt;&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Nova" scheme="http://www.hi-roy.com/source/all-tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-享元模式</title>
    <link href="http://www.hi-roy.com/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2020/05/20/设计模式-享元模式/</id>
    <published>2020-05-20T08:58:08.000Z</published>
    <updated>2020-05-20T09:31:49.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="享元模式-Flyweight-Pattern"><a href="#享元模式-Flyweight-Pattern" class="headerlink" title="享元模式(Flyweight Pattern)"></a>享元模式(Flyweight Pattern)</h2><p>用共享的方式提供大量细粒度的对象，降低系统创建类实例的性能消耗，不是特别常用的一种模式。</p><a id="more"></a><p><img src="/assets/images/design-pattern/flyweight.png" alt="flyweight.png"></p><p>不是特别常见就不写示例demo了，最合适的例子就是在线下五子棋的网站，每个棋子只有颜色、位置不同，如果每个棋子都是一个单独的对象那么对于服务器将产生极大的消耗，这种场景就非常适合享元模式。</p><p>享元模式中有3个角色：</p><ol><li>抽象享元类：定义需要实现的接口。</li><li>具体享元类：实现抽象享元角色的接口，并且定义内部状态。</li><li>享元工厂类：负责创建、管理享元角色。如果已经存在一个对应的角色，则返回；否则创建。一般使用哈希表来记录。</li></ol><p>其中，享元模式中又为内部和外部两类属性。内部属性是共享的，而外部属性则是可变的。比如声明一个五子棋子的抽象享元类，里面定义的颜色就是内部属性，位置则是外部属性。而白色棋子、黑色棋子分别是具体享元类，通过享元工厂来创建具体的棋子。当需要使用位置信息时，则可以通过参数的方式动态的注入到具体实例中。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>当系统中某个对象类型的实例较多时。</li><li>对象实例进行分类后，发现真正有区别的分类很少时。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>组合模式：使用享元模式共享组合模式的叶子结点，提高效率。</li><li>单例模式：一般享元工厂都是单例模式。另外，单例模式是享元模式的一种特例。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;享元模式-Flyweight-Pattern&quot;&gt;&lt;a href=&quot;#享元模式-Flyweight-Pattern&quot; class=&quot;headerlink&quot; title=&quot;享元模式(Flyweight Pattern)&quot;&gt;&lt;/a&gt;享元模式(Flyweight Pattern)&lt;/h2&gt;&lt;p&gt;用共享的方式提供大量细粒度的对象，降低系统创建类实例的性能消耗，不是特别常用的一种模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码学习笔记5</title>
    <link href="http://www.hi-roy.com/2020/03/30/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/"/>
    <id>http://www.hi-roy.com/2020/03/30/OpenStack源码学习笔记5/</id>
    <published>2020-03-30T09:46:29.000Z</published>
    <updated>2020-04-02T02:13:13.361Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个诡异的问题，对某个有问题的计算节点进行疏散，结果有些虚拟机的根磁盘居然消！失！了？首先能够确定的是ceph不会自动删除，那么一定是某个地方触发了删除根磁盘的操作。</p><p>这如果发生在生产环境可是一个极其严重的问题，正好借此排查的机会梳理一下nova关于主机疏散的流程。</p><p>以下代码为N版，但大体流程相差应该不大。</p><a id="more"></a><p>根据套路(不知道套路的看以前的系列文章)，定位疏散入口为<code>api/openstack/compute/evacuate.py</code>的<code>_evacuate</code>函数，这里有个比较重要的就是判断是否使用了共享存储，然后调用<code>compute/api.py</code>中的<code>evacuate</code>函数：<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evacuate</span><span class="params">(self, context, instance, host, on_shared_storage,</span></span></span><br><span class="line"><span class="function"><span class="params">                admin_password=None, force=None)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    migration = objects.Migration(context,</span><br><span class="line">                                    source_compute=instance.host,</span><br><span class="line">                                    source_node=instance.node,</span><br><span class="line">                                    instance_uuid=instance.uuid,</span><br><span class="line">                                    status=<span class="string">'accepted'</span>,</span><br><span class="line">                                    migration_type=<span class="string">'evacuation'</span>)</span><br><span class="line">    <span class="keyword">if</span> host:</span><br><span class="line">        migration.dest_compute = host</span><br><span class="line">    migration.create()</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> self.compute_task_api.rebuild_instance(context,</span><br><span class="line">                    instance=instance,</span><br><span class="line">                    new_pass=admin_password,</span><br><span class="line">                    injected_files=<span class="literal">None</span>,</span><br><span class="line">                    image_ref=<span class="literal">None</span>,</span><br><span class="line">                    orig_image_ref=<span class="literal">None</span>,</span><br><span class="line">                    orig_sys_metadata=<span class="literal">None</span>,</span><br><span class="line">                    bdms=<span class="literal">None</span>,</span><br><span class="line">                    recreate=<span class="literal">True</span>,</span><br><span class="line">                    on_shared_storage=on_shared_storage,</span><br><span class="line">                    host=host,</span><br><span class="line">                    request_spec=request_spec,</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure><p></p><p>这个函数首先建立一个status为<code>accepted</code>、type为<code>evacuation</code>的数据，然后看是否指定目标主机，在我们的使用场景下这个值都为<code>None</code>，这里需要注意一个<code>recreate</code>参数，在疏散调用时值为<code>True</code>。</p><p>然后跟进<code>conductor/manager.py</code>中<code>ComputeTaskManager</code>类的<code>rebuild_instance</code>方法，这里会进行主机筛选：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild_instance</span><span class="params">(self, context, instance, orig_image_ref, image_ref,</span></span></span><br><span class="line"><span class="function"><span class="params">                        injected_files, new_pass, orig_sys_metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                        bdms, recreate, on_shared_storage,</span></span></span><br><span class="line"><span class="function"><span class="params">                        preserve_ephemeral=False, host=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                        request_spec=None, force_dest=None, filter_properties=None)</span>:</span></span><br><span class="line">    dest_filter_properties = filter_properties</span><br><span class="line">    <span class="keyword">with</span> compute_utils.EventReporter(context, <span class="string">'rebuild_server'</span>,</span><br><span class="line">                                        instance.uuid):</span><br><span class="line">        node = limits = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> host:</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                hosts = self._schedule_instances(context, request_spec, filter_properties)</span><br><span class="line">                host_dict = hosts.pop(<span class="number">0</span>)</span><br><span class="line">                host, node, limits = (host_dict[<span class="string">'host'</span>],</span><br><span class="line">                                        host_dict[<span class="string">'nodename'</span>],</span><br><span class="line">                                        host_dict[<span class="string">'limits'</span>])</span><br><span class="line">            <span class="keyword">except</span> exception.NoValidHost <span class="keyword">as</span> ex:</span><br><span class="line">                <span class="keyword">with</span> excutils.save_and_reraise_exception():</span><br><span class="line">                    self._set_vm_state_and_notify(context, instance.uuid,</span><br><span class="line">                            <span class="string">'rebuild_server'</span>,</span><br><span class="line">                            &#123;<span class="string">'vm_state'</span>: instance.vm_state,</span><br><span class="line">                                <span class="string">'task_state'</span>: <span class="literal">None</span>&#125;, ex, request_spec)</span><br><span class="line">                    LOG.warning(_LW(<span class="string">"No valid host found for rebuild"</span>),</span><br><span class="line">                                instance=instance)</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            migration = objects.Migration.get_by_instance_and_status(</span><br><span class="line">                context, instance.uuid, <span class="string">'accepted'</span>)</span><br><span class="line">        <span class="keyword">except</span> exception.MigrationNotFoundByStatus:</span><br><span class="line">            LOG.debug(<span class="string">"No migration record for the rebuild/evacuate "</span></span><br><span class="line">                        <span class="string">"request."</span>, instance=instance)</span><br><span class="line">            migration = <span class="literal">None</span></span><br><span class="line">        self.compute_rpcapi.rebuild_instance(context,</span><br><span class="line">                instance=instance,</span><br><span class="line">                new_pass=new_pass,</span><br><span class="line">                injected_files=injected_files,</span><br><span class="line">                image_ref=image_ref,</span><br><span class="line">                orig_image_ref=orig_image_ref,</span><br><span class="line">                orig_sys_metadata=orig_sys_metadata,</span><br><span class="line">                bdms=bdms,</span><br><span class="line">                recreate=recreate,</span><br><span class="line">                on_shared_storage=on_shared_storage,</span><br><span class="line">                preserve_ephemeral=preserve_ephemeral,</span><br><span class="line">                migration=migration,</span><br><span class="line">                host=host, node=node, limits=limits)</span><br></pre></td></tr></table></figure><p>然后再经过<code>compute/rpcapi.py</code>中<code>ComputeAPI</code>的<code>rebuild_instance</code>方法，最终进入<code>compute/manager.py</code>的<code>_do_rebuild_instance</code>函数，这个函数中进行主机状态、网络、磁盘相关的修改，构造好参数后进入<code>_rebuild_default_impl</code>函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_rebuild_default_impl</span><span class="params">(self, context, instance, image_meta,</span></span></span><br><span class="line"><span class="function"><span class="params">                            injected_files, admin_password, bdms,</span></span></span><br><span class="line"><span class="function"><span class="params">                            detach_block_devices, attach_block_devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                            network_info=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                            recreate=False, block_device_info=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                            preserve_ephemeral=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> preserve_ephemeral:</span><br><span class="line">        <span class="comment"># The default code path does not support preserving ephemeral</span></span><br><span class="line">        <span class="comment"># partitions.</span></span><br><span class="line">        <span class="keyword">raise</span> exception.PreserveEphemeralNotSupported()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> recreate:</span><br><span class="line">        detach_block_devices(context, bdms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._power_off_instance(context, instance, clean_shutdown=<span class="literal">True</span>)</span><br><span class="line">        detach_block_devices(context, bdms)</span><br><span class="line">        self.driver.destroy(context, instance,</span><br><span class="line">                            network_info=network_info,</span><br><span class="line">                            block_device_info=block_device_info)</span><br><span class="line"></span><br><span class="line">    instance.task_state = task_states.REBUILD_BLOCK_DEVICE_MAPPING</span><br><span class="line">    instance.save(expected_task_state=[task_states.REBUILDING])</span><br><span class="line"></span><br><span class="line">    new_block_device_info = attach_block_devices(context, instance, bdms)</span><br><span class="line"></span><br><span class="line">    instance.task_state = task_states.REBUILD_SPAWNING</span><br><span class="line">    instance.save(</span><br><span class="line">        expected_task_state=[task_states.REBUILD_BLOCK_DEVICE_MAPPING])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> instance.mutated_migration_context():</span><br><span class="line">        self.driver.spawn(context, instance, image_meta, injected_files,</span><br><span class="line">                            admin_password, network_info=network_info,</span><br><span class="line">                            block_device_info=new_block_device_info)</span><br></pre></td></tr></table></figure><p>由于传入的<code>recreate</code>值为<code>True</code>，怎么看也不会有触发删除磁盘的行为啊？else分支的<code>driver.destroy</code>函数看起来很可疑，跟进去看看，代码位于<code>virt/libvirt/driver.py</code>中:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">destroy</span><span class="params">(self, context, instance, network_info, block_device_info=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            destroy_disks=True, migrate_data=None)</span>:</span></span><br><span class="line">    self._destroy(instance)</span><br><span class="line">    self.cleanup(context, instance, network_info, block_device_info,</span><br><span class="line">                 destroy_disks, migrate_data)</span><br></pre></td></tr></table></figure><p>其中<code>_destory</code>函数主要是删除主机，代码有兴趣的可以看看。而真正执行删磁盘的代码位于<code>cleanup</code>函数中:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanup</span><span class="params">(self, context, instance, network_info, block_device_info=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            destroy_disks=True, migrate_data=None, destroy_vifs=True)</span>:</span></span><br><span class="line">    ......      </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._disconnect_volume(connection_info, disk_dev)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">with</span> excutils.save_and_reraise_exception() <span class="keyword">as</span> ctxt:</span><br><span class="line">                <span class="keyword">if</span> destroy_disks:</span><br><span class="line">                    <span class="comment"># Don't block on Volume errors if we're trying to</span></span><br><span class="line">                    <span class="comment"># delete the instance as we may be partially created</span></span><br><span class="line">                    <span class="comment"># or deleted</span></span><br><span class="line">                    ctxt.reraise = <span class="literal">False</span></span><br><span class="line">                    LOG.warning(</span><br><span class="line">                        _LW(<span class="string">"Ignoring Volume Error on vol %(vol_id)s "</span></span><br><span class="line">                            <span class="string">"during delete %(exc)s"</span>),</span><br><span class="line">                        &#123;<span class="string">'vol_id'</span>: vol.get(<span class="string">'volume_id'</span>), <span class="string">'exc'</span>: exc&#125;,</span><br><span class="line">                        instance=instance)</span><br><span class="line">    <span class="keyword">if</span> destroy_disks:</span><br><span class="line">        <span class="comment"># NOTE(haomai): destroy volumes if needed</span></span><br><span class="line">        <span class="keyword">if</span> CONF.libvirt.images_type == <span class="string">'lvm'</span>:</span><br><span class="line">            self._cleanup_lvm(instance, block_device_info)</span><br><span class="line">        <span class="keyword">if</span> CONF.libvirt.images_type == <span class="string">'rbd'</span>:</span><br><span class="line">            self._cleanup_rbd(instance)</span><br><span class="line">    ......</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_cleanup_rbd</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">    <span class="comment"># NOTE(nic): On revert_resize, the cleanup steps for the root</span></span><br><span class="line">    <span class="comment"># volume are handled with an "rbd snap rollback" command,</span></span><br><span class="line">    <span class="comment"># and none of this is needed (and is, in fact, harmful) so</span></span><br><span class="line">    <span class="comment"># filter out non-ephemerals from the list</span></span><br><span class="line">    <span class="keyword">if</span> instance.task_state == task_states.RESIZE_REVERTING:</span><br><span class="line">        filter_fn = <span class="keyword">lambda</span> disk: (disk.startswith(instance.uuid) <span class="keyword">and</span></span><br><span class="line">                                    disk.endswith(<span class="string">'disk.local'</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        filter_fn = <span class="keyword">lambda</span> disk: disk.startswith(instance.uuid)</span><br><span class="line">    LibvirtDriver._get_rbd_driver().cleanup_volumes(filter_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Roy注：下面这函数在virt/libvirt/storage/rbd_utils.py中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanup_volumes</span><span class="params">(self, filter_fn)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> RADOSClient(self, self.pool) <span class="keyword">as</span> client:</span><br><span class="line">        volumes = RbdProxy().list(client.ioctx)</span><br><span class="line">        <span class="keyword">for</span> volume <span class="keyword">in</span> filter(filter_fn, volumes):</span><br><span class="line">            self._destroy_volume(client, volume)</span><br></pre></td></tr></table></figure><p>至此，能够触发删除根磁盘的代码可以确定了。这里我们倒过来想，如果疏散行为不会导致磁盘被删除，那么一定是其他地方调用了这个函数呢？经过排查，所有会调用这个<code>destroy</code>函数的地方有4个:</p><ol><li>evacuate</li><li>revert_resize</li><li>shelve_offloading</li><li>host_init</li></ol><p>其中1、2、3都被排除，那么就看host_init时做了什么吧：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_host</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Initialization for a standalone compute service."""</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># checking that instance was not already evacuated to other host</span></span><br><span class="line">        self._destroy_evacuated_instances(context)</span><br><span class="line">        <span class="keyword">for</span> instance <span class="keyword">in</span> instances:</span><br><span class="line">            self._init_instance(context, instance)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> CONF.defer_iptables_apply:</span><br><span class="line">            self.driver.filter_defer_apply_off()</span><br><span class="line">        self._update_scheduler_instance_info(context, instances)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_destroy_evacuated_instances</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    <span class="string">"""Destroys evacuated instances.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    While nova-compute was down, the instances running on it could be</span></span><br><span class="line"><span class="string">    evacuated to another host. Check that the instances reported</span></span><br><span class="line"><span class="string">    by the driver are still associated with this host.  If they are</span></span><br><span class="line"><span class="string">    not, destroy them, with the exception of instances which are in</span></span><br><span class="line"><span class="string">    the MIGRATING, RESIZE_MIGRATING, RESIZE_MIGRATED, RESIZE_FINISH</span></span><br><span class="line"><span class="string">    task state or RESIZED vm state.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    filters = &#123;</span><br><span class="line">        <span class="string">'source_compute'</span>: self.host,</span><br><span class="line">        <span class="string">'status'</span>: [<span class="string">'accepted'</span>, <span class="string">'done'</span>],</span><br><span class="line">        <span class="string">'migration_type'</span>: <span class="string">'evacuation'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    evacuations = objects.MigrationList.get_by_filters(context, filters)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> evacuations:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    evacuations = &#123;mig.instance_uuid: mig <span class="keyword">for</span> mig <span class="keyword">in</span> evacuations&#125;</span><br><span class="line"></span><br><span class="line">    filters = &#123;<span class="string">'deleted'</span>: <span class="literal">False</span>&#125;</span><br><span class="line">    local_instances = self._get_instances_on_driver(context, filters)</span><br><span class="line">    evacuated = [inst <span class="keyword">for</span> inst <span class="keyword">in</span> local_instances</span><br><span class="line">                    <span class="keyword">if</span> inst.uuid <span class="keyword">in</span> evacuations]</span><br><span class="line">    <span class="keyword">for</span> instance <span class="keyword">in</span> evacuated:</span><br><span class="line">        migration = evacuations[instance.uuid]</span><br><span class="line">        LOG.info(_LI(<span class="string">'Deleting instance as it has been evacuated from '</span></span><br><span class="line">                        <span class="string">'this host'</span>), instance=instance)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            network_info = self.network_api.get_instance_nw_info(</span><br><span class="line">                context, instance)</span><br><span class="line">            bdi = self._get_instance_block_device_info(context,</span><br><span class="line">                                                        instance)</span><br><span class="line">            destroy_disks = <span class="keyword">not</span> (self._is_instance_storage_shared(</span><br><span class="line">                context, instance))</span><br><span class="line">        <span class="keyword">except</span> exception.InstanceNotFound:</span><br><span class="line">            network_info = network_model.NetworkInfo()</span><br><span class="line">            bdi = &#123;&#125;</span><br><span class="line">            LOG.info(_LI(<span class="string">'Instance has been marked deleted already, '</span></span><br><span class="line">                            <span class="string">'removing it from the hypervisor.'</span>),</span><br><span class="line">                        instance=instance)</span><br><span class="line">            <span class="comment"># always destroy disks if the instance was deleted</span></span><br><span class="line">            destroy_disks = <span class="literal">True</span></span><br><span class="line">        self.driver.destroy(context, instance,</span><br><span class="line">                            network_info,</span><br><span class="line">                            bdi, destroy_disks)</span><br><span class="line">        migration.status = <span class="string">'completed'</span></span><br><span class="line">        migration.save()</span><br></pre></td></tr></table></figure><p>会不会是疏散过程中触发了异常然后又重启了计算节点才导致的根磁盘被删除呢？</p><p>后来和同事商讨后发现我的思路错了，被上面<code>driver.destroy</code>这个名称误导，其实还有一个地方会进行删除磁盘行为，就是<code>spwan</code>函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(self, context, instance, image_meta, injected_files,</span></span></span><br><span class="line"><span class="function"><span class="params">          admin_password, network_info=None, block_device_info=None)</span>:</span></span><br><span class="line">    disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,</span><br><span class="line">                                        instance,</span><br><span class="line">                                        image_meta,</span><br><span class="line">                                        block_device_info)</span><br><span class="line">    ...</span><br><span class="line">    xml = self._get_guest_xml(context, instance, network_info,</span><br><span class="line">                                disk_info, image_meta,</span><br><span class="line">                                block_device_info=block_device_info)</span><br><span class="line">    self._create_domain_and_network(</span><br><span class="line">        context, xml, instance, network_info, disk_info,</span><br><span class="line">        block_device_info=block_device_info,</span><br><span class="line">        post_xml_callback=gen_confdrive,</span><br><span class="line">        destroy_disks_on_failure=<span class="literal">True</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_domain_and_network</span><span class="params">(self, context, xml, instance, network_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                disk_info, block_device_info=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                                power_on=True, reboot=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                                vifs_already_plugged=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                                post_xml_callback=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                                destroy_disks_on_failure=False)</span>:</span></span><br><span class="line"></span><br><span class="line">    block_device_mapping = driver.block_device_info_get_mapping(</span><br><span class="line">        block_device_info)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="comment"># Any other error, be sure to clean up</span></span><br><span class="line">        LOG.error(_LE(<span class="string">'Failed to start libvirt guest'</span>),</span><br><span class="line">                    instance=instance)</span><br><span class="line">        <span class="keyword">with</span> excutils.save_and_reraise_exception():</span><br><span class="line">            self._cleanup_failed_start(context, instance, network_info,</span><br><span class="line">                                        block_device_info, guest,</span><br><span class="line">                                        destroy_disks_on_failure)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_cleanup_failed_start</span><span class="params">(self, context, instance, network_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                          block_device_info, guest, destroy_disks)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> guest <span class="keyword">and</span> guest.is_active():</span><br><span class="line">            guest.poweroff()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.cleanup(context, instance, network_info=network_info,</span><br><span class="line">                    block_device_info=block_device_info,</span><br><span class="line">                    destroy_disks=destroy_disks)</span><br></pre></td></tr></table></figure><p>注意<code>spwan</code>调用<code>_create_domain_and_network</code>传递的参数<code>destroy_disks_on_failure=True</code>，如果发生异常则会进行关机以及执行<code>cleanup</code>函数且传递的<code>destroy_disks=True</code>。</p><p>在我们这个场景下，如果在<code>nova.conf</code>设置了内存超分比，而实际内存又不足的情况下，就会导致疏散失败根磁盘被删除的情况。看了一下目前s版的nova依然会存在这个问题。</p><p>后来反思，当找到删除磁盘的操作在<code>cleanup</code>函数中逆向查找调用时，居然鬼使神差的认为其他地方会调用<code>destroy</code>函数，忽略了其他地方调用<code>cleanup</code>函数的可能性，浪费了一定时间，下次调试时还是要一步一步回推才行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到一个诡异的问题，对某个有问题的计算节点进行疏散，结果有些虚拟机的根磁盘居然消！失！了？首先能够确定的是ceph不会自动删除，那么一定是某个地方触发了删除根磁盘的操作。&lt;/p&gt;&lt;p&gt;这如果发生在生产环境可是一个极其严重的问题，正好借此排查的机会梳理一下nova关于主机疏散的流程。&lt;/p&gt;&lt;p&gt;以下代码为N版，但大体流程相差应该不大。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Nova" scheme="http://www.hi-roy.com/source/all-tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-外观模式</title>
    <link href="http://www.hi-roy.com/2020/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2020/01/08/设计模式-外观模式/</id>
    <published>2020-01-08T08:58:08.000Z</published>
    <updated>2020-01-08T09:18:03.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式(Facade Pattern)"></a>外观模式(Facade Pattern)</h2><p>这个模式即便没听说过，也很可能在很多地方已经使用了，是非常常用的设计模式之一，完美体现了面向对象“封装”的特性。简单说就是通过一个“外观”将系统内部的实现隐藏起来，将外部系统和内部系统进行解耦。</p><a id="more"></a><p><img src="/assets/images/design-pattern/facade.png" alt="facade.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SysA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a SysA)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"in SysA show"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SysB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b SysB)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"in SysB show"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SysC <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c SysC)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"in SysC show"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Facade <span class="keyword">struct</span> &#123;</span><br><span class="line">a *SysA</span><br><span class="line">b *SysB</span><br><span class="line">c *SysC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Facade)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">f.a.show()</span><br><span class="line">f.b.show()</span><br><span class="line">f.c.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">facade := Facade&#123;<span class="built_in">new</span>(SysA), <span class="built_in">new</span>(SysB), <span class="built_in">new</span>(SysC)&#125;</span><br><span class="line">facade.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>系统内部复杂度较高，需要一个更高级别的简单接口简化操作时。</li><li>需要层级化子系统、简化子系统之间依赖性时。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>单例模式:一般情况下，外观模式会结合单例模式来使用，供外部应用调用。</li><li>中介者模式:中介者模式扮演各个参与者的中间人，使系统各个参与者解耦；而外观模式时形成更高级别的接口供他人调用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;外观模式-Facade-Pattern&quot;&gt;&lt;a href=&quot;#外观模式-Facade-Pattern&quot; class=&quot;headerlink&quot; title=&quot;外观模式(Facade Pattern)&quot;&gt;&lt;/a&gt;外观模式(Facade Pattern)&lt;/h2&gt;&lt;p&gt;这个模式即便没听说过，也很可能在很多地方已经使用了，是非常常用的设计模式之一，完美体现了面向对象“封装”的特性。简单说就是通过一个“外观”将系统内部的实现隐藏起来，将外部系统和内部系统进行解耦。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰器模式</title>
    <link href="http://www.hi-roy.com/2020/01/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2020/01/02/设计模式-装饰器模式/</id>
    <published>2020-01-02T08:58:08.000Z</published>
    <updated>2020-01-02T09:49:48.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器模式-Decorator-Pattern"><a href="#装饰器模式-Decorator-Pattern" class="headerlink" title="装饰器模式(Decorator Pattern)"></a>装饰器模式(Decorator Pattern)</h2><p>在python中有一个非常常用的语法糖<code>@</code>，本质上就是装饰器。这种模式可以不改变原文件的情况下动态的扩展一个对象的功能而不用创建子类，避免了类膨胀，是一种比较常用的模式，有个细节需要注意的就是装饰的顺序。</p><a id="more"></a><p><img src="/assets/images/design-pattern/decorator.png" alt="decorator.png"></p><p>这个模式核心有4个角色：</p><ol><li>被装饰者抽象Component：一个接口或者抽象类，定义最核心对象。</li><li>被装饰者具体实现ConcreteComponent：Component的实现类，装饰的就是这个实现类。</li><li>装饰者抽象Decorator：一般是个抽象类，实现接口或者抽象方法，里面必须有一个Component变量引用。</li><li>装饰者实现ConcreteDecorator：具体的装饰者类。</li></ol><p>当只有一个被装饰者时，也可以吧Component和ConcreateComponent合并成一个，灵活运用而不要死板。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcreteComponent <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConcreteComponent)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"This is %s\n"</span>, c.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Decorator <span class="keyword">struct</span> &#123;</span><br><span class="line">c Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Decorator)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.c.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Decorator)</span> <span class="title">setComponent</span><span class="params">(com Component)</span></span> &#123;</span><br><span class="line">d.c = com</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcreteDecorator <span class="keyword">struct</span> &#123;</span><br><span class="line">d   Decorator</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteDecorator)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"In ConcreteDecorator show func! im %d old!\n"</span>, c.age)</span><br><span class="line">c.d.show()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteDecorator)</span> <span class="title">setComponent</span><span class="params">(com Component)</span></span> &#123;</span><br><span class="line">c.d.setComponent(com)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := ConcreteComponent&#123;name: <span class="string">"tom"</span>&#125;</span><br><span class="line">cd := ConcreteDecorator&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">cd.setComponent(c)</span><br><span class="line">cd.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In ConcreteDecorator show func! im 10 old!</span><br><span class="line">This is concrete_component</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>当需要动态的对某个对象添加功能时。</li><li>当某个对象的功能经常发生变化时，又想避免过多的继承造成类膨胀。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>适配器模式：适配器模式将一种接口转换成另一种接口，而装饰者模式则是不改变原有的功能上增加新功能。</li><li>策略模式：切换运算法则的方式来变换功能。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;装饰器模式-Decorator-Pattern&quot;&gt;&lt;a href=&quot;#装饰器模式-Decorator-Pattern&quot; class=&quot;headerlink&quot; title=&quot;装饰器模式(Decorator Pattern)&quot;&gt;&lt;/a&gt;装饰器模式(Decorator Pattern)&lt;/h2&gt;&lt;p&gt;在python中有一个非常常用的语法糖&lt;code&gt;@&lt;/code&gt;，本质上就是装饰器。这种模式可以不改变原文件的情况下动态的扩展一个对象的功能而不用创建子类，避免了类膨胀，是一种比较常用的模式，有个细节需要注意的就是装饰的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-组合模式</title>
    <link href="http://www.hi-roy.com/2019/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/12/23/设计模式-组合模式/</id>
    <published>2019-12-23T09:58:08.000Z</published>
    <updated>2019-12-23T11:08:03.692Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式(Composite Pattern):将对象组合成树形结构表示来“部分-整体”的层次结构，使用户对单个对象和组合对象的使用具有一致性。</p><p>看上去有点抽象，其实就是一种树形结构。比如二叉树，每个非叶子节点都有2个子节点，叶子节点除了没有子节点外和父节点、根节点都是一样的。在通俗来说，比如公司的层级架构，从老板(根节点)到经理(非叶子节点)再到员工(叶子节点)，他们有很多共性的东西，比如都有姓名、工号，老板和经理有添加、移除手下员工的能力，而作为员工则只能干活。</p><p>从代码实现来说，就是老板、经理、员工使用一个抽象类，而老板和经理实现某些特定的方法，这就是组合模式，十分容易理解。</p><a id="more"></a><p><img src="/assets/images/design-pattern/composite.png" alt="composite.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> duty <span class="keyword">interface</span> &#123;</span><br><span class="line">addStaff(d duty)</span><br><span class="line">getStaff() []duty</span><br><span class="line">printUserInfo()</span><br><span class="line">printEmployeesInfo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Staff <span class="keyword">struct</span> &#123;</span><br><span class="line">number   <span class="keyword">string</span></span><br><span class="line">name     <span class="keyword">string</span></span><br><span class="line">position <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Staff)</span> <span class="title">printUserInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"ID:%s,Name:%s,position:%s\n"</span>, s.number, s.name, s.position)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Staff)</span> <span class="title">printEmployeesInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Staff)</span> <span class="title">addStaff</span><span class="params">(d duty)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Staff)</span> <span class="title">getStaff</span><span class="params">()</span> []<span class="title">duty</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []duty&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">self Staff</span><br><span class="line">arr  []duty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">getStaff</span><span class="params">()</span> []<span class="title">duty</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">addStaff</span><span class="params">(d duty)</span></span> &#123;</span><br><span class="line">m.arr = <span class="built_in">append</span>(m.arr, d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">printUserInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.self.printUserInfo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">printEmployeesInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> m.arr &#123;</span><br><span class="line">e.printUserInfo()</span><br><span class="line"><span class="keyword">for</span> _, ee := <span class="keyword">range</span> e.getStaff() &#123;</span><br><span class="line">ee.printUserInfo()</span><br><span class="line">ee.printEmployeesInfo()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employees <span class="keyword">struct</span> &#123;</span><br><span class="line">self Staff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employees)</span> <span class="title">addStaff</span><span class="params">(d duty)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employees)</span> <span class="title">getStaff</span><span class="params">()</span> []<span class="title">duty</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []duty&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employees)</span> <span class="title">printUserInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">e.self.printUserInfo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employees)</span> <span class="title">printEmployeesInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ceo := Manager&#123;self: Staff&#123;name: <span class="string">"ceo"</span>, number: <span class="string">"001"</span>, position: <span class="string">"CEO"</span>&#125;&#125;</span><br><span class="line">techM := Manager&#123;self: Staff&#123;name: <span class="string">"技术经理"</span>, number: <span class="string">"002"</span>, position: <span class="string">"技术经理"</span>&#125;&#125;</span><br><span class="line">techMG1 := Manager&#123;self: Staff&#123;name: <span class="string">"技术组长1"</span>, number: <span class="string">"004"</span>, position: <span class="string">"技术组长"</span>&#125;&#125;</span><br><span class="line">techMG2 := Manager&#123;self: Staff&#123;name: <span class="string">"技术组长2"</span>, number: <span class="string">"005"</span>, position: <span class="string">"技术组长"</span>&#125;&#125;</span><br><span class="line">finaM := Manager&#123;self: Staff&#123;name: <span class="string">"财务经理"</span>, number: <span class="string">"003"</span>, position: <span class="string">"财务经理"</span>&#125;&#125;</span><br><span class="line">emp1 := Employees&#123;self: Staff&#123;name: <span class="string">"开发1"</span>, number: <span class="string">"0041"</span>, position: <span class="string">"开发人员"</span>&#125;&#125;</span><br><span class="line">emp2 := Employees&#123;self: Staff&#123;name: <span class="string">"开发2"</span>, number: <span class="string">"0052"</span>, position: <span class="string">"开发人员"</span>&#125;&#125;</span><br><span class="line">emp3 := Employees&#123;self: Staff&#123;name: <span class="string">"财务1"</span>, number: <span class="string">"0031"</span>, position: <span class="string">"财务人员"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">ceo.addStaff(&amp;techM)</span><br><span class="line">ceo.addStaff(&amp;finaM)</span><br><span class="line"></span><br><span class="line">techM.addStaff(&amp;techMG1)</span><br><span class="line">techM.addStaff(&amp;techMG2)</span><br><span class="line"></span><br><span class="line">techMG1.addStaff(&amp;emp1)</span><br><span class="line">techMG2.addStaff(&amp;emp2)</span><br><span class="line">finaM.addStaff(&amp;emp3)</span><br><span class="line"></span><br><span class="line">ceo.printUserInfo()</span><br><span class="line">ceo.printEmployeesInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ID:001,Name:ceo,position:CEO</span><br><span class="line">ID:002,Name:技术经理,position:技术经理</span><br><span class="line">ID:004,Name:技术组长1,position:技术组长</span><br><span class="line">ID:0041,Name:开发1,position:开发人员</span><br><span class="line">ID:005,Name:技术组长2,position:技术组长</span><br><span class="line">ID:0052,Name:开发2,position:开发人员</span><br><span class="line">ID:003,Name:财务经理,position:财务经理</span><br><span class="line">ID:0031,Name:财务1,position:财务人员</span><br></pre></td></tr></table></figure><p>如果不使用组合模式，代码则需要建立一个<code>Manager</code>类，里面有添加、展示员工方法，再建立一个<code>Employees</code>类表示员工，这个类仅有<code>printUserInfo</code>方法。而使用组合模式，则将这2者统一为<code>Staff</code>类的子类实现相关接口即可，这也是面向抽象编程的思想。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>表示对象的“部分-整体”层次结构时。</li><li>希望用户忽略组合对象和单个对象的不同时。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组合模式(Composite Pattern):将对象组合成树形结构表示来“部分-整体”的层次结构，使用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;&lt;p&gt;看上去有点抽象，其实就是一种树形结构。比如二叉树，每个非叶子节点都有2个子节点，叶子节点除了没有子节点外和父节点、根节点都是一样的。在通俗来说，比如公司的层级架构，从老板(根节点)到经理(非叶子节点)再到员工(叶子节点)，他们有很多共性的东西，比如都有姓名、工号，老板和经理有添加、移除手下员工的能力，而作为员工则只能干活。&lt;/p&gt;&lt;p&gt;从代码实现来说，就是老板、经理、员工使用一个抽象类，而老板和经理实现某些特定的方法，这就是组合模式，十分容易理解。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-桥接模式</title>
    <link href="http://www.hi-roy.com/2019/12/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/12/12/设计模式-桥接模式/</id>
    <published>2019-12-12T08:58:08.000Z</published>
    <updated>2019-12-12T03:42:44.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式(Bridge Pattern)"></a>桥接模式(Bridge Pattern)</h2><p>桥接模式核心原理是将抽象部分和实现部分分析，使二者可以独立的变化。再具体一点，当某个类型由于自身逻辑可以有两个或多个维度的变化，使用桥接模式可以令这些维度变化时不影响其他维度。再举个例子，手机——可以按照品牌来分类，比如苹果华为三星，也可以按照功能分类，比如拍照手机，游戏手机等等。</p><p>桥接模式有2个设计原则：</p><ol><li>使用聚合而不使用继承。（使用继承一定是在<code>is-a</code>的关系时再考虑使用）</li><li>抽象和实现分离。</li></ol><a id="more"></a><p><img src="/assets/images/design-pattern/bridge.png" alt="bridge.png"></p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> phoneFeature <span class="keyword">interface</span> &#123;</span><br><span class="line">showFeature()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gamePhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g gamePhone)</span> <span class="title">showFeature</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"This phone is for play game!\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cameraPhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cameraPhone)</span> <span class="title">showFeature</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"This phone is for camera!\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> phoneBrand <span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">feature phoneFeature</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b phoneBrand)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"This is a %s phone!\n"</span>, b.name)</span><br><span class="line">b.feature.showFeature()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *phoneBrand)</span> <span class="title">setFeature</span><span class="params">(phonefeature phoneFeature)</span></span> &#123;</span><br><span class="line">b.feature = phonefeature</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> huawei <span class="keyword">struct</span> &#123;</span><br><span class="line">*phoneBrand</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> apple <span class="keyword">struct</span> &#123;</span><br><span class="line">*phoneBrand</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := huawei&#123;phoneBrand: &amp;phoneBrand&#123;name: <span class="string">"huawei"</span>&#125;&#125;</span><br><span class="line">a := apple&#123;phoneBrand: &amp;phoneBrand&#123;name: <span class="string">"apple"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">h.setFeature(cameraPhone&#123;&#125;)</span><br><span class="line">h.show()</span><br><span class="line"></span><br><span class="line">a.setFeature(gamePhone&#123;&#125;)</span><br><span class="line">a.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我创建了2种类型的手机：游戏手机和拍照手机，2种品牌：华为和苹果。然后通过<code>phoneFeature</code>接口作为桥梁将这2者组合在一起，通过这种方法，不论以后是增加修改手机品牌还是类型，都不会影响到另一方了。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>类的抽象和实现都应该可以通过生成子类的方法加以扩充</li><li>对一个抽象的实现部分的修改应对客户不产生影响。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>抽象工厂：有时为了使设计更加抽象，可以在桥接模式中使用抽象工厂。</li><li>适配器模式：适配器模式将一种接口转换成另一种接口，而桥接则是把实现和接口分离以便独立变化。</li><li>模板方法：利用实现类的层次，在父类中定义抽象方法，然后再子类中实现。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;桥接模式-Bridge-Pattern&quot;&gt;&lt;a href=&quot;#桥接模式-Bridge-Pattern&quot; class=&quot;headerlink&quot; title=&quot;桥接模式(Bridge Pattern)&quot;&gt;&lt;/a&gt;桥接模式(Bridge Pattern)&lt;/h2&gt;&lt;p&gt;桥接模式核心原理是将抽象部分和实现部分分析，使二者可以独立的变化。再具体一点，当某个类型由于自身逻辑可以有两个或多个维度的变化，使用桥接模式可以令这些维度变化时不影响其他维度。再举个例子，手机——可以按照品牌来分类，比如苹果华为三星，也可以按照功能分类，比如拍照手机，游戏手机等等。&lt;/p&gt;&lt;p&gt;桥接模式有2个设计原则：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用聚合而不使用继承。（使用继承一定是在&lt;code&gt;is-a&lt;/code&gt;的关系时再考虑使用）&lt;/li&gt;&lt;li&gt;抽象和实现分离。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码学习笔记4</title>
    <link href="http://www.hi-roy.com/2019/12/09/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <id>http://www.hi-roy.com/2019/12/09/OpenStack源码学习笔记4/</id>
    <published>2019-12-09T04:46:29.000Z</published>
    <updated>2019-12-10T03:22:48.176Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录nova创建快照时候的过程，根据<a href="https://docs.openstack.org/api-ref/compute/?expanded=create-image-createimage-action-detail#create-image-createimage-action" target="_blank" rel="noopener">文档</a>，创建快照其实是向<code>/servers/{server_id}/action</code>发送了一个POST的请求，内容则是类似:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    "createImage" : &#123;</span><br><span class="line">        "name" : "image-name",</span><br><span class="line">        "metadata": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>根据openstack的套路，首先找到处理这个请求的代码，在第一篇文章中我们分析了在Stein版中虚拟机的创建过程，但由于某些不可描述的原因，<strong><em>下面的代码是N版的</em></strong>，一定要注意版本问题。N版中是没有<code>nova/api/openstack/compute/routes.py</code>这个文件的，所有处理请求的代码都在<code>nova/api/openstack/compute/</code>目录中，所以我们直接看<code>servers.py</code>即可，相关代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wsgi.response(202)</span></span><br><span class="line"><span class="meta">@extensions.expected_errors((400, 403, 404, 409))</span></span><br><span class="line"><span class="meta">@wsgi.action('createImage')</span></span><br><span class="line"><span class="meta">@common.check_snapshots_enabled</span></span><br><span class="line"><span class="meta">@validation.schema(schema_servers.create_image, '2.0', '2.0')</span></span><br><span class="line"><span class="meta">@validation.schema(schema_servers.create_image, '2.1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_action_create_image</span><span class="params">(self, req, id, body)</span>:</span></span><br><span class="line">    <span class="string">"""Snapshot a server instance."""</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> compute_utils.is_volume_backed_instance(context, instance,</span><br><span class="line">                                                        bdms):</span><br><span class="line">            context.can(server_policies.SERVERS %</span><br><span class="line">                <span class="string">'create_image:allow_volume_backed'</span>)</span><br><span class="line">            image = self.compute_api.snapshot_volume_backed(</span><br><span class="line">                                                    context,</span><br><span class="line">                                                    instance,</span><br><span class="line">                                                    image_name,</span><br><span class="line">                                                    extra_properties=</span><br><span class="line">                                                    metadata)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            image = self.compute_api.snapshot(context,</span><br><span class="line">                                                instance,</span><br><span class="line">                                                image_name,</span><br><span class="line">                                                extra_properties=metadata)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># build location of newly-created image entity</span></span><br><span class="line">    image_id = str(image[<span class="string">'id'</span>])</span><br><span class="line">    image_ref = glance.generate_image_url(image_id)</span><br><span class="line"></span><br><span class="line">    resp = webob.Response(status_int=<span class="number">202</span>)</span><br><span class="line">    resp.headers[<span class="string">'Location'</span>] = image_ref</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>由于我的配置文件中没启用<code>cell</code>功能，所以代码中的<code>self.compute_api</code>就是<code>nova/compute/api.py</code>中的<code>API()</code>类，<code>snapshot</code>方法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@check_instance_cell</span></span><br><span class="line"><span class="meta">@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED,</span></span><br><span class="line">                                vm_states.PAUSED, vm_states.SUSPENDED])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span><span class="params">(self, context, instance, name, extra_properties=None)</span>:</span></span><br><span class="line">    <span class="string">"""Snapshot the given instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param instance: nova.objects.instance.Instance object</span></span><br><span class="line"><span class="string">    :param name: name of the snapshot</span></span><br><span class="line"><span class="string">    :param extra_properties: dict of extra image properties to include</span></span><br><span class="line"><span class="string">                                when creating the image.</span></span><br><span class="line"><span class="string">    :returns: A dict containing image metadata</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image_meta = self._create_image(context, instance, name,</span><br><span class="line">                                    <span class="string">'snapshot'</span>,</span><br><span class="line">                                    extra_properties=extra_properties)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NOTE(comstud): Any changes to this method should also be made</span></span><br><span class="line">    <span class="comment"># to the snapshot_instance() method in nova/cells/messaging.py</span></span><br><span class="line">    instance.task_state = task_states.IMAGE_SNAPSHOT_PENDING</span><br><span class="line">    instance.save(expected_task_state=[<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">    self.compute_rpcapi.snapshot_instance(context, instance,</span><br><span class="line">                                            image_meta[<span class="string">'id'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image_meta</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_image</span><span class="params">(self, context, instance, name, image_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                    extra_properties=None)</span>:</span></span><br><span class="line">    <span class="string">"""Create new image entry in the image service.  This new image</span></span><br><span class="line"><span class="string">    will be reserved for the compute manager to upload a snapshot</span></span><br><span class="line"><span class="string">    or backup.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param context: security context</span></span><br><span class="line"><span class="string">    :param instance: nova.objects.instance.Instance object</span></span><br><span class="line"><span class="string">    :param name: string for name of the snapshot</span></span><br><span class="line"><span class="string">    :param image_type: snapshot | backup</span></span><br><span class="line"><span class="string">    :param extra_properties: dict of extra image properties to include</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    properties = &#123;</span><br><span class="line">        <span class="string">'instance_uuid'</span>: instance.uuid,</span><br><span class="line">        <span class="string">'user_id'</span>: str(context.user_id),</span><br><span class="line">        <span class="string">'image_type'</span>: image_type,</span><br><span class="line">    &#125;</span><br><span class="line">    properties.update(extra_properties <span class="keyword">or</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    image_meta = self._initialize_instance_snapshot_metadata(</span><br><span class="line">        instance, name, properties)</span><br><span class="line">    <span class="comment"># if we're making a snapshot, omit the disk and container formats,</span></span><br><span class="line">    <span class="comment"># since the image may have been converted to another format, and the</span></span><br><span class="line">    <span class="comment"># original values won't be accurate.  The driver will populate these</span></span><br><span class="line">    <span class="comment"># with the correct values later, on image upload.</span></span><br><span class="line">    <span class="keyword">if</span> image_type == <span class="string">'snapshot'</span>:</span><br><span class="line">        image_meta.pop(<span class="string">'disk_format'</span>, <span class="literal">None</span>)</span><br><span class="line">        image_meta.pop(<span class="string">'container_format'</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> self.image_api.create(context, image_meta)</span><br></pre></td></tr></table></figure><p>代码中的<code>self.image_api</code>就是调用glanceclient创建镜像，之前已经写过镜像上传这里就不贴代码了，有兴趣的可以去看<code>nova/image/glance.py</code>，看到rpc就知道这里发送一个异步请求，看<code>nova/compute/rpcapi.py</code>代码不出所料:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot_instance</span><span class="params">(self, ctxt, instance, image_id)</span>:</span></span><br><span class="line">    version = <span class="string">'4.0'</span></span><br><span class="line">    cctxt = self.router.by_instance(ctxt, instance).prepare(</span><br><span class="line">            server=_compute_host(<span class="literal">None</span>, instance), version=version)</span><br><span class="line">    cctxt.cast(ctxt, <span class="string">'snapshot_instance'</span>,</span><br><span class="line">                instance=instance,</span><br><span class="line">                image_id=image_id)</span><br></pre></td></tr></table></figure><p>根据套路，这里应该是到<code>nova/compute/manager.py</code>了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wrap_exception()</span></span><br><span class="line"><span class="meta">@reverts_task_state</span></span><br><span class="line"><span class="meta">@wrap_instance_fault</span></span><br><span class="line"><span class="meta">@delete_image_on_error</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot_instance</span><span class="params">(self, context, image_id, instance)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        instance.task_state = task_states.IMAGE_SNAPSHOT</span><br><span class="line">        instance.save(</span><br><span class="line">                    expected_task_state=task_states.IMAGE_SNAPSHOT_PENDING)</span><br><span class="line">    <span class="keyword">except</span> exception.InstanceNotFound:</span><br><span class="line">        <span class="comment"># possibility instance no longer exists, no point in continuing</span></span><br><span class="line">        LOG.debug(<span class="string">"Instance not found, could not set state %s "</span></span><br><span class="line">                    <span class="string">"for instance."</span>,</span><br><span class="line">                    task_states.IMAGE_SNAPSHOT, instance=instance)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> exception.UnexpectedDeletingTaskStateError:</span><br><span class="line">        LOG.debug(<span class="string">"Instance being deleted, snapshot cannot continue"</span>,</span><br><span class="line">                    instance=instance)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self._snapshot_instance(context, image_id, instance,</span><br><span class="line">                            task_states.IMAGE_SNAPSHOT)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_snapshot_instance</span><span class="params">(self, context, image_id, instance,</span></span></span><br><span class="line"><span class="function"><span class="params">                        expected_task_state)</span>:</span></span><br><span class="line">    context = context.elevated()</span><br><span class="line">    instance.power_state = self._get_power_state(context, instance)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ...</span><br><span class="line">        self.driver.snapshot(context, instance, image_id,</span><br><span class="line">                                update_task_state)</span><br><span class="line">        instance.task_state = <span class="literal">None</span></span><br><span class="line">        instance.save(expected_task_state=task_states.IMAGE_UPLOADING)</span><br><span class="line">        self._notify_about_instance_usage(context, instance,</span><br><span class="line">                                            <span class="string">"snapshot.end"</span>)</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>然后进入<code>driver</code>中，这里我以使用<code>libvirt</code>为例，位于<code>nova/virt/libvirt/driver.py</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span><span class="params">(self, context, instance, image_id, update_task_state)</span>:</span></span><br><span class="line">        <span class="string">"""Create snapshot from a running VM instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This command only works with qemu 0.14+</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ...        </span><br><span class="line">        snapshot = self._image_api.get(context, image_id)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># NOTE(bfilippov): save lvm and rbd as raw</span></span><br><span class="line">        <span class="keyword">if</span> image_format == <span class="string">'lvm'</span> <span class="keyword">or</span> image_format == <span class="string">'rbd'</span>:</span><br><span class="line">            image_format = <span class="string">'raw'</span></span><br><span class="line"></span><br><span class="line">        metadata = self._create_snapshot_metadata(instance.image_meta,</span><br><span class="line">                                                  instance,</span><br><span class="line">                                                  image_format,</span><br><span class="line">                                                  snapshot[<span class="string">'name'</span>])</span><br><span class="line">        ....</span><br><span class="line">        snapshot_backend = self.image_backend.snapshot(instance,</span><br><span class="line">                disk_path,</span><br><span class="line">                image_type=source_type)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            update_task_state(task_state=task_states.IMAGE_UPLOADING,</span><br><span class="line">                              expected_state=task_states.IMAGE_PENDING_UPLOAD)</span><br><span class="line">            metadata[<span class="string">'location'</span>] = snapshot_backend.direct_snapshot(</span><br><span class="line">                context, snapshot_name, image_format, image_id,</span><br><span class="line">                instance.image_ref)</span><br><span class="line">            ...</span><br><span class="line">            self._image_api.update(context, image_id, metadata,</span><br><span class="line">                                   purge_props=<span class="literal">False</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这里代码太长了我做了删减，所以缩进看起来有点奇怪。经过一系列的判断、准备后，首先获取对应的存储后端，这里我以rbd为例，其他类型的可以看<code>nova/virt/libvirt/imagebackend.py</code>中<code>Backend</code>类的相关定义。然后调用<code>Rbd</code>类下的<code>direct_snapshot</code>方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">direct_snapshot</span><span class="params">(self, context, snapshot_name, image_format,</span></span></span><br><span class="line"><span class="function"><span class="params">                        image_id, base_image_id)</span>:</span></span><br><span class="line">    <span class="string">"""Creates an RBD snapshot directly.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    fsid = self.driver.get_fsid()</span><br><span class="line">    parent_pool = self._get_parent_pool(context, base_image_id, fsid)</span><br><span class="line">    self.driver.create_snap(self.rbd_name, snapshot_name, protect=<span class="literal">True</span>)</span><br><span class="line">    location = &#123;<span class="string">'url'</span>: <span class="string">'rbd://%(fsid)s/%(pool)s/%(image)s/%(snap)s'</span> %</span><br><span class="line">                        dict(fsid=fsid,</span><br><span class="line">                            pool=self.pool,</span><br><span class="line">                            image=self.rbd_name,</span><br><span class="line">                            snap=snapshot_name)&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.driver.clone(location, image_id, dest_pool=parent_pool)</span><br><span class="line">        self.driver.flatten(image_id, pool=parent_pool)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.cleanup_direct_snapshot(location)</span><br><span class="line">    self.driver.create_snap(image_id, <span class="string">'snap'</span>, pool=parent_pool,</span><br><span class="line">                            protect=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">'rbd://%(fsid)s/%(pool)s/%(image)s/snap'</span> %</span><br><span class="line">            dict(fsid=fsid, pool=parent_pool, image=image_id))</span><br></pre></td></tr></table></figure><p>这个函数本质上还是一层封装，最终调用<code>rbd</code>驱动提供的<code>clone</code>、<code>create_snap</code>、<code>flatten</code>方法返回一个location给glance。</p><p>总结一下，nova创建快照功能是交给底层对应的驱动来处理的，然后调用glance接口创建一条数据最后更新location字段即可。这里多说一句，如果镜像文件特别大的时候使用glance进行同步特别慢，可以参考这里的思路进行优化，使用ceph提供的功能复制后新增glance中的数据即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章记录nova创建快照时候的过程，根据&lt;a href=&quot;https://docs.openstack.org/api-ref/compute/?expanded=create-image-createimage-action-detail#create-image-createimage-action&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt;，创建快照其实是向&lt;code&gt;/servers/{server_id}/action&lt;/code&gt;发送了一个POST的请求，内容则是类似:&lt;/p&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &quot;createImage&quot; : &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;name&quot; : &quot;image-name&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;metadata&quot;: &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Nova" scheme="http://www.hi-roy.com/source/all-tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>如何更好的Code Review</title>
    <link href="http://www.hi-roy.com/2019/12/03/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84code-review/"/>
    <id>http://www.hi-roy.com/2019/12/03/如何更好的code-review/</id>
    <published>2019-12-03T03:05:03.000Z</published>
    <updated>2019-12-03T06:52:06.056Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://levelup.gitconnected.com/how-to-do-good-code-reviews-ee481f73b11b" target="_blank" rel="noopener">原文</a>，向原作者表示感谢。不过不知道作者是不是在国内学过作文，让我想起了小学时老师教的作文要多引用名人名言哈哈。</p><hr><p>几年前当我还是个菜鸟的时候，我过得十分潇洒。</p><p>写代码——交给别人review——改代码，绳命是多磨美好！工作内容就是仔细阅读我收到的评论、建议，学着成为一个更优秀的开发者。如今我成长为了一名高级开发人员，给别人做code review成为了我的职责之一，这时我意识到我的经验还不足以完成这种职责转变。</p><p>每次给别人做code review时我都感觉到害怕，感觉自己像是一个骗子，很多问题都困扰着我：</p><p><em>我该给这行代码提建议吗？</em></p><p><em>应该有更好的办法写这段代码，我应该告诉他吗？</em></p><p><em>他会怎么想？他的经验比我丰富。</em></p><p><em>改了这一行代码会不会使程序崩溃？</em></p><p>这时我的导师给了我建议。</p><p>好的code review聚焦于获得额外的产出，而非仅仅是找到bug。别把review当做是审讯，而当做是一种提高代码质量、发现其他方案、增加学习能力以及加强友谊的办法。</p><p>作为reviewer，你对代码的反馈是将渴望贡献的开发者组建成社区的一种主要方法。通过培养一个活跃的社区，你将提升产品、团队、和人生的质量。</p><p>这里有一些做好code review的建议。</p><a id="more"></a><h2 id="设置目标以及测量指标"><a href="#设置目标以及测量指标" class="headerlink" title="设置目标以及测量指标"></a>设置目标以及测量指标</h2><p>Scott M. Graffiu说过：</p><blockquote><p>如果你不收集任何指标，你是在瞎搞。如果你收集的指标过多，则会干扰你的视野。(If you don’t collect any metrics, you’re flying blind. If you collect and focus on too many, they may be obstructing your field of view)</p></blockquote><p>取得平衡的关键在于你如何收集指标，太多的指标是在浪费时间，没有指标则是在一艘没有舵的船上航行。当开始之前，你的团队应该决定如何衡量code review的效果并列举一些具体的目标。一般来说，好的代码应该：</p><p>首先是完成功能——像预期那样工作。</p><p>其次是整洁可维护——可读性很重要。</p><p>最后是优化——像在生产环境那样运行。</p><p>定义的指标应该在review前后进行测量和追踪，比如“减少客服15%的工作量”，或者“减少开发期间50%的错误率”。</p><p>记住，目标应该是你提高代码质量的测量图。“修bug”并不是一个具体的目标，不会产生任何价值。正如Albert Einstein说的:</p><blockquote><p>只有测量才能带来管控。(What gets measured will only get managed.)</p></blockquote><h2 id="对事不对人"><a href="#对事不对人" class="headerlink" title="对事不对人"></a>对事不对人</h2><p>Frank A. Clark说:</p><blockquote><p>批评就像是雨，应该温和的促使人成长而不是摧毁他。(Criticism, like rain, should be gentle enough to nourish a man’s growth without destroying his roots)</p></blockquote><p>为啥有时候code review会跑偏变成批评大会？</p><p>这种情况往往发生于我们停止讨论这个主意的优劣而开始讨论想出这个主意的人的时候。我们总是很容易的说出:“某某，你个傻B，为啥不用并发”，但我们需要的是更优雅、中立、成熟的说：“我很好奇这段代码，如果使用并发实现会怎样？”</p><p>这2种说法区别是很明显的，第一种你是在羞辱他并且激怒他进行反击。第二种你仅仅是在说代码，没有评论或者指责，只是朴素的讨论。</p><p>记住，谦虚和礼貌的和人交流是十分有意义的，确保你们聚焦于主意的优劣而非消耗在其他无关问题上。</p><p><strong>保持专业，别情绪化。</strong></p><h2 id="不懂就问"><a href="#不懂就问" class="headerlink" title="不懂就问"></a>不懂就问</h2><p>Kubra Sait说：</p><blockquote><p>提问是改变的第一步。(Asking questions is the first way to begin change)</p></blockquote><p>如果你对项目没有足够的熟悉，你不可能做好code review，奏是这么简单。</p><p>不管别人怎么样，你需要去观察你能想得到的任何相关的事。这要求你看的更深，问各种问题，确保你理解每一步。</p><p>你就好像一个医生，要问各种问题——患者的习惯、吃了什么东西，压力如何，吃过什么药等等，这样才能提高疗效。人体是一个十分复杂的系统，除非医生十分执着，否则他不会找到引发问题的根本原因。</p><p>code review和上面原理类似，Nigel Munoz建议reviewer思考“这个改变将导致大或小什么样的情况”。大的包括发现任何重复的代码，非模块化，或者没遵守约定俗成的一些惯例——以及分析对代码架构的修改。</p><h2 id="不要填鸭式教育"><a href="#不要填鸭式教育" class="headerlink" title="不要填鸭式教育"></a>不要填鸭式教育</h2><p>Maimonides说过:</p><blockquote><p>授人以鱼不如授人以渔。(Give a man a fish and you feed him for a day; teach a man to fish and you feed him for a lifetime)</p></blockquote><p>当你做code review时你在扮演的是一名指导者，好的指导者从来不进行填鸭式教育。</p><p>你要做的是引导他们解决问题并且激励他们。相像自己是寻宝游戏中的NPC，你给玩家指出线索，指明正确的路线，而最终由他们自己去解决问题。这样做有很多优点：</p><ol><li>code review成为学习和分享的机会。</li><li>开发人员对代码有完整的所有权而不是依赖你帮他们解决问题。（Roy注：说白了就是控制自己改别人代码的冲动。）</li><li>你将创造和培养下一任高级开发人员。</li></ol><p>一旦团队采纳了这种学习态度，你很快就会发现团队的智力资本在不断上升。这也健康的使用了开发人员的自我驱动力。<strong>“自我成就感”天然的促使开发人员写出更整洁的代码，因为这给他们展示自己能力的机会</strong>。</p><h2 id="控制时长"><a href="#控制时长" class="headerlink" title="控制时长"></a>控制时长</h2><p>Garry Kasparov说过:</p><blockquote><p>能努力工作几天还保持专注是一种天赋，能长久学习后还不断吸收新知识也是一种天赋。(The ability to work hard for days on end without losing focus is a talent. The ability to keep absorbing new information after many hours of study is a talent)</p></blockquote><p>别把code review当做苦差事，如果你发现自己吸收知识的能力每时每刻都在下降，那么你需要停下来活动一下清空脑子。做review时不要超过60分钟，超过这个时间效率和关注细节的能力都会下降，最好是在短时间内进行review。</p><p>不要一次性review很多行代码，你不太可能会发现缺陷，保持每次review的代码在400行以内，设定一个行数限制和设置时间限制一样重要。这确保你在review时保持最佳状态。</p><p>经常做code review不仅仅能提高代码质量，还让你有时间去想每个问题的最佳解决方案去替换脑子中最先想到的方案。</p><p>最后，让code review变成一件积极的事，事实上bug在进入生产环境之前就被发现总比造成客户抱怨好得多。谁如何导致了bug并不重要，重要的是你和团队在创造更优秀产品中的作用。</p><p>培养这种积极的想法，使code review成为一种集体协作行为，这有助于团队感激(而不是害怕)code review。</p><p>正如Hellen Keller所说:</p><blockquote><p>人多力量大。(Alone we can do so little; together we can do so much)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://levelup.gitconnected.com/how-to-do-good-code-reviews-ee481f73b11b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;，向原作者表示感谢。不过不知道作者是不是在国内学过作文，让我想起了小学时老师教的作文要多引用名人名言哈哈。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;几年前当我还是个菜鸟的时候，我过得十分潇洒。&lt;/p&gt;&lt;p&gt;写代码——交给别人review——改代码，绳命是多磨美好！工作内容就是仔细阅读我收到的评论、建议，学着成为一个更优秀的开发者。如今我成长为了一名高级开发人员，给别人做code review成为了我的职责之一，这时我意识到我的经验还不足以完成这种职责转变。&lt;/p&gt;&lt;p&gt;每次给别人做code review时我都感觉到害怕，感觉自己像是一个骗子，很多问题都困扰着我：&lt;/p&gt;&lt;p&gt;&lt;em&gt;我该给这行代码提建议吗？&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;应该有更好的办法写这段代码，我应该告诉他吗？&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;他会怎么想？他的经验比我丰富。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;改了这一行代码会不会使程序崩溃？&lt;/em&gt;&lt;/p&gt;&lt;p&gt;这时我的导师给了我建议。&lt;/p&gt;&lt;p&gt;好的code review聚焦于获得额外的产出，而非仅仅是找到bug。别把review当做是审讯，而当做是一种提高代码质量、发现其他方案、增加学习能力以及加强友谊的办法。&lt;/p&gt;&lt;p&gt;作为reviewer，你对代码的反馈是将渴望贡献的开发者组建成社区的一种主要方法。通过培养一个活跃的社区，你将提升产品、团队、和人生的质量。&lt;/p&gt;&lt;p&gt;这里有一些做好code review的建议。&lt;/p&gt;
    
    </summary>
    
      <category term="菜鸟翻译屋" scheme="http://www.hi-roy.com/source/all-categories/%E8%8F%9C%E9%B8%9F%E7%BF%BB%E8%AF%91%E5%B1%8B/"/>
    
    
      <category term="code review" scheme="http://www.hi-roy.com/source/all-tags/code-review/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://www.hi-roy.com/2019/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/11/28/设计模式-适配器模式/</id>
    <published>2019-11-28T08:58:08.000Z</published>
    <updated>2019-12-12T03:24:03.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h2><p>适配器模式目的就是不改变原有系统的基础上保留其提供的服务，向调用者提供新的接口服务，使得原本由于接口不兼容而不能一起工作的类可以一起工作。（简单说就是增加兼容性，复用已经存在的功能）</p><p>笔记本电脑的电源变压器就是这个原理，把交流电转换成直流电。或者把英文翻译成中文，都是适配器模式。</p><p>又分为2种：</p><ol><li>对象适配器模式</li><li>类适配器模式</li></ol><p>适配器虽好，但也不要乱用，如果能在设计阶段就统一就是最好的，适配器模式更像是一种补丁。</p><a id="more"></a><p><img src="/assets/images/design-pattern/adapter.png" alt="adapter.png"></p><p>推荐使用基于组合的对象适配器模式，因为类适配器模式使用了继承增加了模块之间的耦合度，下面的例子就是对象适配器模式。</p><p>假设现在有2种电压：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> power220 <span class="keyword">struct</span> &#123;</span><br><span class="line">power <span class="keyword">int</span></span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p power220)</span> <span class="title">output220</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"This is %s! power is %d\n"</span>, p.name, p.power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> power12 <span class="keyword">struct</span> &#123;</span><br><span class="line">power <span class="keyword">int</span></span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p power12)</span> <span class="title">output12</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"This is %s! power is %d\n"</span>, p.name, p.power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p220 := power220&#123;power: <span class="number">220</span>, name: <span class="string">"power220"</span>&#125;</span><br><span class="line">p220.output220()</span><br><span class="line"></span><br><span class="line">p12 := power12&#123;power: <span class="number">12</span>, name: <span class="string">"power12"</span>&#125;</span><br><span class="line">p12.output12()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is power220! power is 220</span><br><span class="line">This is power12! power is 12</span><br></pre></td></tr></table></figure><p>但是实际生活中家庭用电都是220V的，不可能和电厂说”我的电脑需要12V直流电，请给我提供12V直流电服务”，也不可能和笔记本电脑制造商说制造一台适配220V交流电的电脑给你，这种情况就类似上面说的”双方不兼容所以不能直接一起工作，而且没法修改任何一方”。此时适配器就该出厂了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> adapter12 <span class="keyword">struct</span> &#123;</span><br><span class="line">power220 power220</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a adapter12)</span> <span class="title">output12</span><span class="params">()</span></span> &#123;</span><br><span class="line">a.power220.output220()</span><br><span class="line">fmt.Printf(<span class="string">"This is adapter12,i will transfer %d to 12"</span>, a.power220.power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p220 := power220&#123;power: <span class="number">220</span>, name: <span class="string">"power220"</span>&#125;</span><br><span class="line">a := adapter12&#123;power220: p220&#125;</span><br><span class="line">a.output12()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is power220! power is 220</span><br><span class="line">This is adapter12,i will transfer 220 to 12</span><br></pre></td></tr></table></figure><p>适配器模式还是比较好理解的一种设计模式。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>软件系统结构需要升级或者扩展，又不想影响原有系统的稳定运行时。</li><li>转换类之间的差别不是太大的时候。(把电源转换成砖头就很难)</li><li>创建一个可以复用的类，该类可以与其他不相干的类或者不可预见的类协同工作时。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>和装饰器模式比，适配器模式主要是弥补接口之间的差异，而装饰器模式则是添加新功能。</li><li>和桥接模式比，桥接模式更注重连接功能部分和实现部分的设计，把实现和接口分开，以便独立的变化。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;适配器模式-Adapter-Pattern&quot;&gt;&lt;a href=&quot;#适配器模式-Adapter-Pattern&quot; class=&quot;headerlink&quot; title=&quot;适配器模式(Adapter Pattern)&quot;&gt;&lt;/a&gt;适配器模式(Adapter Pattern)&lt;/h2&gt;&lt;p&gt;适配器模式目的就是不改变原有系统的基础上保留其提供的服务，向调用者提供新的接口服务，使得原本由于接口不兼容而不能一起工作的类可以一起工作。（简单说就是增加兼容性，复用已经存在的功能）&lt;/p&gt;&lt;p&gt;笔记本电脑的电源变压器就是这个原理，把交流电转换成直流电。或者把英文翻译成中文，都是适配器模式。&lt;/p&gt;&lt;p&gt;又分为2种：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;对象适配器模式&lt;/li&gt;&lt;li&gt;类适配器模式&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;适配器虽好，但也不要乱用，如果能在设计阶段就统一就是最好的，适配器模式更像是一种补丁。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码学习笔记3</title>
    <link href="http://www.hi-roy.com/2019/11/04/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://www.hi-roy.com/2019/11/04/OpenStack源码学习笔记3/</id>
    <published>2019-11-04T04:46:29.000Z</published>
    <updated>2020-04-02T03:39:13.759Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下关于OpenStack如何统计更新CPU、内存、硬盘等硬件资源的部分，由于历史原因下面的代码来自<code>newton</code>版。</p><p>简单说，OpenStack先通过定时任务进行资源统计，入口代码位于<code>nova\compute\manager.py</code>中<code>ComputeManager</code>类的<code>update_available_resource</code>函数。默认情况下每分钟更新一次：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@periodic_task.periodic_task(spacing=CONF.update_resources_interval)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_available_resource</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    <span class="string">"""See driver.get_available_resource()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Periodic process that keeps that the compute host's understanding of</span></span><br><span class="line"><span class="string">    resource availability and usage in sync with the underlying hypervisor.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param context: security context</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    compute_nodes_in_db = self._get_compute_nodes_in_db(context,</span><br><span class="line">                                                        use_slave=<span class="literal">True</span>)</span><br><span class="line">    nodenames = set(self.driver.get_available_nodes())</span><br><span class="line">    <span class="keyword">for</span> nodename <span class="keyword">in</span> nodenames:</span><br><span class="line">        self.update_available_resource_for_node(context, nodename)</span><br><span class="line"></span><br><span class="line">    self._resource_tracker_dict = &#123;</span><br><span class="line">        k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> self._resource_tracker_dict.items()</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> nodenames&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delete orphan compute node not reported by driver but still in db</span></span><br><span class="line">    <span class="keyword">for</span> cn <span class="keyword">in</span> compute_nodes_in_db:</span><br><span class="line">        <span class="keyword">if</span> cn.hypervisor_hostname <span class="keyword">not</span> <span class="keyword">in</span> nodenames:</span><br><span class="line">            LOG.info(_LI(<span class="string">"Deleting orphan compute node %s"</span>), cn.id)</span><br><span class="line">            cn.destroy()</span><br></pre></td></tr></table></figure><p>首先获取所有节点，然后维护了一个名为<code>_resource_tracker_dict</code>的字典用来记录host和<code>ResourceTracker</code>实例的对应关系，所有的资源更新行为都在<code>ResourceTracker</code>中进行处理。</p><a id="more"></a><p>在字典中找到对应的<code>ResourceTracker</code>实例后调用其<code>update_available_resource</code>函数，位于<code>nova\compute\resource_tracker.py</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_available_resource</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    <span class="string">"""Override in-memory calculations of compute node resource usage based</span></span><br><span class="line"><span class="string">    on data audited from the hypervisor layer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Add in resource claims in progress to account for operations that have</span></span><br><span class="line"><span class="string">    declared a need for resources, but not necessarily retrieved them from</span></span><br><span class="line"><span class="string">    the hypervisor layer yet.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    LOG.info(_LI(<span class="string">"Auditing locally available compute resources for "</span></span><br><span class="line">                    <span class="string">"node %(node)s"</span>),</span><br><span class="line">                &#123;<span class="string">'node'</span>: self.nodename&#125;)</span><br><span class="line">    resources = self.driver.get_available_resource(self.nodename)</span><br><span class="line">    resources[<span class="string">'host_ip'</span>] = CONF.my_ip</span><br><span class="line">    <span class="comment"># We want the 'cpu_info' to be None from the POV of the</span></span><br><span class="line">    <span class="comment"># virt driver, but the DB requires it to be non-null so</span></span><br><span class="line">    <span class="comment"># just force it to empty string</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"cpu_info"</span> <span class="keyword">not</span> <span class="keyword">in</span> resources <span class="keyword">or</span> resources[<span class="string">"cpu_info"</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        resources[<span class="string">"cpu_info"</span>] = <span class="string">''</span></span><br><span class="line">    self._verify_resources(resources)</span><br><span class="line">    self._report_hypervisor_resource_view(resources)</span><br><span class="line">    self._update_available_resource(context, resources)</span><br></pre></td></tr></table></figure><p>使用不同的dirver获取资源的方法不一样，以使用libvirt为例，相关代码位于<code>nova\virt\libvirt\driver.py</code>中的<code>get_available_resource</code>函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_available_resource</span><span class="params">(self, nodename)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    data[<span class="string">"memory_mb"</span>] = self._host.get_memory_mb_total()</span><br><span class="line">    data[<span class="string">"memory_mb_used"</span>] = self._host.get_memory_mb_used()</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>这里我以获取内存为例，获取内存信息分为2步，首先调用<code>libvirt</code>库获取总内存，代码位于<code>nova\virt\libvirt\host.py</code>，这里我直接给出相关验证代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line">conn = libvirt.open(<span class="string">"qemu:///system"</span>)</span><br><span class="line">c = conn.getInfo()[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这段代码就是<code>get_memory_mb_total()</code>的底层实现。测试的话注意使用root用户否则会报权限错误。</p><p>获取使用内存代码如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_memory_mb_used</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Get the used memory size(MB) of physical computer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :returns: the total usage of memory(MB).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> sys.platform.upper() <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'LINUX2'</span>, <span class="string">'LINUX3'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/proc/meminfo'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        m = fp.read().split()</span><br><span class="line">    idx1 = m.index(<span class="string">'MemFree:'</span>)</span><br><span class="line">    idx2 = m.index(<span class="string">'Buffers:'</span>)</span><br><span class="line">    idx3 = m.index(<span class="string">'Cached:'</span>)</span><br><span class="line">    <span class="keyword">if</span> CONF.libvirt.virt_type == <span class="string">'xen'</span>:</span><br><span class="line">        used = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> guest <span class="keyword">in</span> self.list_guests(only_guests=<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># TODO(sahid): Use get_info...</span></span><br><span class="line">                dom_mem = int(guest._get_domain_info(self)[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">                LOG.warning(_LW(<span class="string">"couldn't obtain the memory from domain:"</span></span><br><span class="line">                                <span class="string">" %(uuid)s, exception: %(ex)s"</span>),</span><br><span class="line">                            &#123;<span class="string">"uuid"</span>: guest.uuid, <span class="string">"ex"</span>: e&#125;)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># skip dom0</span></span><br><span class="line">            <span class="keyword">if</span> guest.id != <span class="number">0</span>:</span><br><span class="line">                used += dom_mem</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># the mem reported by dom0 is be greater of what</span></span><br><span class="line">                <span class="comment"># it is being used</span></span><br><span class="line">                used += (dom_mem -</span><br><span class="line">                            (int(m[idx1 + <span class="number">1</span>]) +</span><br><span class="line">                            int(m[idx2 + <span class="number">1</span>]) +</span><br><span class="line">                            int(m[idx3 + <span class="number">1</span>])))</span><br><span class="line">        <span class="comment"># Convert it to MB</span></span><br><span class="line">        <span class="keyword">return</span> used // units.Ki</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        avail = (int(m[idx1 + <span class="number">1</span>]) + int(m[idx2 + <span class="number">1</span>]) + int(m[idx3 + <span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># Convert it to MB</span></span><br><span class="line">        <span class="keyword">return</span> self.get_memory_mb_total() - avail // units.Ki</span><br></pre></td></tr></table></figure><p>可以看出其实是读取的<code>/proc/meminfo</code>。</p><p>然后更新行为位于<code>_update_available_resource</code>函数中：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@utils.synchronized(COMPUTE_RESOURCE_SEMAPHORE)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_update_available_resource</span><span class="params">(self, context, resources)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize the compute node object, creating it</span></span><br><span class="line">    <span class="comment"># if it does not already exist.</span></span><br><span class="line">    self._init_compute_node(context, resources)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if we could not init the compute node the tracker will be</span></span><br><span class="line">    <span class="comment"># disabled and we should quit now</span></span><br><span class="line">    <span class="keyword">if</span> self.disabled:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Grab all instances assigned to this node:</span></span><br><span class="line">    instances = objects.InstanceList.get_by_host_and_node(</span><br><span class="line">        context, self.host, self.nodename,</span><br><span class="line">        expected_attrs=[<span class="string">'system_metadata'</span>,</span><br><span class="line">                        <span class="string">'numa_topology'</span>,</span><br><span class="line">                        <span class="string">'flavor'</span>, <span class="string">'migration_context'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now calculate usage based on instance utilization:</span></span><br><span class="line">    self._update_usage_from_instances(context, instances)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Grab all in-progress migrations:</span></span><br><span class="line">    migrations = objects.MigrationList.get_in_progress_by_host_and_node(</span><br><span class="line">            context, self.host, self.nodename)</span><br><span class="line"></span><br><span class="line">    self._pair_instances_to_migrations(migrations, instances)</span><br><span class="line">    self._update_usage_from_migrations(context, migrations)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Detect and account for orphaned instances that may exist on the</span></span><br><span class="line">    <span class="comment"># hypervisor, but are not in the DB:</span></span><br><span class="line">    orphans = self._find_orphaned_instances()</span><br><span class="line">    self._update_usage_from_orphans(orphans)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NOTE(yjiang5): Because pci device tracker status is not cleared in</span></span><br><span class="line">    <span class="comment"># this periodic task, and also because the resource tracker is not</span></span><br><span class="line">    <span class="comment"># notified when instances are deleted, we need remove all usages</span></span><br><span class="line">    <span class="comment"># from deleted instances.</span></span><br><span class="line">    self.pci_tracker.clean_usage(instances, migrations, orphans)</span><br><span class="line">    dev_pools_obj = self.pci_tracker.stats.to_device_pools_obj()</span><br><span class="line">    self.compute_node.pci_device_pools = dev_pools_obj</span><br><span class="line"></span><br><span class="line">    self._report_final_resource_view()</span><br><span class="line"></span><br><span class="line">    metrics = self._get_host_metrics(context, self.nodename)</span><br><span class="line">    <span class="comment"># TODO(pmurray): metrics should not be a json string in ComputeNode,</span></span><br><span class="line">    <span class="comment"># but it is. This should be changed in ComputeNode</span></span><br><span class="line">    self.compute_node.metrics = jsonutils.dumps(metrics)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update the compute_node</span></span><br><span class="line">    self._update(context)</span><br><span class="line">    LOG.info(_LI(<span class="string">'Compute_service record updated for %(host)s:%(node)s'</span>),</span><br><span class="line">                    &#123;<span class="string">'host'</span>: self.host, <span class="string">'node'</span>: self.nodename&#125;)</span><br></pre></td></tr></table></figure><p>首先调用<code>_init_compute_node()</code>函数初始化，这里首先从数据库中读取数据，然后用刚刚获取到的最新数据进行覆盖，再进行下面的计算。</p><p>这里可以分为3类，一种是运行中的实例，一种是迁移中的实例，一种是孤儿实例（这个目前我还没见到过）。这里以第一种为例，跟进<code>_update_usage_from_instances</code>函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_update_usage_from_instances</span><span class="params">(self, context, instances)</span>:</span></span><br><span class="line">    <span class="string">"""Calculate resource usage based on instance utilization.  This is</span></span><br><span class="line"><span class="string">    different than the hypervisor's view as it will account for all</span></span><br><span class="line"><span class="string">    instances assigned to the local compute host, even if they are not</span></span><br><span class="line"><span class="string">    currently powered on.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.tracked_instances.clear()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set some initial values, reserve room for host/hypervisor:</span></span><br><span class="line">    self.compute_node.local_gb_used = CONF.reserved_host_disk_mb / <span class="number">1024</span></span><br><span class="line">    self.compute_node.memory_mb_used = CONF.reserved_host_memory_mb</span><br><span class="line">    self.compute_node.vcpus_used = <span class="number">0</span></span><br><span class="line">    self.compute_node.free_ram_mb = (self.compute_node.memory_mb -</span><br><span class="line">                                        self.compute_node.memory_mb_used)</span><br><span class="line">    self.compute_node.free_disk_gb = (self.compute_node.local_gb -</span><br><span class="line">                                        self.compute_node.local_gb_used)</span><br><span class="line">    self.compute_node.current_workload = <span class="number">0</span></span><br><span class="line">    self.compute_node.running_vms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> instance <span class="keyword">in</span> instances:</span><br><span class="line">        <span class="keyword">if</span> instance.vm_state <span class="keyword">not</span> <span class="keyword">in</span> vm_states.ALLOW_RESOURCE_REMOVAL:</span><br><span class="line">            self._update_usage_from_instance(context, instance)</span><br><span class="line"></span><br><span class="line">    self.scheduler_client.reportclient.remove_deleted_instances(</span><br><span class="line">            self.compute_node, self.tracked_instances.values())</span><br></pre></td></tr></table></figure><p>这里有个小细节，关于内存只是使用了调用<code>libvirt</code>获取到的总内存，至于使用内存都是每次重新计算的。</p><p>首先减去配置文件中设定的保留内存和保留硬盘，如果状态不是’deleted’或者’shelved_offloaded’开始对实例进行循环计算：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_update_usage_from_instance</span><span class="params">(self, context, instance, is_removed=False)</span>:</span></span><br><span class="line">    <span class="string">"""Update usage for a single instance."""</span></span><br><span class="line">    uuid = instance[<span class="string">'uuid'</span>]</span><br><span class="line">    is_new_instance = uuid <span class="keyword">not</span> <span class="keyword">in</span> self.tracked_instances</span><br><span class="line">    <span class="comment"># NOTE(sfinucan): Both brand new instances as well as instances that</span></span><br><span class="line">    <span class="comment"># are being unshelved will have is_new_instance == True</span></span><br><span class="line">    is_removed_instance = <span class="keyword">not</span> is_new_instance <span class="keyword">and</span> (is_removed <span class="keyword">or</span></span><br><span class="line">        instance[<span class="string">'vm_state'</span>] <span class="keyword">in</span> vm_states.ALLOW_RESOURCE_REMOVAL)</span><br><span class="line">    <span class="keyword">if</span> is_new_instance:</span><br><span class="line">        self.tracked_instances[uuid] = obj_base.obj_to_primitive(instance)</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> is_removed_instance:</span><br><span class="line">        self.tracked_instances.pop(uuid)</span><br><span class="line">        sign = <span class="number">-1</span></span><br><span class="line">    self.stats.update_stats_for_instance(instance, is_removed_instance)</span><br><span class="line">    self.compute_node.stats = copy.deepcopy(self.stats)</span><br><span class="line">    <span class="comment"># if it's a new or deleted instance:</span></span><br><span class="line">    <span class="keyword">if</span> is_new_instance <span class="keyword">or</span> is_removed_instance:</span><br><span class="line">        <span class="keyword">if</span> self.pci_tracker:</span><br><span class="line">            self.pci_tracker.update_pci_for_instance(context,</span><br><span class="line">                                                        instance,</span><br><span class="line">                                                        sign=sign)</span><br><span class="line">        self.scheduler_client.reportclient.update_instance_allocation(</span><br><span class="line">            self.compute_node, instance, sign)</span><br><span class="line">        <span class="comment"># new instance, update compute node resource usage:</span></span><br><span class="line">        self._update_usage(self._get_usage_dict(instance), sign=sign)</span><br><span class="line"></span><br><span class="line">    self.compute_node.current_workload = self.stats.calculate_workload()</span><br><span class="line">    <span class="keyword">if</span> self.pci_tracker:</span><br><span class="line">        obj = self.pci_tracker.stats.to_device_pools_obj()</span><br><span class="line">        self.compute_node.pci_device_pools = obj</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.compute_node.pci_device_pools = objects.PciDevicePoolList()</span><br></pre></td></tr></table></figure><p>由于很多请求都是异步的，所以在函数中又判断了一次主机是否删除，如果删除了的话sign则为负值。</p><p>然后调用<code>_update_usage</code>函数进行最终计算，这里通过<code>sign</code>参数来控制加减：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_update_usage</span><span class="params">(self, usage, sign=<span class="number">1</span>)</span>:</span></span><br><span class="line">    mem_usage = usage[<span class="string">'memory_mb'</span>]</span><br><span class="line">    disk_usage = usage.get(<span class="string">'root_gb'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    overhead = self.driver.estimate_instance_overhead(usage)</span><br><span class="line">    mem_usage += overhead[<span class="string">'memory_mb'</span>]</span><br><span class="line">    disk_usage += overhead.get(<span class="string">'disk_gb'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    self.compute_node.memory_mb_used += sign * mem_usage</span><br><span class="line">    self.compute_node.local_gb_used += sign * disk_usage</span><br><span class="line">    self.compute_node.local_gb_used += sign * usage.get(<span class="string">'ephemeral_gb'</span>, <span class="number">0</span>)</span><br><span class="line">    self.compute_node.vcpus_used += sign * usage.get(<span class="string">'vcpus'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># free ram and disk may be negative, depending on policy:</span></span><br><span class="line">    self.compute_node.free_ram_mb = (self.compute_node.memory_mb -</span><br><span class="line">                                        self.compute_node.memory_mb_used)</span><br><span class="line">    self.compute_node.free_disk_gb = (self.compute_node.local_gb -</span><br><span class="line">                                        self.compute_node.local_gb_used)</span><br><span class="line"></span><br><span class="line">    self.compute_node.running_vms = self.stats.num_instances</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the numa usage</span></span><br><span class="line">    free = sign == <span class="number">-1</span></span><br><span class="line">    updated_numa_topology = hardware.get_host_numa_usage_from_instance(</span><br><span class="line">            self.compute_node, usage, free)</span><br><span class="line">    self.compute_node.numa_topology = updated_numa_topology</span><br></pre></td></tr></table></figure><p>这里的mem_usage其实是创建主机时指定的flavor的值，关于<code>estimate_instance_overhead</code>函数貌似只有xen和hyperv驱动才有实际用途，对于libvirt返回的就是0，有兴趣的小伙伴可以深入研究下。</p><p>然后再经过第二步、第三步处理后将结果存入数据库中。</p><p>这里有一点需要注意，如果配置了超分参数，创建迁移主机时并不是直接使用上述计算结果的，而是要乘以配置的超分参数，相关代码位于<code>nova\scheduler\filters\ram_filter.py</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">host_passes</span><span class="params">(self, host_state, spec_obj)</span>:</span></span><br><span class="line">    <span class="string">"""Only return hosts with sufficient available RAM."""</span></span><br><span class="line">    requested_ram = spec_obj.memory_mb</span><br><span class="line">    free_ram_mb = host_state.free_ram_mb</span><br><span class="line">    total_usable_ram_mb = host_state.total_usable_ram_mb</span><br><span class="line">    <span class="comment"># Do not allow an instance to overcommit against itself, only against</span></span><br><span class="line">    <span class="comment"># other instances.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> total_usable_ram_mb &gt;= requested_ram:</span><br><span class="line">        LOG.debug(<span class="string">"%(host_state)s does not have %(requested_ram)s MB "</span></span><br><span class="line">                    <span class="string">"usable ram before overcommit, it only has "</span></span><br><span class="line">                    <span class="string">"%(usable_ram)s MB."</span>,</span><br><span class="line">                    &#123;<span class="string">'host_state'</span>: host_state,</span><br><span class="line">                    <span class="string">'requested_ram'</span>: requested_ram,</span><br><span class="line">                    <span class="string">'usable_ram'</span>: total_usable_ram_mb&#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    ram_allocation_ratio = self._get_ram_allocation_ratio(host_state,</span><br><span class="line">                                                            spec_obj)</span><br><span class="line">    memory_mb_limit = total_usable_ram_mb * ram_allocation_ratio</span><br><span class="line">    used_ram_mb = total_usable_ram_mb - free_ram_mb</span><br><span class="line">    usable_ram = memory_mb_limit - used_ram_mb</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> usable_ram &gt;= requested_ram:</span><br><span class="line">        LOG.debug(<span class="string">"%(host_state)s does not have %(requested_ram)s MB "</span></span><br><span class="line">                <span class="string">"usable ram, it only has %(usable_ram)s MB usable ram."</span>,</span><br><span class="line">                &#123;<span class="string">'host_state'</span>: host_state,</span><br><span class="line">                    <span class="string">'requested_ram'</span>: requested_ram,</span><br><span class="line">                    <span class="string">'usable_ram'</span>: usable_ram&#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># save oversubscription limit for compute node to test against:</span></span><br><span class="line">    host_state.limits[<span class="string">'memory_mb'</span>] = memory_mb_limit</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这也是为什么有时候看<code>free_ram_mb</code>、<code>free_disk_gb</code>为负的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下关于OpenStack如何统计更新CPU、内存、硬盘等硬件资源的部分，由于历史原因下面的代码来自&lt;code&gt;newton&lt;/code&gt;版。&lt;/p&gt;&lt;p&gt;简单说，OpenStack先通过定时任务进行资源统计，入口代码位于&lt;code&gt;nova\compute\manager.py&lt;/code&gt;中&lt;code&gt;ComputeManager&lt;/code&gt;类的&lt;code&gt;update_available_resource&lt;/code&gt;函数。默认情况下每分钟更新一次：&lt;/p&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@periodic_task.periodic_task(spacing=CONF.update_resources_interval)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;update_available_resource&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, context)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;See driver.get_available_resource()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    Periodic process that keeps that the compute host&#39;s understanding of&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    resource availability and usage in sync with the underlying hypervisor.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    :param context: security context&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compute_nodes_in_db = self._get_compute_nodes_in_db(context,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                        use_slave=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nodenames = set(self.driver.get_available_nodes())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; nodename &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nodenames:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.update_available_resource_for_node(context, nodename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self._resource_tracker_dict = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        k: v &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; self._resource_tracker_dict.items()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nodenames&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Delete orphan compute node not reported by driver but still in db&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; cn &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; compute_nodes_in_db:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cn.hypervisor_hostname &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nodenames:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            LOG.info(_LI(&lt;span class=&quot;string&quot;&gt;&quot;Deleting orphan compute node %s&quot;&lt;/span&gt;), cn.id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cn.destroy()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;首先获取所有节点，然后维护了一个名为&lt;code&gt;_resource_tracker_dict&lt;/code&gt;的字典用来记录host和&lt;code&gt;ResourceTracker&lt;/code&gt;实例的对应关系，所有的资源更新行为都在&lt;code&gt;ResourceTracker&lt;/code&gt;中进行处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Nova" scheme="http://www.hi-roy.com/source/all-tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://www.hi-roy.com/2019/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/10/28/设计模式-单例模式/</id>
    <published>2019-10-28T08:58:08.000Z</published>
    <updated>2019-10-28T09:58:31.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h2><p>单例模式可以说是最容易理解的一种设计模式了，当需要某个类仅有一个全局唯一对象时可以使用，比如某些配置项。核心思想就是新建某个类实例时先进行一次判断，如果不存在则创建新实例返回，否则返回已经存在的实例。</p><a id="more"></a><h3 id="懒汉模式-Lazy-Loading"><a href="#懒汉模式-Lazy-Loading" class="headerlink" title="懒汉模式(Lazy Loading)"></a>懒汉模式(Lazy Loading)</h3><p>很常见的一种方式，不过并非是线程安全的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带单锁的单例模式"><a href="#带单锁的单例模式" class="headerlink" title="带单锁的单例模式"></a>带单锁的单例模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决线程安全问题，很容易想到的就是加锁。这种方式有个缺点就是每次获取实例时候都要对锁进行操作，会降低性能。</p><h3 id="双重锁定"><a href="#双重锁定" class="headerlink" title="双重锁定"></a>双重锁定</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialized <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;initialized) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;singleton&#123;&#125;</span><br><span class="line">atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>atomic</code>来保证原子操作。不过代码还可以更精简，使用golang中的<a href="https://godoc.org/sync#Once" target="_blank" rel="noopener">Once</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式-Singleton-Pattern&quot;&gt;&lt;a href=&quot;#单例模式-Singleton-Pattern&quot; class=&quot;headerlink&quot; title=&quot;单例模式(Singleton Pattern)&quot;&gt;&lt;/a&gt;单例模式(Singleton Pattern)&lt;/h2&gt;&lt;p&gt;单例模式可以说是最容易理解的一种设计模式了，当需要某个类仅有一个全局唯一对象时可以使用，比如某些配置项。核心思想就是新建某个类实例时先进行一次判断，如果不存在则创建新实例返回，否则返回已经存在的实例。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="http://www.hi-roy.com/2019/10/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/10/14/设计模式-原型模式/</id>
    <published>2019-10-14T09:58:08.000Z</published>
    <updated>2019-12-23T08:29:13.215Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式(Prototype Pattern)：使用原型实例创建指定创建对象的种类，并通过拷贝这些原型创建新对象。这个模式很好理解，就是<code>ctrl+c，ctrl+v</code>后做一些小修改。</p><p>这里面涉及一个知识点就是深拷贝和浅拷贝的问题，但我相信任何python开发人员都知道<code>copy()</code>和<code>deepcopy()</code>的区别，这里就不多说了（有兴趣的可以去看python中这2个函数的实现）。</p><p>个人理解当需要多个类对象时，如果要进行很多复杂的、消耗时间的初始化操作，而这些对象之间又仅有少量不同时，可以考虑使用原型模式。</p><a id="more"></a><p><img src="/assets/images/design-pattern/prototype.png" alt="prototype.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">food []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Cat&#123;name: <span class="string">"tom"</span>, age: <span class="number">3</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a == b) <span class="comment">// true a和b的值相同</span></span><br><span class="line">fmt.Println(&amp;b == &amp;a) <span class="comment">// false  a和b的内存地址不同</span></span><br><span class="line">b.name = <span class="string">"roy"</span></span><br><span class="line">fmt.Printf(<span class="string">"a:%v \nb:%v \n"</span>,a,b)</span><br><span class="line">fmt.Println(a == b) <span class="comment">// false a和b的值不同</span></span><br><span class="line"></span><br><span class="line">c := Dog&#123;name: <span class="string">"cola"</span>,age:<span class="number">1</span>,food:[]<span class="keyword">string</span>&#123;<span class="string">"beef"</span>,<span class="string">"chicken"</span>&#125;&#125;</span><br><span class="line">d := c</span><br><span class="line">d.food[<span class="number">0</span>] = <span class="string">"poke"</span> <span class="comment">// 修改d的food会影响到c</span></span><br><span class="line">fmt.Printf(<span class="string">"struct c.food:%p\nstruct d.food:%p\n"</span>,&amp;c.food,&amp;d.food)</span><br><span class="line">fmt.Printf(<span class="string">"struct c.food[0]:%p\nstruct d.food[0]:%p\n"</span>,&amp;c.food[<span class="number">0</span>],&amp;d.food[<span class="number">0</span>]) <span class="comment">// 从这里可以看出最终内存地址是一样的</span></span><br><span class="line"></span><br><span class="line">e := c</span><br><span class="line">e.food = <span class="built_in">append</span>(e.food,<span class="string">"poke"</span>) <span class="comment">// append方法返回了一个新对象</span></span><br><span class="line">fmt.Printf(<span class="string">"struct e.food:%p\n"</span>,&amp;e.food)</span><br><span class="line">fmt.Printf(<span class="string">"struct e.food[0]:%p\n"</span>,&amp;e.food[<span class="number">0</span>]) <span class="comment">// 这里可以看出e的第一个元素已经和c、d不一样了</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"c:%v"</span>,c)</span><br><span class="line">fmt.Printf(<span class="string">"d:%v"</span>,d)</span><br><span class="line">fmt.Printf(<span class="string">"e:%v"</span>,e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cat</code>这个类中不包含引用类型，所以直接将a赋值给b后，对b的修改不会影响a。但是<code>Dog</code>类中包含了引用类型，赋值后修改c、d任何一个的food值都会影响另一个。但是如果通过<code>append()</code>方法则是返回了一个新的slice，修改<code>e.food</code>就不会影响c和d了。</p><p>常见的引用类型：slice，pointers，maps，functions和channels，所以如果结构中包含这些将一个对象赋值给另一个对象时候要小心。</p><p>这里再多说一句关于golang中<code>new</code>，<code>make</code>创建对象的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%p\n"</span>,b,&amp;b)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%p\n"</span>,c,&amp;c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0 0 0],0x40a0f0</span><br><span class="line">&amp;[],0x40c138</span><br></pre></td></tr></table></figure><p>可以看出，<code>new</code>返回的是指针并且没有初始值，而<code>make</code>则返回的是引用而且有默认值。此外，<code>make</code>只能创建<code>slice、map、channel</code>而<code>new</code>可以用于所有类型的内存分配。</p><p>原型模式代码思路如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="built_in">copy</span> <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="built_in">copy</span>() Dog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">food []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">copy</span><span class="params">()</span> <span class="title">Dog</span></span> &#123;</span><br><span class="line">obj := d</span><br><span class="line">food := <span class="built_in">new</span>([]<span class="keyword">string</span>)</span><br><span class="line">bytes, _ := json.Marshal(d.food)</span><br><span class="line">_ = json.Unmarshal(bytes, food)</span><br><span class="line">obj.food = *food</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Dog&#123;name: <span class="string">"tom"</span>, age: <span class="number">3</span>, food: []<span class="keyword">string</span>&#123;<span class="string">"beef"</span>,<span class="string">"poke"</span>&#125;&#125;</span><br><span class="line">b := a.<span class="built_in">copy</span>()</span><br><span class="line">b.food[<span class="number">0</span>] = <span class="string">"chicken"</span></span><br><span class="line">fmt.Printf(<span class="string">"a:%v,%p,%p\n"</span>,a,&amp;a,&amp;a.food[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"b:%v,%p,%p\n"</span>,b,&amp;b,&amp;b.food[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用了<code>json</code>包里的序列化函数来模拟deepcopy仅仅为了演示，生产环境下请使用其他方法实现。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>当产生对象过程比较复杂，初始化需要许多资源时。</li><li>希望框架原型和产生对象分开时。</li><li>同一个对象可能会供其他调用者同时调用时。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型模式(Prototype Pattern)：使用原型实例创建指定创建对象的种类，并通过拷贝这些原型创建新对象。这个模式很好理解，就是&lt;code&gt;ctrl+c，ctrl+v&lt;/code&gt;后做一些小修改。&lt;/p&gt;&lt;p&gt;这里面涉及一个知识点就是深拷贝和浅拷贝的问题，但我相信任何python开发人员都知道&lt;code&gt;copy()&lt;/code&gt;和&lt;code&gt;deepcopy()&lt;/code&gt;的区别，这里就不多说了（有兴趣的可以去看python中这2个函数的实现）。&lt;/p&gt;&lt;p&gt;个人理解当需要多个类对象时，如果要进行很多复杂的、消耗时间的初始化操作，而这些对象之间又仅有少量不同时，可以考虑使用原型模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://www.hi-roy.com/2019/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/10/12/设计模式-建造者模式/</id>
    <published>2019-10-12T08:58:08.000Z</published>
    <updated>2019-12-12T03:24:23.404Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式(Builder Pattern)：将复杂对象的创建和表示分离，使同样的构建过程可以创建不同的表示。</p><p>进一步说，建造者隐藏了产品是如何组装的，使建造代码和表示代码分离。建造对象时 <strong>构件顺序稳定</strong> 的情况下，不管每一步具体怎么变都可以适用。</p><p><img src="/assets/images/design-pattern/builder.png" alt="builder.png"></p><a id="more"></a><p>简单说，建造者模式将需要一系列动作才能完成的事固化下来，并定义了一个Director给客户端使用。还是很抽象的话，想想如何把大象装进冰箱：</p><ol><li>打开冰箱门</li><li>把大象装进去</li><li>关上冰箱门</li></ol><p>这个步骤比较简单，但如果细化一下：买冰箱、接通电源、买大象、清洗大象……很可能就会有300个步骤。建造者模式则提供了一系列行为的集合，保证以后有把山羊装进冰箱这样的需求时候不会遗漏某个步骤（想想KFC、麦当劳生产食品的步骤，其实是建造者模式不错的例子）。</p><p>代码实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把xx装进冰箱</span></span><br><span class="line"><span class="keyword">type</span> inFridge <span class="keyword">interface</span> &#123;</span><br><span class="line">openDoor()</span><br><span class="line">putInFridge()</span><br><span class="line">closeDoor()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> meat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m meat)</span> <span class="title">openDoor</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"Open the Door!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m meat)</span> <span class="title">closeDoor</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"Close the Door!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pig <span class="keyword">struct</span> &#123;</span><br><span class="line">meat</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pig)</span> <span class="title">putInFridge</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Put %s in fridge \n"</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chicken <span class="keyword">struct</span> &#123;</span><br><span class="line">meat</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c chicken)</span> <span class="title">putInFridge</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Kill the %s \n"</span>,c.name)</span><br><span class="line">fmt.Printf(<span class="string">"Put %s in fridge \n"</span>,c.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> director <span class="keyword">struct</span> &#123;</span><br><span class="line">i inFridge</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d director)</span> <span class="title">createMeat</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.i.openDoor()</span><br><span class="line">d.i.putInFridge()</span><br><span class="line">d.i.closeDoor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := pig&#123;meat:meat&#123;name:<span class="string">"pig"</span>&#125;&#125;</span><br><span class="line">c := chicken&#123;meat:meat&#123;name:<span class="string">"chicken"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">d := director&#123;i:p&#125;</span><br><span class="line">d.createMeat()</span><br><span class="line"></span><br><span class="line">d2 := director&#123;i:c&#125;</span><br><span class="line">d2.createMeat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，定义了<code>meat</code>基类和<code>inFridge</code>接口，并在<code>pig</code>以及<code>chicken</code>实现。把猪肉放进冰箱和把鸡肉放进冰箱步骤是一样的，而放鸡肉时候要多进行一步“杀鸡”，所以使用建造者模式时，到底将步骤抽象提取出多少步则是需要权衡的。然后客户端通过使用<code>director</code>来创建产品(这里我偷懒了，并没返回冻肉这个产品，而仅仅是输出)，无需关心具体实现步骤，实现代码解耦。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>当生成的对象内部结构复杂时（需要很多步骤时）</li><li>需要向客户隐藏产品内部实现步骤时</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建造者模式(Builder Pattern)：将复杂对象的创建和表示分离，使同样的构建过程可以创建不同的表示。&lt;/p&gt;&lt;p&gt;进一步说，建造者隐藏了产品是如何组装的，使建造代码和表示代码分离。建造对象时 &lt;strong&gt;构件顺序稳定&lt;/strong&gt; 的情况下，不管每一步具体怎么变都可以适用。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/assets/images/design-pattern/builder.png&quot; alt=&quot;builder.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://www.hi-roy.com/2019/10/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hi-roy.com/2019/10/09/设计模式-工厂模式/</id>
    <published>2019-10-09T08:58:08.000Z</published>
    <updated>2019-12-12T03:24:36.613Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式又可以分为工厂方法模式和抽象工厂模式。</p><h2 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式(Factory Method Pattern)"></a>工厂方法模式(Factory Method Pattern)</h2><p>工厂模式是指：定义一个接口用户创建对象，让子类决定实例化哪一个类。</p><p>工厂模式中存在4个角色：</p><ol><li>抽象工厂</li><li>具体工厂</li><li>抽象产品</li><li>具体产品</li></ol><p><strong>抽象工厂产生抽象产品，具体工厂生产具体产品。</strong> 这句话很重要，理解了这句话就理解了工厂方法模式。</p><a id="more"></a><p><img src="/assets/images/design-pattern/factory.png" alt="factory.png"></p><p>看定义还是略微抽象，这里我们以客户购买汽水为例，初学编程的人很有可能出现类似下面的代码段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line"><span class="keyword">if</span> require == <span class="string">"cola"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is cola"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> require == <span class="string">"sprite"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is sprite"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> require == <span class="string">"fanta"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is fanta"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"What you want?"</span>)        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很好理解，用户输入他想要购买的汽水，然后程序返回他的选择，如果用户输入的不在上述3个选择内就报错<code>What you want?</code>。但基本上没有可维护性、扩展性，也不能方便的进行复用。为了实现高内聚低耦合的目标，我们做一些修改：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> showname <span class="keyword">interface</span> &#123;</span><br><span class="line">    show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cola <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is cola"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sprite <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is sprite"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fanta <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is fanta"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> factory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e factory)</span> <span class="title">showname</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">showname</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> name &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cola"</span>:</span><br><span class="line"><span class="keyword">return</span> cola&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sprite"</span>:</span><br><span class="line"><span class="keyword">return</span> sprite&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"fanta"</span>:</span><br><span class="line"><span class="keyword">return</span> fanta&#123;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"What you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line">fac := factory&#123;&#125;</span><br><span class="line">fac.showname(require).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于golang中没有类、继承相关的概念，所以这里使用struct和interface来实现。采用上面这种修改后，看上去更复杂了，但却提高了代码的复用率。如果以后有其他地方也要用到这个功能，直接调用factory即可，而不是把那堆<code>if...else</code>复制过去。这种写法还有个学名叫做 <strong>简单工厂模式</strong> ，这个模式优点是工厂类中包含了逻辑判断，根据调用方传入的参数动态实例化相关的类，如果需要修改功能不需要修改调用方的代码。但问题也在这里，如果要新增一个类，那么是要修改<code>case</code>分支条件的，修改原有的类<strong>违反了开闭原则</strong>,这时候就该工厂方法模式出场了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">type</span> showFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">info() saleinfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">type</span> showColaFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s showColaFactory)</span> <span class="title">info</span><span class="params">()</span> <span class="title">saleinfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cola&#123;soda:soda&#123;name:<span class="string">"cola"</span>,price:<span class="number">5</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">type</span> showSpriteFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s showSpriteFactory)</span> <span class="title">info</span><span class="params">()</span> <span class="title">saleinfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cola&#123;soda:soda&#123;name:<span class="string">"sprite"</span>,price:<span class="number">5</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">type</span> showFantaFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s showFantaFactory)</span> <span class="title">info</span><span class="params">()</span> <span class="title">saleinfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fanta&#123;soda:soda&#123;name:<span class="string">"fanta"</span>,price:<span class="number">5</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">type</span> saleinfo <span class="keyword">interface</span> &#123;</span><br><span class="line">getname()</span><br><span class="line">getprice()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> soda <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品</span></span><br><span class="line"><span class="keyword">type</span> cola <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">getname</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s"</span>, e.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">getprice</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"price is %d"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品</span></span><br><span class="line"><span class="keyword">type</span> sprite <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">getname</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s"</span>, e.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">getprice</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"price is %d"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品</span></span><br><span class="line"><span class="keyword">type</span> fanta <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">getname</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s"</span>, e.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">getprice</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"price is %d"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line"><span class="keyword">var</span> s saleinfo</span><br><span class="line"><span class="keyword">switch</span> require &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cola"</span>:</span><br><span class="line">s = showColaFactory&#123;&#125;.info()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sprite"</span>:</span><br><span class="line">s = showSpriteFactory&#123;&#125;.info()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"fanta"</span>:</span><br><span class="line">s = showFantaFactory&#123;&#125;.info()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"what you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.getname()</span><br><span class="line">s.getprice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WoW，代码更复杂了，但这样修改后，如果以后需要新增一个新的<code>juice</code>，只需新增相关的具体工厂和具体产品即可，不用修改原来的工厂类，符合了开闭原则。不过，这种方法把判断逻辑又丢给了调用方，有没有什么办法更进一步呢？答案就是抽象工厂模式，这个下面再说。</p><h3 id="工厂方法模式应用场景"><a href="#工厂方法模式应用场景" class="headerlink" title="工厂方法模式应用场景"></a>工厂方法模式应用场景</h3><ol><li>当子类型有很多，以后需要不断添加不同子类实现时。</li><li>一个系统在框架设计阶段，还不知道将来需要实例化哪些具体子类时。</li><li>系统设计之初不需要具体对象的概念或没有具体对象的概念。</li></ol><h2 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式(Abstract Factory Pattern)"></a>抽象工厂模式(Abstract Factory Pattern)</h2><p>抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体实现类。</p><p><img src="/assets/images/design-pattern/absstact-factory.png" alt="absstact-factory.png"></p><p>进一步说，抽象工厂模式中调用方使用抽象接口来创建一组相关产品，实现了与工厂类的解耦。我们将卖汽水的例子复杂化一点，可以在汽水中加冰，那么用抽象工厂模式写法就变成了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象汽水基类</span></span><br><span class="line"><span class="keyword">type</span> soda <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sodaInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">buy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象可乐基类，继承soda并实现sodaInfo接口</span></span><br><span class="line"><span class="keyword">type</span> cola <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e cola)</span> <span class="title">buy</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s \n"</span>, e.name)</span><br><span class="line">fmt.Printf(<span class="string">"price is %d \n"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体可乐类，加冰</span></span><br><span class="line"><span class="keyword">type</span> colaIce <span class="keyword">struct</span> &#123;</span><br><span class="line">cola</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象雪碧基类，继承soda并实现sodaInfo接口</span></span><br><span class="line"><span class="keyword">type</span> sprite <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e sprite)</span> <span class="title">buy</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s \n"</span>, e.name)</span><br><span class="line">fmt.Printf(<span class="string">"price is %d \n"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体雪碧类，加冰</span></span><br><span class="line"><span class="keyword">type</span> spriteIce <span class="keyword">struct</span> &#123;</span><br><span class="line">sprite</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象芬达基类，继承soda并实现sodaInfo接口</span></span><br><span class="line"><span class="keyword">type</span> fanta <span class="keyword">struct</span> &#123;</span><br><span class="line">soda</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e fanta)</span> <span class="title">buy</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"this is %s \n"</span>, e.name)</span><br><span class="line">fmt.Printf(<span class="string">"price is %d \n"</span>, e.price)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体芬达类，加冰</span></span><br><span class="line"><span class="keyword">type</span> fantaIce <span class="keyword">struct</span> &#123;</span><br><span class="line">fanta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象汽水工厂，注意里面都是生产抽象汽水</span></span><br><span class="line"><span class="keyword">type</span> sodaAbsFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">createCola() sodaInfo</span><br><span class="line">createSprite() sodaInfo</span><br><span class="line">createFanta() sodaInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体汽水工厂，生产具体汽水，实现抽象汽水工厂接口</span></span><br><span class="line"><span class="keyword">type</span> sodaFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sodaFactory)</span> <span class="title">createCola</span><span class="params">()</span> <span class="title">sodaInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> colaIce&#123;</span><br><span class="line">cola:cola&#123;</span><br><span class="line">soda:soda&#123;name:<span class="string">"cola_with_ice"</span>,price: <span class="number">10</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sodaFactory)</span> <span class="title">createSprite</span><span class="params">()</span> <span class="title">sodaInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> colaIce&#123;</span><br><span class="line">cola:cola&#123;</span><br><span class="line">soda:soda&#123;name:<span class="string">"sprice_with_ice"</span>,price: <span class="number">12</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sodaFactory)</span> <span class="title">createFanta</span><span class="params">()</span> <span class="title">sodaInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> colaIce&#123;</span><br><span class="line">cola:cola&#123;</span><br><span class="line">soda:soda&#123;name:<span class="string">"fanta_with_ice"</span>,price: <span class="number">8</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者类，需要买汽水时候向汽水工厂请求</span></span><br><span class="line"><span class="keyword">type</span> customer <span class="keyword">struct</span> &#123;</span><br><span class="line">sodafac sodaAbsFactory</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customer)</span> <span class="title">Buycola</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.sodafac.createCola().buy()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customer)</span> <span class="title">Buysprite</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.sodafac.createSprite().buy()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customer)</span> <span class="title">Buyfanta</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.sodafac.createFanta().buy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := customer&#123;sodafac: sodaFactory&#123;&#125;&#125; <span class="comment">// 创建消费者，并把汽水工厂传递进去</span></span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line"><span class="keyword">switch</span> require &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cola"</span>:</span><br><span class="line">c.buyCola()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sprite"</span>:</span><br><span class="line">c.buySprite()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"fanta"</span>:</span><br><span class="line">c.buyFanta()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"what you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎更更更复杂了，但假设突然需要更换另一家卖汽水的，调用方仅仅修改创建消费者那行代码就可以了。（这里别陷入误区：改1行代码和改100行代码可不是一回事，减少修改!=不修改。）至于判断逻辑的问题，可以使用反射来解决：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> require <span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"Please enter your choice(cola,spirte,fanta): "</span>)</span><br><span class="line">fmt.Scanln(&amp;require)</span><br><span class="line">methodName := fmt.Sprintf(<span class="string">"Buy%s"</span>,require)</span><br><span class="line">c := customer&#123;sodafac: sodaFactory&#123;&#125;&#125; <span class="comment">// 创建消费者，并把汽水工厂传递进去</span></span><br><span class="line">getValue := reflect.ValueOf(c)</span><br><span class="line">methodValue := getValue.MethodByName(methodName) <span class="comment">// 注意所有的函数名都要大写开头，否则reflect找不到对应的函数会报错！</span></span><br><span class="line"><span class="keyword">if</span> methodValue.String() != <span class="string">"&lt;invalid Value&gt;"</span> &#123;</span><br><span class="line">    args := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>)</span><br><span class="line">    methodValue.Call(args)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"what you want?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>千万注意使用反射机制来调用函数时候的名称问题，非大写字母开头的函数<code>MethodbyName</code>是找不到的。虽然使用反射可以解决判断逻辑的问题，但是要不要在项目中这么使用则是见仁见智了。另外补充一句，这个反射行为在python中使用使用<code>getattr()</code>即可实现，或许这也是使用python时候并没怎么想到设计模式的原因之一吧。</p><h3 id="抽象工厂模式应用场景"><a href="#抽象工厂模式应用场景" class="headerlink" title="抽象工厂模式应用场景"></a>抽象工厂模式应用场景</h3><ol><li>创建产品家族，相关产品集合在一起使用的时候。</li><li>提供一个产品类库，并只想显示其接口而不是实现的时候。</li><li>通过组合的方使使用工厂时。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>工厂方法模式通过继承的方式来解耦，抽象工厂模式则通过组合的方式实现解耦。</li><li>工厂方法模式用来创建一个抽象产品，具体工厂实现工厂方法来创建具体产品，抽象工厂模式用组合来创建一个产品家族的抽象类型。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式又可以分为工厂方法模式和抽象工厂模式。&lt;/p&gt;&lt;h2 id=&quot;工厂方法模式-Factory-Method-Pattern&quot;&gt;&lt;a href=&quot;#工厂方法模式-Factory-Method-Pattern&quot; class=&quot;headerlink&quot; title=&quot;工厂方法模式(Factory Method Pattern)&quot;&gt;&lt;/a&gt;工厂方法模式(Factory Method Pattern)&lt;/h2&gt;&lt;p&gt;工厂模式是指：定义一个接口用户创建对象，让子类决定实例化哪一个类。&lt;/p&gt;&lt;p&gt;工厂模式中存在4个角色：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;抽象工厂&lt;/li&gt;&lt;li&gt;具体工厂&lt;/li&gt;&lt;li&gt;抽象产品&lt;/li&gt;&lt;li&gt;具体产品&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;抽象工厂产生抽象产品，具体工厂生产具体产品。&lt;/strong&gt; 这句话很重要，理解了这句话就理解了工厂方法模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-总览</title>
    <link href="http://www.hi-roy.com/2019/10/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/"/>
    <id>http://www.hi-roy.com/2019/10/08/设计模式-总览/</id>
    <published>2019-10-08T08:58:08.000Z</published>
    <updated>2019-11-27T09:15:20.746Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前，忘记从哪看到一句话——设计模式是对编程语言缺陷的弥补。</p><p>年轻的我并没意识到这句话背后的真实含义以及所处语境，外加之后主要开发语言是Python这个动态语言，设计模式真的没怎么用到——比如装饰模式不就是Python中的装饰器嘛，一个语法糖能解决的事居然还弄出个模式来？</p><p>直到我开始学习openstack的源码，发现里面用到了大量的设计模式，才明白自己是多么无知可笑。</p><p>这里借用一位大佬的话：</p><blockquote><p>如果你觉得设计模式在某程度上没用，说明两个问题：<br>1.你的系统还不足以复杂到要用设计模式的程度<br>2.你的经验还没强到能熟练应用设计模式的程度。</p></blockquote><p>能找到这篇文章的，应该都知道面向过程、面向对象、封装继承多态、高内聚低耦合（包含程序级别以及架构级别）、开闭原则(对扩展开放、对修改关闭)、依赖倒置原则(尽量使用抽象类型作为对象实例变量类型，用于实现开闭原则)、单一责任原则(一个模块只负责一个功能)等一堆的名词，以及“组合优于继承”(这里略有争议，我个人对此赞同，最近看一些继承过多的代码总是要向上找好几层父类，还要仔细看子类中有没有重写父类方法，术语叫做类膨胀)。</p><a id="more"></a><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>设计模式(Design Pattern)简单说就是经验的总结，大佬们将其分为了23种。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>通过使用设计模式来提高软件质量，降低开发人员之间的沟通成本。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>先学基础，知道每种设计模式的优缺点以及应用场景，然后灵活应用。</p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>《软件秘籍——设计模式那点事》这本书将设计模式分为了三类：</p><ol><li>创建型<ul><li>工厂方法模式(Factory Method Pattern)</li><li>抽象工厂模式(Abstract Factory Pattern)</li><li>建造者模式(Builder Pattern)</li><li>原型模式(Prototype Pattern)</li><li>单例模式(Singleton Pattern)</li></ul></li><li>结构型<ul><li>适配器模式(Adapter Pattern)</li><li>桥接模式(Bridge Pattern)</li><li>组合模式(Composite Pattern)</li><li>装饰器模式(Decorator Pattern)</li><li>外观模式(Facade Pattern)</li><li>享元模式(Flyweight Pattern)</li><li>代理模式(Proxy Pattern)</li></ul></li><li>行为型<ul><li>责任链模式(Chain of Responsibility Pattern)</li><li>命令模式(Command Pattern)</li><li>解释器模式(Interpreter Pattern)</li><li>迭代器模式(Iterator Pattern)</li><li>中介者模式(Mediator Pattern)</li><li>备忘录模式(Memento Pattern)</li><li>观察者模式(Observer Pattern)</li><li>状态模式(State Pattern)</li><li>策略模式(Strategy Pattern)</li><li>模板方法模式(Template Method Pattern)</li><li>访问者模式(Visitor Pattern)</li></ul></li></ol><blockquote><p>学习设计模式不是目的，真正的目的是学习这种思想，并在实践中应用，学会归纳和总结。</p></blockquote><p>另外这本书是一本被书名耽误了的书，我个人是以这本书为主要脉络，结合《大话设计模式》来进行复习，有兴趣的小伙伴可以翻翻这2本书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久很久以前，忘记从哪看到一句话——设计模式是对编程语言缺陷的弥补。&lt;/p&gt;&lt;p&gt;年轻的我并没意识到这句话背后的真实含义以及所处语境，外加之后主要开发语言是Python这个动态语言，设计模式真的没怎么用到——比如装饰模式不就是Python中的装饰器嘛，一个语法糖能解决的事居然还弄出个模式来？&lt;/p&gt;&lt;p&gt;直到我开始学习openstack的源码，发现里面用到了大量的设计模式，才明白自己是多么无知可笑。&lt;/p&gt;&lt;p&gt;这里借用一位大佬的话：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果你觉得设计模式在某程度上没用，说明两个问题：&lt;br&gt;1.你的系统还不足以复杂到要用设计模式的程度&lt;br&gt;2.你的经验还没强到能熟练应用设计模式的程度。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;能找到这篇文章的，应该都知道面向过程、面向对象、封装继承多态、高内聚低耦合（包含程序级别以及架构级别）、开闭原则(对扩展开放、对修改关闭)、依赖倒置原则(尽量使用抽象类型作为对象实例变量类型，用于实现开闭原则)、单一责任原则(一个模块只负责一个功能)等一堆的名词，以及“组合优于继承”(这里略有争议，我个人对此赞同，最近看一些继承过多的代码总是要向上找好几层父类，还要仔细看子类中有没有重写父类方法，术语叫做类膨胀)。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.hi-roy.com/source/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码学习笔记2</title>
    <link href="http://www.hi-roy.com/2019/09/18/OpenStack%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://www.hi-roy.com/2019/09/18/OpenStack源码学习笔记2/</id>
    <published>2019-09-18T04:46:29.000Z</published>
    <updated>2019-09-18T11:04:59.410Z</updated>
    
    <content type="html"><![CDATA[<p>上次学习了Nova创建虚拟机的过程，这次来看一下Glance是如何上传镜像的。相比于Nova，Glance源码使用了大量的代理模式和装饰器模式，阅读代码时候一个不仔细就会一脸懵X。根据上次说的Openstack套路，我们通过<code>setup.cfg</code>直奔主题——<code>glance/cmd/api.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        config.parse_args()</span><br><span class="line">        config.set_config_defaults()</span><br><span class="line">        wsgi.set_eventlet_hub()</span><br><span class="line">        logging.setup(CONF, <span class="string">'glance'</span>)</span><br><span class="line">        notifier.set_defaults()</span><br><span class="line">        <span class="keyword">if</span> cfg.CONF.profiler.enabled:</span><br><span class="line">            _notifier = osprofiler.notifier.create(<span class="string">"Messaging"</span>,</span><br><span class="line">                                                   oslo_messaging, &#123;&#125;,</span><br><span class="line">                                                   notifier.get_transport(),</span><br><span class="line">                                                   <span class="string">"glance"</span>, <span class="string">"api"</span>,</span><br><span class="line">                                                   cfg.CONF.bind_host)</span><br><span class="line">            osprofiler.notifier.set(_notifier)</span><br><span class="line">            osprofiler.web.enable(cfg.CONF.profiler.hmac_keys)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            osprofiler.web.disable()</span><br><span class="line">        server = wsgi.Server(initialize_glance_store=<span class="literal">True</span>)</span><br><span class="line">        server.start(config.load_paste_app(<span class="string">'glance-api'</span>), default_port=<span class="number">9292</span>)</span><br><span class="line">        server.wait()</span><br><span class="line">    <span class="keyword">except</span> KNOWN_EXCEPTIONS <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        fail(e)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="配置加载与路由绑定"><a href="#配置加载与路由绑定" class="headerlink" title="配置加载与路由绑定"></a>配置加载与路由绑定</h2><p>和Nova一样，这个文件主要作用就是加载配置、创建WSGI Server并运行，这里我们注意一下<code>initialize_glance_store=True</code>这里，新版中关于存储的部分已经独立出项目叫做<a href="https://github.com/openstack/glance_store" target="_blank" rel="noopener">glance_store</a>，这里还对这部分进行了初始化，我们跟进<code>glance/common/wsgi.py</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_glance_store</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Initialize glance store."""</span></span><br><span class="line">    glance_store.register_opts(CONF)</span><br><span class="line">    glance_store.create_stores(CONF)</span><br><span class="line">    glance_store.verify_default_store()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span><span class="params">(object)</span>:</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threads=<span class="number">1000</span>, initialize_glance_store=False)</span>:</span></span><br><span class="line">        ......    </span><br><span class="line">        self.initialize_glance_store = initialize_glance_store</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self, application, default_port)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line">        self.default_port = default_port</span><br><span class="line">        self.configure()</span><br><span class="line">        self.start_wsgi()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(self, old_conf=None, has_changed=None)</span>:</span></span><br><span class="line">        eventlet.wsgi.MAX_HEADER_LINE = CONF.max_header_line</span><br><span class="line">        self.client_socket_timeout = CONF.client_socket_timeout <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line">        self.configure_socket(old_conf, has_changed)</span><br><span class="line">        <span class="keyword">if</span> self.initialize_glance_store:</span><br><span class="line">            initialize_glance_store()</span><br></pre></td></tr></table></figure><p>这里我们跟进<code>glance_store/backend.py</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_stores</span><span class="params">(conf=CONF)</span>:</span></span><br><span class="line">    store_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (store_entry, store_instance) <span class="keyword">in</span> _load_stores(conf):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            schemes = store_instance.get_schemes()</span><br><span class="line">            store_instance.configure(re_raise_bsc=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">except</span> NotImplementedError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> schemes:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.BackendException(<span class="string">'Unable to register store %s. '</span></span><br><span class="line">                                              <span class="string">'No schemes associated with it.'</span></span><br><span class="line">                                              % store_entry)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            LOG.debug(<span class="string">"Registering store %s with schemes %s"</span>,</span><br><span class="line">                      store_entry, schemes)</span><br><span class="line">            scheme_map = &#123;&#125;</span><br><span class="line">            loc_cls = store_instance.get_store_location_class()</span><br><span class="line">            <span class="keyword">for</span> scheme <span class="keyword">in</span> schemes:</span><br><span class="line">                scheme_map[scheme] = &#123;</span><br><span class="line">                    <span class="string">'store'</span>: store_instance,</span><br><span class="line">                    <span class="string">'location_class'</span>: loc_cls,</span><br><span class="line">                    <span class="string">'store_entry'</span>: store_entry</span><br><span class="line">                &#125;</span><br><span class="line">            location.register_scheme_map(scheme_map)</span><br><span class="line">            store_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> store_count</span><br></pre></td></tr></table></figure><p>在这里会根据<code>/etc/glance/glance_api.conf</code>中的配置信息找到对应的driver(位于<code>glance_store/_drivers</code>目录)并配置，然后调用<code>register_scheme_map()</code>进行绑定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SCHEME_TO_CLS_MAP = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_scheme_map</span><span class="params">(scheme_map)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> (k, v) <span class="keyword">in</span> scheme_map.items():</span><br><span class="line">        LOG.debug(<span class="string">"Registering scheme %s with %s"</span>, k, v)</span><br><span class="line">        SCHEME_TO_CLS_MAP[k] = v</span><br></pre></td></tr></table></figure><p>这样就完成了所需的准备工作。</p><h2 id="镜像上传"><a href="#镜像上传" class="headerlink" title="镜像上传"></a>镜像上传</h2><p>glance镜像上传分为2个步骤，首先在数据库中创建一条记录，并返回相关信息，此时使用<code>glance image-list</code>命令可以查看到一个空镜像，状态为<code>queued</code>。然后再上传镜像数据，上传完成后进入<code>active</code>状态，代码均来源于rocky版。</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>根据<a href="https://docs.openstack.org/api-ref/image/v2/index.html?expanded=create-image-detail#create-image" target="_blank" rel="noopener">文档</a>创建镜像是向<code>/v2/images</code>发送POST请求，然后再结合<code>glance-api-paste.ini</code>中的定义：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[pipeline:glance-api]</span></span><br><span class="line"><span class="attr">pipeline</span> = cors healthcheck http_proxy_to_wsgi versionnegotiation osprofiler unauthenticated-context rootapp</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:rootapp]</span></span><br><span class="line"><span class="attr">paste.composite_factory</span> = glance.api:root_app_factory</span><br><span class="line">/: apiversions</span><br><span class="line">/v1: apiv1app</span><br><span class="line">/v2: apiv2app</span><br><span class="line"></span><br><span class="line"><span class="section">[app:apiversions]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = glance.api.versions:create_resource</span><br><span class="line"></span><br><span class="line"><span class="section">[app:apiv1app]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = glance.api.v1.router:API.factory</span><br><span class="line"></span><br><span class="line"><span class="section">[app:apiv2app]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = glance.api.v2.router:API.factory</span><br></pre></td></tr></table></figure><p>根据<code>glance/api/v2/router.py</code>中的<code>API()</code>定义，找到实际处理post请求的函数为<code>glance/api/v2/images.py</code>中的<code>ImagesController</code>类的<code>create</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, req, image, extra_properties, tags)</span>:</span></span><br><span class="line">        image_factory = self.gateway.get_image_factory(req.context)</span><br><span class="line">        image_repo = self.gateway.get_repo(req.context)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            image = image_factory.new_image(extra_properties=extra_properties,</span><br><span class="line">                                            tags=tags, **image)</span><br><span class="line">            image_repo.add(image)</span><br><span class="line">        <span class="keyword">except</span> (exception.DuplicateLocation,</span><br><span class="line">                exception.Invalid) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPBadRequest(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> (exception.ReservedProperty,</span><br><span class="line">                exception.ReadonlyProperty) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPForbidden(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> exception.Forbidden <span class="keyword">as</span> e:</span><br><span class="line">            LOG.debug(<span class="string">"User not permitted to create image"</span>)</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPForbidden(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> exception.LimitExceeded <span class="keyword">as</span> e:</span><br><span class="line">            LOG.warn(encodeutils.exception_to_unicode(e))</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPRequestEntityTooLarge(</span><br><span class="line">                explanation=e.msg, request=req, content_type=<span class="string">'text/plain'</span>)</span><br><span class="line">        <span class="keyword">except</span> exception.Duplicate <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPConflict(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> exception.NotAuthenticated <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPUnauthorized(explanation=e.msg)</span><br><span class="line">        <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">            LOG.debug(encodeutils.exception_to_unicode(e))</span><br><span class="line">            <span class="keyword">raise</span> webob.exc.HTTPBadRequest(explanation=e)</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><p>这段代码看上简单，实际内含玄机，如果跟进<code>gateway.get_image_factory</code>和<code>gateway.get_repo</code>函数，会发现作者用了大量的装饰器模式和代理模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glance/gateway.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_image_factory</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    image_factory = glance.domain.ImageFactory()</span><br><span class="line">    store_image_factory = glance.location.ImageFactoryProxy(</span><br><span class="line">        image_factory, context, self.store_api, self.store_utils)</span><br><span class="line">    quota_image_factory = glance.quota.ImageFactoryProxy(</span><br><span class="line">        store_image_factory, context, self.db_api, self.store_utils)</span><br><span class="line">    policy_image_factory = policy.ImageFactoryProxy(</span><br><span class="line">        quota_image_factory, context, self.policy)</span><br><span class="line">    notifier_image_factory = glance.notifier.ImageFactoryProxy(</span><br><span class="line">        policy_image_factory, context, self.notifier)</span><br><span class="line">    <span class="keyword">if</span> property_utils.is_property_protection_enabled():</span><br><span class="line">        property_rules = property_utils.PropertyRules(self.policy)</span><br><span class="line">        pif = property_protections.ProtectedImageFactoryProxy(</span><br><span class="line">            notifier_image_factory, context, property_rules)</span><br><span class="line">        authorized_image_factory = authorization.ImageFactoryProxy(</span><br><span class="line">            pif, context)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        authorized_image_factory = authorization.ImageFactoryProxy(</span><br><span class="line">            notifier_image_factory, context)</span><br><span class="line">    <span class="keyword">return</span> authorized_image_factory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_repo</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    image_repo = glance.db.ImageRepo(context, self.db_api)</span><br><span class="line">    store_image_repo = glance.location.ImageRepoProxy(</span><br><span class="line">        image_repo, context, self.store_api, self.store_utils)</span><br><span class="line">    quota_image_repo = glance.quota.ImageRepoProxy(</span><br><span class="line">        store_image_repo, context, self.db_api, self.store_utils)</span><br><span class="line">    policy_image_repo = policy.ImageRepoProxy(</span><br><span class="line">        quota_image_repo, context, self.policy)</span><br><span class="line">    notifier_image_repo = glance.notifier.ImageRepoProxy(</span><br><span class="line">        policy_image_repo, context, self.notifier)</span><br><span class="line">    <span class="keyword">if</span> property_utils.is_property_protection_enabled():</span><br><span class="line">        property_rules = property_utils.PropertyRules(self.policy)</span><br><span class="line">        pir = property_protections.ProtectedImageRepoProxy(</span><br><span class="line">            notifier_image_repo, context, property_rules)</span><br><span class="line">        authorized_image_repo = authorization.ImageRepoProxy(</span><br><span class="line">            pir, context)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        authorized_image_repo = authorization.ImageRepoProxy(</span><br><span class="line">            notifier_image_repo, context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> authorized_image_repo</span><br></pre></td></tr></table></figure><p>阅读这里的时候一个不仔细逻辑就断了，要像剥洋葱一样，一层一层剥开它的心。这里我就不记录追踪细节了，经过一层层判断后，<code>image_factory.new_image</code>函数最终进入<code>glance/domain/__init__.py</code>中并返回了一个<code>Image</code>类型实例。</p><p>然后将这个实例传递给<code>image_repo.add</code>函数，这个函数再经过一层层判断，进入<code>glance/db/__init__.py</code>中调用<code>ImageRepo</code>的<code>add()</code>方法，在这个方法中最终调用了<code>glance/db/sqlalchemy/api.py</code>中的<code>image_create()</code>函数来在数据库中创建新记录。</p><p>如果没有发生错误，则返回创建的空镜像信息给客户端。</p><h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><p><a href="https://docs.openstack.org/api-ref/image/v2/?expanded=upload-binary-image-data-detail#upload-binary-image-data" target="_blank" rel="noopener">文档</a>中定义，上传数据行为是向<code>/v2/images/{image_id}/file</code>发送PUT请求，实际处理函数为<code>glance/api/v2/image_data.py</code>中的<code>ImageDataController</code>类的<code>upload</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">@utils.mutating</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(self, req, image_id, data, size)</span>:</span></span><br><span class="line">    backend = <span class="literal">None</span></span><br><span class="line">    image_repo = self.gateway.get_repo(req.context)</span><br><span class="line">    image = <span class="literal">None</span></span><br><span class="line">    refresher = <span class="literal">None</span></span><br><span class="line">    cxt = req.context</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.policy.enforce(cxt, <span class="string">'upload_image'</span>, &#123;&#125;)</span><br><span class="line">        image = image_repo.get(image_id)</span><br><span class="line">        image.status = <span class="string">'saving'</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            image_repo.save(image, from_state=<span class="string">'queued'</span>)</span><br><span class="line">            image.set_data(data, size, backend=backend)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                image_repo.save(image, from_state=<span class="string">'saving'</span>)</span><br><span class="line">            <span class="keyword">except</span> exception.NotAuthenticated:</span><br><span class="line">                <span class="keyword">if</span> refresher <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># request a new token to update an image in database</span></span><br><span class="line">                    cxt.auth_token = refresher.refresh_token()</span><br><span class="line">                    image_repo = self.gateway.get_repo(req.context)</span><br><span class="line">                    image_repo.save(image, from_state=<span class="string">'saving'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>新版本中glance已经可以支持多后端的配置，但还不是稳定版。这里以单后端为例，首先将状态改为saving，然后调用<code>set_data</code>函数。由于某些不可描述的原因，我没法启动程序进行单步调试，只能使用IDE的跳转功能，结果这里兜兜转转饶了很久。这里我就直接给出答案吧，最终调用的是<code>glance/location.py</code>的<code>ImageProxy</code>类中的方法。这里面的关键点在于image其实是由<code>ImageProxy</code>实例代理的，转换发生在初始化对象时候创建的<code>Helper</code>类，这个类有一个<code>proxy</code>方法用来将原始<code>Image</code>类型转换成<code>ImageProxy</code>类型。这里具体就不再详细说明了，回到<code>set_data</code>函数定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_data</span><span class="params">(self, data, size=None, backend=None)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    hashing_algo = CONF[<span class="string">'hashing_algorithm'</span>]</span><br><span class="line">    <span class="keyword">if</span> CONF.enabled_backends:</span><br><span class="line">        (location, size, checksum,</span><br><span class="line">            multihash, loc_meta) = self.store_api.add_with_multihash(</span><br><span class="line">            CONF,</span><br><span class="line">            self.image.image_id,</span><br><span class="line">            utils.LimitingReader(utils.CooperativeReader(data),</span><br><span class="line">                                    CONF.image_size_cap),</span><br><span class="line">            size,</span><br><span class="line">            backend,</span><br><span class="line">            hashing_algo,</span><br><span class="line">            context=self.context,</span><br><span class="line">            verifier=verifier)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        (location, size, checksum,</span><br><span class="line">            multihash, loc_meta) = self.store_api.add_to_backend_with_multihash(</span><br><span class="line">            CONF,</span><br><span class="line">            self.image.image_id,</span><br><span class="line">            utils.LimitingReader(utils.CooperativeReader(data),</span><br><span class="line">                                    CONF.image_size_cap),</span><br><span class="line">            size,</span><br><span class="line">            hashing_algo,</span><br><span class="line">            context=self.context,</span><br><span class="line">            verifier=verifier)</span><br><span class="line"></span><br><span class="line">    self.image.locations = [&#123;<span class="string">'url'</span>: location, <span class="string">'metadata'</span>: loc_meta, <span class="string">'status'</span>: <span class="string">'active'</span>&#125;]</span><br><span class="line">    self.image.size = size</span><br><span class="line">    self.image.checksum = checksum</span><br><span class="line">    self.image.os_hash_value = multihash</span><br><span class="line">    self.image.os_hash_algo = hashing_algo</span><br><span class="line">    self.image.status = <span class="string">'active'</span></span><br></pre></td></tr></table></figure><p>这里的<code>store_api</code>默认就是<code>glance_store</code>了，其中<code>add_with_multihash</code>是启用多后端时候调用，<code>add_to_backend_with_multihash</code>启用单后端时候调用。这里以单后端为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to_backend_with_multihash</span><span class="params">(conf, image_id, data, size, hashing_algo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  scheme=None, context=None, verifier=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> scheme <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        scheme = conf[<span class="string">'glance_store'</span>][<span class="string">'default_store'</span>]</span><br><span class="line">    store = get_store_from_scheme(scheme)</span><br><span class="line">    <span class="keyword">return</span> store_add_to_backend_with_multihash(</span><br><span class="line">        image_id, data, size, hashing_algo, store, context, verifier)</span><br></pre></td></tr></table></figure><p>其中<code>get_store_from_scheme</code>函数作用是获取到文章开头所说的绑定到<code>SCHEME_TO_CLS_MAP</code>中的对应的<code>driver</code>，然后经过<code>store_add_to_backend_with_multihash</code>函数进入相应的<code>driver</code>的<code>add</code>方法，这里以Ceph的块存储RBD(RADOS Block Device)为例，函数位于<code>glance_store/_drivers/rbd.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@driver.back_compat_add</span></span><br><span class="line"><span class="meta">@capabilities.check</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, image_id, image_file, image_size, hashing_algo, context=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        verifier=None)</span>:</span></span><br><span class="line">    checksum = hashlib.md5()</span><br><span class="line">    os_hash_value = hashlib.new(str(hashing_algo))</span><br><span class="line">    image_name = str(image_id)</span><br><span class="line">    <span class="keyword">with</span> self.get_connection(conffile=self.conf_file,</span><br><span class="line">                             rados_id=self.user) <span class="keyword">as</span> conn:</span><br><span class="line">        fsid = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(conn, <span class="string">'get_fsid'</span>):</span><br><span class="line">            fsid = encodeutils.safe_decode(conn.get_fsid())</span><br><span class="line">        <span class="keyword">with</span> conn.open_ioctx(self.pool) <span class="keyword">as</span> ioctx:</span><br><span class="line">            order = int(math.log(self.WRITE_CHUNKSIZE, <span class="number">2</span>))</span><br><span class="line">            LOG.debug(<span class="string">'creating image %s with order %d and size %d'</span>,</span><br><span class="line">                      image_name, order, image_size)</span><br><span class="line">            <span class="keyword">if</span> image_size == <span class="number">0</span>:</span><br><span class="line">                LOG.warning(_(<span class="string">"since image size is zero we will be doing "</span></span><br><span class="line">                              <span class="string">"resize-before-write for each chunk which "</span></span><br><span class="line">                              <span class="string">"will be considerably slower than normal"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                loc = self._create_image(fsid, conn, ioctx, image_name,</span><br><span class="line">                                         image_size, order)</span><br><span class="line">            <span class="keyword">except</span> rbd.ImageExists:</span><br><span class="line">                msg = _(<span class="string">'RBD image %s already exists'</span>) % image_id</span><br><span class="line">                <span class="keyword">raise</span> exceptions.Duplicate(message=msg)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> rbd.Image(ioctx, image_name) <span class="keyword">as</span> image:</span><br><span class="line">                    bytes_written = <span class="number">0</span></span><br><span class="line">                    offset = <span class="number">0</span></span><br><span class="line">                    chunks = utils.chunkreadable(image_file,</span><br><span class="line">                                                 self.WRITE_CHUNKSIZE)</span><br><span class="line">                    <span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">                        <span class="comment"># If the image size provided is zero we need to do</span></span><br><span class="line">                        <span class="comment"># a resize for the amount we are writing. This will</span></span><br><span class="line">                        <span class="comment"># be slower so setting a higher chunk size may</span></span><br><span class="line">                        <span class="comment"># speed things up a bit.</span></span><br><span class="line">                        <span class="keyword">if</span> image_size == <span class="number">0</span>:</span><br><span class="line">                            chunk_length = len(chunk)</span><br><span class="line">                            length = offset + chunk_length</span><br><span class="line">                            bytes_written += chunk_length</span><br><span class="line">                            LOG.debug(_(<span class="string">"resizing image to %s KiB"</span>) %</span><br><span class="line">                                      (length / units.Ki))</span><br><span class="line">                            image.resize(length)</span><br><span class="line">                        LOG.debug(_(<span class="string">"writing chunk at offset %s"</span>) %</span><br><span class="line">                                  (offset))</span><br><span class="line">                        offset += image.write(chunk, offset)</span><br><span class="line">                        os_hash_value.update(chunk)</span><br><span class="line">                        checksum.update(chunk)</span><br><span class="line">                        <span class="keyword">if</span> verifier:</span><br><span class="line">                            verifier.update(chunk)</span><br><span class="line">                    <span class="keyword">if</span> loc.snapshot:</span><br><span class="line">                        image.create_snap(loc.snapshot)</span><br><span class="line">                        image.protect_snap(loc.snapshot)</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> image_size == <span class="number">0</span>:</span><br><span class="line">        image_size = bytes_written</span><br><span class="line">    metadata = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> self.backend_group:</span><br><span class="line">        metadata[<span class="string">'store'</span>] = <span class="string">u"%s"</span> % self.backend_group</span><br><span class="line">    <span class="keyword">return</span> (loc.get_uri(),</span><br><span class="line">            image_size,</span><br><span class="line">            checksum.hexdigest(),</span><br><span class="line">            os_hash_value.hexdigest(),</span><br><span class="line">            metadata)</span><br></pre></td></tr></table></figure><p>这个函数首先计算hash值，然后创建连接，再判断镜像是否存在，不存在则上传，然后将数据返回给调用者。最后glance中修改状态为active，整个镜像上传过程就结束了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次学习了Nova创建虚拟机的过程，这次来看一下Glance是如何上传镜像的。相比于Nova，Glance源码使用了大量的代理模式和装饰器模式，阅读代码时候一个不仔细就会一脸懵X。根据上次说的Openstack套路，我们通过&lt;code&gt;setup.cfg&lt;/code&gt;直奔主题——&lt;code&gt;glance/cmd/api.py&lt;/code&gt;:&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        config.parse_args()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        config.set_config_defaults()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wsgi.set_eventlet_hub()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        logging.setup(CONF, &lt;span class=&quot;string&quot;&gt;&#39;glance&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        notifier.set_defaults()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cfg.CONF.profiler.enabled:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            _notifier = osprofiler.notifier.create(&lt;span class=&quot;string&quot;&gt;&quot;Messaging&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   oslo_messaging, &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   notifier.get_transport(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   &lt;span class=&quot;string&quot;&gt;&quot;glance&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;api&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                   cfg.CONF.bind_host)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            osprofiler.notifier.set(_notifier)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            osprofiler.web.enable(cfg.CONF.profiler.hmac_keys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            osprofiler.web.disable()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        server = wsgi.Server(initialize_glance_store=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        server.start(config.load_paste_app(&lt;span class=&quot;string&quot;&gt;&#39;glance-api&#39;&lt;/span&gt;), default_port=&lt;span class=&quot;number&quot;&gt;9292&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        server.wait()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; KNOWN_EXCEPTIONS &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fail(e)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.hi-roy.com/source/all-categories/Python/"/>
    
      <category term="OpenStack" scheme="http://www.hi-roy.com/source/all-categories/Python/OpenStack/"/>
    
    
      <category term="Glance" scheme="http://www.hi-roy.com/source/all-tags/Glance/"/>
    
  </entry>
  
</feed>
