<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Hi!Roy!"><title>Hi!Roy!</title><meta name="author" content="Roy"><link rel="icon" href="http://www.hi-roy.com/assets/images/favicon.ico"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><meta property="og:type" content="blog"><meta property="og:title" content="Hi!Roy!"><meta property="og:url" content="http://www.hi-roy.com/index.html"><meta property="og:site_name" content="Hi!Roy!"><meta property="og:locale" content="zh-cn"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hi!Roy!"><meta property="og:image" content="http://www.hi-roy.com/assets/images/my.jpg"><link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?21513ec2bcd577b3297a1b16da82fa40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div id="blog"><header id="header" data-behavior="1"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/">Hi!Roy!</a></div><a class="header-right-icon" href="#about"><i class="fa fa-lg fa-question"></i></a></header><nav id="sidebar" data-behavior="1"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about"><img class="sidebar-profile-picture" src="/assets/images/my.jpg" alt="作者的图片"></a><h4 class="sidebar-profile-name">Roy</h4><h5 class="sidebar-profile-bio"><p>君以国士待我，我必以国士报君。</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/"><i class="sidebar-button-icon fa fa-lg fa-home"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories"><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags"><i class="sidebar-button-icon fa fa-lg fa-tags"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives"><i class="sidebar-button-icon fa fa-lg fa-archive"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link open-algolia-search" href="#search"><i class="sidebar-button-icon fa fa-lg fa-search"></i> <span class="sidebar-button-desc">搜索</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about"><i class="sidebar-button-icon fa fa-lg fa-question"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/shenyushun" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-github"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:darkcooking@gmail.com" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml"><i class="sidebar-button-icon fa fa-lg fa-rss"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div id="main" data-behavior="1" class="hasCoverMetaIn"><section class="postShorten-group main-content-wrap"><article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/12/09/OpenStack源码学习笔记4/">OpenStack源码学习笔记4</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-12-09T12:46:29+08:00">12月 09, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Python/">Python</a>, <a class="category-link" href="/source/all-categories/Python/OpenStack/">OpenStack</a></div></div><div class="postShorten-content" itemprop="articleBody"><p>这篇文章记录nova创建快照时候的过程，根据<a href="https://docs.openstack.org/api-ref/compute/?expanded=create-image-createimage-action-detail#create-image-createimage-action" target="_blank" rel="noopener">文档</a>，创建快照其实是向<code>/servers/{server_id}/action</code>发送了一个POST的请求，内容则是类似:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    "createImage" : &#123;</span><br><span class="line">        "name" : "image-name",</span><br><span class="line">        "metadata": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据openstack的套路，首先找到处理这个请求的代码，在第一篇文章中我们分析了在Stein版中虚拟机的创建过程，但由于某些不可描述的原因，<strong><em>下面的代码是N版的</em></strong>，一定要注意版本问题。N版中是没有<code>nova/api/openstack/compute/routes.py</code>这个文件的，所有处理请求的代码都在<code>nova/api/openstack/compute/</code>目录中，所以我们直接看<code>servers.py</code>即可，相关代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wsgi.response(202)</span></span><br><span class="line"><span class="meta">@extensions.expected_errors((400, 403, 404, 409))</span></span><br><span class="line"><span class="meta">@wsgi.action('createImage')</span></span><br><span class="line"><span class="meta">@common.check_snapshots_enabled</span></span><br><span class="line"><span class="meta">@validation.schema(schema_servers.create_image, '2.0', '2.0')</span></span><br><span class="line"><span class="meta">@validation.schema(schema_servers.create_image, '2.1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_action_create_image</span><span class="params">(self, req, id, body)</span>:</span></span><br><span class="line">    <span class="string">"""Snapshot a server instance."""</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> compute_utils.is_volume_backed_instance(context, instance,</span><br><span class="line">                                                        bdms):</span><br><span class="line">            context.can(server_policies.SERVERS %</span><br><span class="line">                <span class="string">'create_image:allow_volume_backed'</span>)</span><br><span class="line">            image = self.compute_api.snapshot_volume_backed(</span><br><span class="line">                                                    context,</span><br><span class="line">                                                    instance,</span><br><span class="line">                                                    image_name,</span><br><span class="line">                                                    extra_properties=</span><br><span class="line">                                                    metadata)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            image = self.compute_api.snapshot(context,</span><br><span class="line">                                                instance,</span><br><span class="line">                                                image_name,</span><br><span class="line">                                                extra_properties=metadata)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># build location of newly-created image entity</span></span><br><span class="line">    image_id = str(image[<span class="string">'id'</span>])</span><br><span class="line">    image_ref = glance.generate_image_url(image_id)</span><br><span class="line"></span><br><span class="line">    resp = webob.Response(status_int=<span class="number">202</span>)</span><br><span class="line">    resp.headers[<span class="string">'Location'</span>] = image_ref</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>由于我的配置文件中没启用<code>cell</code>功能，所以代码中的<code>self.compute_api</code>就是<code>nova/compute/api.py</code>中的<code>API()</code>类，<code>snapshot</code>方法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@check_instance_cell</span></span><br><span class="line"><span class="meta">@check_instance_state(vm_state=[vm_states.ACTIVE, vm_states.STOPPED,</span></span><br><span class="line">                                vm_states.PAUSED, vm_states.SUSPENDED])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span><span class="params">(self, context, instance, name, extra_properties=None)</span>:</span></span><br><span class="line">    <span class="string">"""Snapshot the given instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param instance: nova.objects.instance.Instance object</span></span><br><span class="line"><span class="string">    :param name: name of the snapshot</span></span><br><span class="line"><span class="string">    :param extra_properties: dict of extra image properties to include</span></span><br><span class="line"><span class="string">                                when creating the image.</span></span><br><span class="line"><span class="string">    :returns: A dict containing image metadata</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image_meta = self._create_image(context, instance, name,</span><br><span class="line">                                    <span class="string">'snapshot'</span>,</span><br><span class="line">                                    extra_properties=extra_properties)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NOTE(comstud): Any changes to this method should also be made</span></span><br><span class="line">    <span class="comment"># to the snapshot_instance() method in nova/cells/messaging.py</span></span><br><span class="line">    instance.task_state = task_states.IMAGE_SNAPSHOT_PENDING</span><br><span class="line">    instance.save(expected_task_state=[<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">    self.compute_rpcapi.snapshot_instance(context, instance,</span><br><span class="line">                                            image_meta[<span class="string">'id'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image_meta</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_image</span><span class="params">(self, context, instance, name, image_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                    extra_properties=None)</span>:</span></span><br><span class="line">    <span class="string">"""Create new image entry in the image service.  This new image</span></span><br><span class="line"><span class="string">    will be reserved for the compute manager to upload a snapshot</span></span><br><span class="line"><span class="string">    or backup.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param context: security context</span></span><br><span class="line"><span class="string">    :param instance: nova.objects.instance.Instance object</span></span><br><span class="line"><span class="string">    :param name: string for name of the snapshot</span></span><br><span class="line"><span class="string">    :param image_type: snapshot | backup</span></span><br><span class="line"><span class="string">    :param extra_properties: dict of extra image properties to include</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    properties = &#123;</span><br><span class="line">        <span class="string">'instance_uuid'</span>: instance.uuid,</span><br><span class="line">        <span class="string">'user_id'</span>: str(context.user_id),</span><br><span class="line">        <span class="string">'image_type'</span>: image_type,</span><br><span class="line">    &#125;</span><br><span class="line">    properties.update(extra_properties <span class="keyword">or</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    image_meta = self._initialize_instance_snapshot_metadata(</span><br><span class="line">        instance, name, properties)</span><br><span class="line">    <span class="comment"># if we're making a snapshot, omit the disk and container formats,</span></span><br><span class="line">    <span class="comment"># since the image may have been converted to another format, and the</span></span><br><span class="line">    <span class="comment"># original values won't be accurate.  The driver will populate these</span></span><br><span class="line">    <span class="comment"># with the correct values later, on image upload.</span></span><br><span class="line">    <span class="keyword">if</span> image_type == <span class="string">'snapshot'</span>:</span><br><span class="line">        image_meta.pop(<span class="string">'disk_format'</span>, <span class="literal">None</span>)</span><br><span class="line">        image_meta.pop(<span class="string">'container_format'</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> self.image_api.create(context, image_meta)</span><br></pre></td></tr></table></figure><p>代码中的<code>self.image_api</code>就是调用glanceclient创建镜像，之前已经写过镜像上传这里就不贴代码了，有兴趣的可以去看<code>nova/image/glance.py</code>，看到rpc就知道这里发送一个异步请求，看<code>nova/compute/rpcapi.py</code>代码不出所料:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot_instance</span><span class="params">(self, ctxt, instance, image_id)</span>:</span></span><br><span class="line">    version = <span class="string">'4.0'</span></span><br><span class="line">    cctxt = self.router.by_instance(ctxt, instance).prepare(</span><br><span class="line">            server=_compute_host(<span class="literal">None</span>, instance), version=version)</span><br><span class="line">    cctxt.cast(ctxt, <span class="string">'snapshot_instance'</span>,</span><br><span class="line">                instance=instance,</span><br><span class="line">                image_id=image_id)</span><br></pre></td></tr></table></figure><p>根据套路，这里应该是到<code>nova/compute/manager.py</code>了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wrap_exception()</span></span><br><span class="line"><span class="meta">@reverts_task_state</span></span><br><span class="line"><span class="meta">@wrap_instance_fault</span></span><br><span class="line"><span class="meta">@delete_image_on_error</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot_instance</span><span class="params">(self, context, image_id, instance)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        instance.task_state = task_states.IMAGE_SNAPSHOT</span><br><span class="line">        instance.save(</span><br><span class="line">                    expected_task_state=task_states.IMAGE_SNAPSHOT_PENDING)</span><br><span class="line">    <span class="keyword">except</span> exception.InstanceNotFound:</span><br><span class="line">        <span class="comment"># possibility instance no longer exists, no point in continuing</span></span><br><span class="line">        LOG.debug(<span class="string">"Instance not found, could not set state %s "</span></span><br><span class="line">                    <span class="string">"for instance."</span>,</span><br><span class="line">                    task_states.IMAGE_SNAPSHOT, instance=instance)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">except</span> exception.UnexpectedDeletingTaskStateError:</span><br><span class="line">        LOG.debug(<span class="string">"Instance being deleted, snapshot cannot continue"</span>,</span><br><span class="line">                    instance=instance)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self._snapshot_instance(context, image_id, instance,</span><br><span class="line">                            task_states.IMAGE_SNAPSHOT)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_snapshot_instance</span><span class="params">(self, context, image_id, instance,</span></span></span><br><span class="line"><span class="function"><span class="params">                        expected_task_state)</span>:</span></span><br><span class="line">    context = context.elevated()</span><br><span class="line">    instance.power_state = self._get_power_state(context, instance)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ...</span><br><span class="line">        self.driver.snapshot(context, instance, image_id,</span><br><span class="line">                                update_task_state)</span><br><span class="line">        instance.task_state = <span class="literal">None</span></span><br><span class="line">        instance.save(expected_task_state=task_states.IMAGE_UPLOADING)</span><br><span class="line">        self._notify_about_instance_usage(context, instance,</span><br><span class="line">                                            <span class="string">"snapshot.end"</span>)</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>然后进入<code>driver</code>中，这里我以使用<code>libvirt</code>为例，位于<code>nova/virt/libvirt/driver.py</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span><span class="params">(self, context, instance, image_id, update_task_state)</span>:</span></span><br><span class="line">        <span class="string">"""Create snapshot from a running VM instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This command only works with qemu 0.14+</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ...        </span><br><span class="line">        snapshot = self._image_api.get(context, image_id)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># NOTE(bfilippov): save lvm and rbd as raw</span></span><br><span class="line">        <span class="keyword">if</span> image_format == <span class="string">'lvm'</span> <span class="keyword">or</span> image_format == <span class="string">'rbd'</span>:</span><br><span class="line">            image_format = <span class="string">'raw'</span></span><br><span class="line"></span><br><span class="line">        metadata = self._create_snapshot_metadata(instance.image_meta,</span><br><span class="line">                                                  instance,</span><br><span class="line">                                                  image_format,</span><br><span class="line">                                                  snapshot[<span class="string">'name'</span>])</span><br><span class="line">        ....</span><br><span class="line">        snapshot_backend = self.image_backend.snapshot(instance,</span><br><span class="line">                disk_path,</span><br><span class="line">                image_type=source_type)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            update_task_state(task_state=task_states.IMAGE_UPLOADING,</span><br><span class="line">                              expected_state=task_states.IMAGE_PENDING_UPLOAD)</span><br><span class="line">            metadata[<span class="string">'location'</span>] = snapshot_backend.direct_snapshot(</span><br><span class="line">                context, snapshot_name, image_format, image_id,</span><br><span class="line">                instance.image_ref)</span><br><span class="line">            ...</span><br><span class="line">            self._image_api.update(context, image_id, metadata,</span><br><span class="line">                                   purge_props=<span class="literal">False</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这里代码太长了我做了删减，所以缩进看起来有点奇怪。经过一系列的判断、准备后，首先获取对应的存储后端，这里我以rbd为例，其他类型的可以看<code>nova/virt/libvirt/imagebackend.py</code>中<code>Backend</code>类的相关定义。然后调用<code>Rbd</code>类下的<code>direct_snapshot</code>方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">direct_snapshot</span><span class="params">(self, context, snapshot_name, image_format,</span></span></span><br><span class="line"><span class="function"><span class="params">                        image_id, base_image_id)</span>:</span></span><br><span class="line">    <span class="string">"""Creates an RBD snapshot directly.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    fsid = self.driver.get_fsid()</span><br><span class="line">    parent_pool = self._get_parent_pool(context, base_image_id, fsid)</span><br><span class="line">    self.driver.create_snap(self.rbd_name, snapshot_name, protect=<span class="literal">True</span>)</span><br><span class="line">    location = &#123;<span class="string">'url'</span>: <span class="string">'rbd://%(fsid)s/%(pool)s/%(image)s/%(snap)s'</span> %</span><br><span class="line">                        dict(fsid=fsid,</span><br><span class="line">                            pool=self.pool,</span><br><span class="line">                            image=self.rbd_name,</span><br><span class="line">                            snap=snapshot_name)&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.driver.clone(location, image_id, dest_pool=parent_pool)</span><br><span class="line">        self.driver.flatten(image_id, pool=parent_pool)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.cleanup_direct_snapshot(location)</span><br><span class="line">    self.driver.create_snap(image_id, <span class="string">'snap'</span>, pool=parent_pool,</span><br><span class="line">                            protect=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">'rbd://%(fsid)s/%(pool)s/%(image)s/snap'</span> %</span><br><span class="line">            dict(fsid=fsid, pool=parent_pool, image=image_id))</span><br></pre></td></tr></table></figure><p>这个函数本质上还是一层封装，最终调用<code>rbd</code>驱动提供的<code>clone</code>、<code>create_snap</code>、<code>flatten</code>方法返回一个location给glance。</p><p>总结一下，nova创建快照功能是交给底层对应的驱动来处理的，然后调用glance接口创建一条数据最后更新location字段即可。这里多说一句，如果镜像文件特别大的时候使用glance进行同步特别慢，可以参考这里的思路进行优化，使用ceph提供的功能复制后新增glance中的数据即可。</p><p><a href="/2019/12/09/OpenStack源码学习笔记4/#post-footer" class="postShorten-excerpt_link link">评论和分享</a></p></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/12/03/如何更好的code-review/">如何更好的Code Review</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-12-03T11:05:03+08:00">12月 03, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p><a href="https://levelup.gitconnected.com/how-to-do-good-code-reviews-ee481f73b11b" target="_blank" rel="noopener">原文</a>，向原作者表示感谢。不过不知道作者是不是在国内学过作文，让我想起了小学时老师教的作文要多引用名人名言哈哈。</p><hr><p>几年前当我还是个菜鸟的时候，我过得十分潇洒。</p><p>写代码——交给别人review——改代码，绳命是多磨美好！工作内容就是仔细阅读我收到的评论、建议，学着成为一个更优秀的开发者。如今我成长为了一名高级开发人员，给别人做code review成为了我的职责之一，这时我意识到我的经验还不足以完成这种职责转变。</p><p>每次给别人做code review时我都感觉到害怕，感觉自己像是一个骗子，很多问题都困扰着我：</p><p><em>我该给这行代码提建议吗？</em></p><p><em>应该有更好的办法写这段代码，我应该告诉他吗？</em></p><p><em>他会怎么想？他的经验比我丰富。</em></p><p><em>改了这一行代码会不会使程序崩溃？</em></p><p>这时我的导师给了我建议。</p><p>好的code review聚焦于获得额外的产出，而非仅仅是找到bug。别把review当做是审讯，而当做是一种提高代码质量、发现其他方案、增加学习能力以及加强友谊的办法。</p><p>作为reviewer，你对代码的反馈是将渴望贡献的开发者组建成社区的一种主要方法。通过培养一个活跃的社区，你将提升产品、团队、和人生的质量。</p><p>这里有一些做好code review的建议。</p><a href="/2019/12/03/如何更好的code-review/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/11/28/设计模式-适配器模式/">设计模式-适配器模式</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-11-28T16:58:08+08:00">11月 28, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/设计模式/">设计模式</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><h2 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h2><p>适配器模式目的就是不改变原有系统的基础上保留其提供的服务，向调用者提供新的接口服务，使得原本由于接口不兼容而不能一起工作的类可以一起工作。（简单说就是增加兼容性，复用已经存在的功能）</p><p>笔记本电脑的电源变压器就是这个原理，把交流电转换成直流电。或者把英文翻译成中文，都是适配器模式。</p><p>又分为2种：</p><ol><li>对象适配器模式</li><li>类适配器模式</li></ol><p>适配器虽好，但也不要乱用，如果能在设计阶段就统一就是最好的，适配器模式更像是一种补丁。</p><p>推荐使用基于组合的对象适配器模式，因为类适配器模式使用了继承增加了模块之间的耦合度，下面的例子就是对象适配器模式。</p><a href="/2019/11/28/设计模式-适配器模式/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/11/04/OpenStack源码学习笔记3/">OpenStack源码学习笔记3</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-11-04T12:46:29+08:00">11月 04, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Python/">Python</a>, <a class="category-link" href="/source/all-categories/Python/OpenStack/">OpenStack</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>最近看了下关于OpenStack如何统计更新CPU、内存、硬盘等硬件资源的部分，由于历史原因下面的代码来自<code>newton</code>版。</p><p>简单说，OpenStack先通过定时任务进行资源统计，入口代码位于<code>nova\compute\manager.py</code>中<code>ComputeManager</code>类的<code>update_available_resource</code>函数。默认情况下每分钟更新一次：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@periodic_task.periodic_task(spacing=CONF.update_resources_interval)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_available_resource</span><span class="params">(self, context)</span>:</span></span><br><span class="line">    <span class="string">"""See driver.get_available_resource()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Periodic process that keeps that the compute host's understanding of</span></span><br><span class="line"><span class="string">    resource availability and usage in sync with the underlying hypervisor.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param context: security context</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    compute_nodes_in_db = self._get_compute_nodes_in_db(context,</span><br><span class="line">                                                        use_slave=<span class="literal">True</span>)</span><br><span class="line">    nodenames = set(self.driver.get_available_nodes())</span><br><span class="line">    <span class="keyword">for</span> nodename <span class="keyword">in</span> nodenames:</span><br><span class="line">        self.update_available_resource_for_node(context, nodename)</span><br><span class="line"></span><br><span class="line">    self._resource_tracker_dict = &#123;</span><br><span class="line">        k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> self._resource_tracker_dict.items()</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> nodenames&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delete orphan compute node not reported by driver but still in db</span></span><br><span class="line">    <span class="keyword">for</span> cn <span class="keyword">in</span> compute_nodes_in_db:</span><br><span class="line">        <span class="keyword">if</span> cn.hypervisor_hostname <span class="keyword">not</span> <span class="keyword">in</span> nodenames:</span><br><span class="line">            LOG.info(_LI(<span class="string">"Deleting orphan compute node %s"</span>), cn.id)</span><br><span class="line">            cn.destroy()</span><br></pre></td></tr></table></figure><p>首先获取所有节点，然后维护了一个名为<code>_resource_tracker_dict</code>的字典用来记录host和<code>ResourceTracker</code>实例的对应关系，所有的资源更新行为都在<code>ResourceTracker</code>中进行处理。</p><a href="/2019/11/04/OpenStack源码学习笔记3/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/10/28/设计模式-单例模式/">设计模式-单例模式</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-10-28T16:58:08+08:00">10月 28, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/设计模式/">设计模式</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h2><p>单例模式可以说是最容易理解的一种设计模式了，当需要某个类仅有一个全局唯一对象时可以使用，比如某些配置项。核心思想就是新建某个类实例时先进行一次判断，如果不存在则创建新实例返回，否则返回已经存在的实例。</p><a href="/2019/10/28/设计模式-单例模式/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/10/14/设计模式-原型模式/">设计模式-原型模式</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-10-14T17:58:08+08:00">10月 14, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/设计模式/">设计模式</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>原型模式(Prototype Pattern)：使用原型实例创建指定创建对象的种类，并通过拷贝这些原型创建新对象。这个模式很好理解，就是<code>ctrl+c，ctrl+v</code>后做一些小修改。</p><p>这里面涉及一个知识点就是深拷贝和浅拷贝的问题，但我相信任何python开发人员都知道<code>copy()</code>和<code>deepcopy()</code>的区别，这里就不多说了（有兴趣的可以去看python中这2个函数的实现）。</p><p>个人理解当需要多个类对象时，如果要进行很多复杂的、消耗时间的初始化操作，而这些对象之间又仅有少量不同时，可以考虑使用原型模式。</p><a href="/2019/10/14/设计模式-原型模式/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/10/12/设计模式-建造者模式/">设计模式-建造者模式</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-10-12T16:58:08+08:00">10月 12, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/设计模式/">设计模式</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>建造者模式(Builder Pattern)：将复杂对象的创建和表示分离，使同样的构建过程可以创建不同的表示。</p><p>进一步说，建造者隐藏了产品是如何组装的，使建造代码和表示代码分离。建造对象时 <strong>构件顺序稳定</strong> 的情况下，不管每一步具体怎么变都可以适用。</p><p>简单说，建造者模式将需要一系列动作才能完成的事固化下来，并定义了一个Director给客户端使用。还是很抽象的话，想想如何把大象装进冰箱：</p><ol><li>打开冰箱门</li><li>把大象装进去</li><li>关上冰箱门</li></ol><p>这个步骤比较简单，但如果细化一下：买冰箱、接通电源、买大象、清洗大象……很可能就会有300个步骤。建造者模式则提供了一系列行为的集合，保证以后有把山羊装进冰箱这样的需求时候不会遗漏某个步骤（想想KFC、麦当劳生产食品的步骤，其实是建造者模式不错的例子）。</p><a href="/2019/10/12/设计模式-建造者模式/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/10/09/设计模式-工厂模式/">设计模式-工厂模式</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-10-09T16:58:08+08:00">10月 09, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/设计模式/">设计模式</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>工厂模式又可以分为工厂方法模式和抽象工厂模式。</p><h2 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式(Factory Method Pattern)"></a>工厂方法模式(Factory Method Pattern)</h2><p>工厂模式是指：定义一个接口用户创建对象，让子类决定实例化哪一个类。</p><p>工厂模式中存在4个角色：</p><ol><li>抽象工厂</li><li>具体工厂</li><li>抽象产品</li><li>具体产品</li></ol><p><strong>抽象工厂产生抽象产品，具体工厂生产具体产品。</strong> 这句话很重要，理解了这句话就理解了工厂方法模式。</p><a href="/2019/10/09/设计模式-工厂模式/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/10/08/设计模式-总览/">设计模式-总览</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-10-08T16:58:08+08:00">10月 08, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/设计模式/">设计模式</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>很久很久以前，忘记从哪看到一句话——设计模式是对编程语言缺陷的弥补。</p><p>年轻的我并没意识到这句话背后的真实含义以及所处语境，外加之后主要开发语言是Python这个动态语言，设计模式真的没怎么用到——比如装饰模式不就是Python中的装饰器嘛，一个语法糖能解决的事居然还弄出个模式来？</p><p>直到我开始学习openstack的源码，发现里面用到了大量的设计模式，才明白自己是多么无知可笑。</p><p>这里借用一位大佬的话：</p><blockquote><p>如果你觉得设计模式在某程度上没用，说明两个问题：<br>1.你的系统还不足以复杂到要用设计模式的程度<br>2.你的经验还没强到能熟练应用设计模式的程度。</p></blockquote><p>能找到这篇文章的，应该都知道面向过程、面向对象、封装继承多态、高内聚低耦合（包含程序级别以及架构级别）、开闭原则(对扩展开放、对修改关闭)、依赖倒置原则(尽量使用抽象类型作为对象实例变量类型，用于实现开闭原则)、单一责任原则(一个模块只负责一个功能)等一堆的名词，以及“组合优于继承”(这里略有争议，我个人对此赞同，最近看一些继承过多的代码总是要向上找好几层父类，还要仔细看子类中有没有重写父类方法，术语叫做类膨胀)。</p><a href="/2019/10/08/设计模式-总览/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><article class="postShorten postShorten--thumbnailimg-right" itemscope itemtype="http://schema.org/BlogPosting"><div class="postShorten-wrap"><div class="postShorten-header"><h1 class="postShorten-title" itemprop="headline"><a class="link-unstyled" href="/2019/09/18/OpenStack源码学习笔记2/">OpenStack源码学习笔记2</a></h1><div class="postShorten-meta"><time itemprop="datePublished" datetime="2019-09-18T12:46:29+08:00">9月 18, 2019 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Python/">Python</a>, <a class="category-link" href="/source/all-categories/Python/OpenStack/">OpenStack</a></div></div><div class="postShorten-excerpt" itemprop="articleBody"><p>上次学习了Nova创建虚拟机的过程，这次来看一下Glance是如何上传镜像的。相比于Nova，Glance源码使用了大量的代理模式和装饰器模式，阅读代码时候一个不仔细就会一脸懵X。根据上次说的Openstack套路，我们通过<code>setup.cfg</code>直奔主题——<code>glance/cmd/api.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        config.parse_args()</span><br><span class="line">        config.set_config_defaults()</span><br><span class="line">        wsgi.set_eventlet_hub()</span><br><span class="line">        logging.setup(CONF, <span class="string">'glance'</span>)</span><br><span class="line">        notifier.set_defaults()</span><br><span class="line">        <span class="keyword">if</span> cfg.CONF.profiler.enabled:</span><br><span class="line">            _notifier = osprofiler.notifier.create(<span class="string">"Messaging"</span>,</span><br><span class="line">                                                   oslo_messaging, &#123;&#125;,</span><br><span class="line">                                                   notifier.get_transport(),</span><br><span class="line">                                                   <span class="string">"glance"</span>, <span class="string">"api"</span>,</span><br><span class="line">                                                   cfg.CONF.bind_host)</span><br><span class="line">            osprofiler.notifier.set(_notifier)</span><br><span class="line">            osprofiler.web.enable(cfg.CONF.profiler.hmac_keys)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            osprofiler.web.disable()</span><br><span class="line">        server = wsgi.Server(initialize_glance_store=<span class="literal">True</span>)</span><br><span class="line">        server.start(config.load_paste_app(<span class="string">'glance-api'</span>), default_port=<span class="number">9292</span>)</span><br><span class="line">        server.wait()</span><br><span class="line">    <span class="keyword">except</span> KNOWN_EXCEPTIONS <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        fail(e)</span><br></pre></td></tr></table></figure><a href="/2019/09/18/OpenStack源码学习笔记2/" class="postShorten-excerpt_link link">阅读全文</a></div></div></article><div class="pagination-bar"><ul class="pagination"><li class="pagination-next"><a class="btn btn--default btn--small" href="/page/2/"><span>下一页</span> <i class="fa fa-angle-right text-base icon-ml"></i></a></li><li class="pagination-number">第 1 页 共 23 页</li></ul></div></section><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2019 Roy. All Rights Reserved.</span></footer></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-remove"></i></div><img id="about-card-picture" src="/assets/images/my.jpg" alt="作者的图片"><h4 id="about-card-name">Roy</h4><div id="about-card-bio"><p>君以国士待我，我必以国士报君。</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>野生程序猿</p></div><div id="about-card-location"><i class="fa fa-map-marker"></i><br>China</div></div></div><div id="algolia-search-modal" class="modal-container"><div class="modal"><div class="modal-header"><span class="close-button"><i class="fa fa-close"></i></span> <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled"><span class="searchby-algolia-text text-color-light text-small">by</span> <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg"> </a><i class="search-icon fa fa-search"></i><form id="algolia-search-form"><input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search "></form></div><div class="modal-body"><div class="no-result text-color-light text-center">没有找到文章</div><div class="results"><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/02/12/Ubuntu下Gogant的简易破墙术/"><h3 class="media-heading">Ubuntu下Gogant的简易破墙术</h3></a><span class="media-meta"><span class="media-date text-small">2013年2月12日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/10/31/python常用第三方库-转载/"><h3 class="media-heading">Python常用第三方库(转载)</h3></a><span class="media-meta"><span class="media-date text-small">2013年10月31日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19安装ar8161网卡驱动/"><h3 class="media-heading">fedora19安装ar8161网卡驱动</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19源，rpmforge，fastestmirror/"><h3 class="media-heading">fedora19源，rpmforge，fastestmirror</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/python中如何自定义解析域名/"><h3 class="media-heading">python中如何自定义解析域名</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django版本更换/"><h3 class="media-heading">django版本更换</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django-groundwork个人1-5-3修改版/"><h3 class="media-heading">django-groundwork个人1.5.3修改版</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19美化/"><h3 class="media-heading">fedora19美化</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/装饰器/"><h3 class="media-heading">装饰器</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/SVN常用操作/"><h3 class="media-heading">SVN常用操作</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div></div></div><div class="modal-footer"><p class="results-count text-medium" data-message-zero="没有找到文章" data-message-one="找到 1 篇文章" data-message-other="找到 {n} 篇文章">找到 224 篇文章</p></div></div></div><div id="cover" style="background-image:url(/assets/images/cover.jpg)"></div><script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script><script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><script>var algoliaClient=algoliasearch("51U8PIBLP6","16909d9ce1780cda71113841864e7aa8"),algoliaIndex=algoliaClient.initIndex("my-blog")</script></body></html>