<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Hi!Roy!"><title>200行GO代码实现区块链1 - Hi!Roy!</title><meta name="author" content="Roy"><link rel="icon" href="http://www.hi-roy.com/assets/images/favicon.ico"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><meta name="description" content="原文，需要科学上网。省略了一些无关的内容。世界上很多开发者听说过区块链却不知道它是怎么工作的，他们或许仅仅听过比特币或者智能合约一类的名词。这篇文章尝试用简明的语言说明区块链并且用不到200行的代码来实现你自己的区块链！文章的最后，你应该可以运行并且添加区块到区块链中并从浏览器中看到结果。有什么学习区块链的方法比你亲自实现一个更好呢？文章讲了什么如何创建自己的区块链如何使用Hash来维护区块链的完"><meta name="keywords" content="区块链,go"><meta property="og:type" content="blog"><meta property="og:title" content="200行GO代码实现区块链1"><meta property="og:url" content="http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/index.html"><meta property="og:site_name" content="Hi!Roy!"><meta property="og:description" content="原文，需要科学上网。省略了一些无关的内容。世界上很多开发者听说过区块链却不知道它是怎么工作的，他们或许仅仅听过比特币或者智能合约一类的名词。这篇文章尝试用简明的语言说明区块链并且用不到200行的代码来实现你自己的区块链！文章的最后，你应该可以运行并且添加区块到区块链中并从浏览器中看到结果。有什么学习区块链的方法比你亲自实现一个更好呢？文章讲了什么如何创建自己的区块链如何使用Hash来维护区块链的完"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="http://mypic-1252424367.coshk.myqcloud.com/block1.png"><meta property="og:image" content="http://mypic-1252424367.coshk.myqcloud.com/block2.png"><meta property="og:image" content="http://mypic-1252424367.coshk.myqcloud.com/block3.png"><meta property="og:image" content="http://mypic-1252424367.coshk.myqcloud.com/block4.png"><meta property="og:image" content="http://mypic-1252424367.coshk.myqcloud.com/block5.png"><meta property="og:image" content="http://mypic-1252424367.coshk.myqcloud.com/block6.png"><meta property="og:updated_time" content="2019-09-16T08:11:51.450Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="200行GO代码实现区块链1"><meta name="twitter:description" content="原文，需要科学上网。省略了一些无关的内容。世界上很多开发者听说过区块链却不知道它是怎么工作的，他们或许仅仅听过比特币或者智能合约一类的名词。这篇文章尝试用简明的语言说明区块链并且用不到200行的代码来实现你自己的区块链！文章的最后，你应该可以运行并且添加区块到区块链中并从浏览器中看到结果。有什么学习区块链的方法比你亲自实现一个更好呢？文章讲了什么如何创建自己的区块链如何使用Hash来维护区块链的完"><meta name="twitter:image" content="http://mypic-1252424367.coshk.myqcloud.com/block1.png"><meta property="og:image" content="http://www.hi-roy.com/assets/images/my.jpg"><link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?21513ec2bcd577b3297a1b16da82fa40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div id="blog"><header id="header" data-behavior="4"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/">Hi!Roy!</a></div><a class="header-right-icon" href="#about"><i class="fa fa-lg fa-question"></i></a></header><nav id="sidebar" data-behavior="4"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about"><img class="sidebar-profile-picture" src="/assets/images/my.jpg" alt="作者的图片"></a><h4 class="sidebar-profile-name">Roy</h4><h5 class="sidebar-profile-bio"><p>君以国士待我，我必以国士报君。</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/"><i class="sidebar-button-icon fa fa-lg fa-home"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories"><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags"><i class="sidebar-button-icon fa fa-lg fa-tags"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives"><i class="sidebar-button-icon fa fa-lg fa-archive"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link open-algolia-search" href="#search"><i class="sidebar-button-icon fa fa-lg fa-search"></i> <span class="sidebar-button-desc">搜索</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about"><i class="sidebar-button-icon fa fa-lg fa-question"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/shenyushun" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-github"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:darkcooking@gmail.com" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml"><i class="sidebar-button-icon fa fa-lg fa-rss"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div id="main" data-behavior="4" class="hasCoverMetaIn"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><div class="post-header main-content-wrap text-left"><h1 class="post-title" itemprop="headline">200行GO代码实现区块链1</h1><div class="post-meta"><time itemprop="datePublished" datetime="2018-05-18T14:42:11+08:00">5月 18, 2018 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/区块链/">区块链</a>, <a class="category-link" href="/source/all-categories/区块链/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/区块链/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="post-content markdown" itemprop="articleBody"><div class="main-content-wrap"><p><a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc" target="_blank" rel="noopener">原文</a>，需要科学上网。省略了一些无关的内容。</p><p>世界上很多开发者听说过区块链却不知道它是怎么工作的，他们或许仅仅听过比特币或者智能合约一类的名词。这篇文章尝试用简明的语言说明区块链并且用不到200行的代码来实现你自己的区块链！文章的最后，你应该可以运行并且添加区块到区块链中并从浏览器中看到结果。</p><p>有什么学习区块链的方法比你亲自实现一个更好呢？</p><p><strong>文章讲了什么</strong></p><ul><li>如何创建自己的区块链</li><li>如何使用Hash来维护区块链的完整性</li><li>如何添加新区块</li><li>如何解决多个节点同时生成区块导致冲突问题</li><li>如何在浏览器中查看区块链</li><li>如何生成新区块</li><li>了解区块链的基础知识后，你可以决定你的未来发展方向</li></ul><p><strong>文章没讲什么</strong></p><p>为了保持简单，我们并没介绍更高级的概念比如pow和pos的对比，我们模拟了网络交互所以你可以看到区块链并且添加区块，但网络广播部分将以后再讲。</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>因为我们使用GO，所以假设你已经是一个有经验的GO开发者了。安装并设置GO开发环境后，需要安装下面的三方包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/davecgh/<span class="keyword">go</span>-spew/spew</span><br></pre></td></tr></table></figure><p><code>spew</code>可以更好的输出<code>struct</code>和<code>slices</code>，你值得拥有。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/gorilla/mux</span><br></pre></td></tr></table></figure><p><code>mux</code>是一个流行的web服务框架，我们需要这个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/joho/godotenv</span><br></pre></td></tr></table></figure><p><code>godotenv</code>让我们从根目录的<code>.env</code>文件读取配置信息，这样http端口一类的配置就不需要硬编码在代码中了。</p><p>让我们在根目录创建一个<code>.env</code>文件，里面定义我们http服务的端口，内容就一行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDR=8080</span><br></pre></td></tr></table></figure><p></p><p>再创建一个<code>main.go</code>文件，所有的代码都将写在这里并且不会超过200行，让我们开始吧！</p><h3 id="imports"><a href="#imports" class="headerlink" title="imports"></a>imports</h3><p>首先引入我们需要的库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/sha256"</span></span><br><span class="line">	<span class="string">"encoding/hex"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">	<span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">	<span class="string">"github.com/joho/godotenv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>接下来定义一个struct作为区块，别担心，我们下面将解释每一个字段的作用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Index     <span class="keyword">int</span></span><br><span class="line">	Timestamp <span class="keyword">string</span></span><br><span class="line">	BPM       <span class="keyword">int</span></span><br><span class="line">	Hash      <span class="keyword">string</span></span><br><span class="line">	PrevHash  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个Block中的数据都会写入到区块链中：</p><ul><li><code>Index</code>表示区块在区块链中的位置</li><li><code>Timestamp</code>是自动生成的并记录了数据写入时间</li><li><code>BPM</code>表示每分钟心跳次数</li><li><code>Hash</code>是sha256加密后的数据</li><li><code>PrevHash</code>表示前一个区块的Hash值</li></ul><p>接下来，定义一个由Block组成的slices:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br></pre></td></tr></table></figure><p>那么是如何把区块组成区块链的呢？我们使用Hash值来识别和保证区块的顺序正确。确保每个块中的<code>PrevHash</code>和前一个区块中的<code>Hash</code>一样，这样我们就知道了区块链的顺序。</p><p><img src="http://mypic-1252424367.coshk.myqcloud.com/block1.png" alt="pic1"></p><h3 id="Hashing和创建新区块"><a href="#Hashing和创建新区块" class="headerlink" title="Hashing和创建新区块"></a>Hashing和创建新区块</h3><p>为什么需要进行Hash？主要有２个原因：</p><ul><li>节省空间。Hash结果是由区块中全部数据计算产生的，在我们这个例子中仅仅有少量数据，但想象一下如果一个区块中有成百上千的数据，记录数据hash后的结果显然比一次又一次的拷贝全部数据更加高效。</li><li>保持区块链完整性。如上图，通过记录上一个区块的Hash值，我们能够确保区块链的顺序是正确的。如果有人恶意写入数据(比如想修改心跳来影响保险价格)，hash值将被改变而且区块链将被”打破”，并且每个人都能知道并且不信任那个恶意的链条。</li></ul><p>现在创建一个函数来计算区块的Hash值：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">	h := sha256.New()</span><br><span class="line">	h.Write([]<span class="keyword">byte</span>(record))</span><br><span class="line">	hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>calculateHash</code>函数将<code>Index</code>、<code>Timestamp</code>、<code>BPM</code>、<code>PrevHash</code>链接成一个字符串并返回其SHA256后的结果。现在我们可以使用这些参数通过<code>generateBlock</code>函数创建一个新区块了。我们需要传入前一个区块和BPM值，不用担心这个BPM我们晚一些解释：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">	t := time.Now()</span><br><span class="line"></span><br><span class="line">	newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">	newBlock.Timestamp = t.String()</span><br><span class="line">	newBlock.BPM = BPM</span><br><span class="line">	newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">	newBlock.Hash = calculateHash(newBlock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意时间是使用<code>time.now()</code>自动创建的并且我们调用了之前写的<code>calculateHash</code>函数，PrevHash直接从前一个区块中拷贝出来，Index则是根据前一个区块的值自增１。</p><h3 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h3><p>现在我们需要写一些函数来确保区块链的真实性，通过检测Index来确保正确的自增，还需要检测PrevHash和前一个区块的Hash是否相同。最后我们再次使用<code>calculateHash</code>函数检查当前区块的Hash值。现在写一个<code>isBlockValid</code>函数并且返回<code>bool</code>类型，如果通过了全部的检查则返回<code>true</code>：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> calculateHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果有２个节点同时计算出正确的Hash值并且添加到各自的区块链中，那么我们该相信哪一条呢？我们选择最长的那条。这在区块链中是一个很典型的问题，并且坏人也无计可施。</p><p>节点很容易产生不同长度的链，自然而言的最长的链条有最新的数据和最后一个区块。所以我们需要确保拥有最长的链条，这样做我们可以使用最新的区块链来覆盖原来的。</p><p><img src="http://mypic-1252424367.coshk.myqcloud.com/block2.png" alt="img2"></p><p>通过简单的长度比较来实现这个功能：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceChain</span><span class="params">(newBlocks []Block)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(newBlocks) &gt; <span class="built_in">len</span>(Blockchain) &#123;</span><br><span class="line">		Blockchain = newBlocks</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>恭喜！我们已经完成了所需要的基本函数，接下来我们想要一种简单的方法来查看和添加新区块。</p><p>###　web服务<br>我们假设你已经很熟悉web服务是如何工作的并且会使用GO来实现，接下来将使用<code>mux</code>包来创建web服务：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	mux := makeMuxRouter()</span><br><span class="line">	httpAddr := os.Getenv(<span class="string">"ADDR"</span>)</span><br><span class="line">	log.Println(<span class="string">"Listening on "</span>, os.Getenv(<span class="string">"ADDR"</span>))</span><br><span class="line">	s := &amp;http.Server&#123;</span><br><span class="line">		Addr:           <span class="string">":"</span> + httpAddr,</span><br><span class="line">		Handler:        mux,</span><br><span class="line">		ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">		WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := s.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里使用了之前在<code>.env</code>文件中定义的端口，并且通过<code>log.Println</code>输出一条消息来表明服务已经运行。</p><p>现在我们需要实现<code>makeMuxRouter</code>函数，为了实现在浏览器中读和写我们的区块链，我们需要２个简单的路由规则。<code>GET</code>请求来查看<code>POST</code>请求来创建新区块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMuxRouter</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	muxRouter := mux.NewRouter()</span><br><span class="line">	muxRouter.HandleFunc(<span class="string">"/"</span>, handleGetBlockchain).Methods(<span class="string">"GET"</span>)</span><br><span class="line">	muxRouter.HandleFunc(<span class="string">"/"</span>, handleWriteBlock).Methods(<span class="string">"POST"</span>)</span><br><span class="line">	<span class="keyword">return</span> muxRouter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理GET请求的函数如下:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGetBlockchain</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	bytes, err := json.MarshalIndent(Blockchain, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	io.WriteString(w, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们简单的使用json格式返回全部的区块链，当访问浏览器的<code>localhost:8080</code>端口时候我们可以看到结果。 如果你修改了<code>.env</code>文件中的<code>ADDR</code>，确保你访问的端口正确。</p><p>POST请求相对复杂一点，我们需要一个新结构体叫做<code>Message</code>，晚点解释为什么需要它:<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	BPM <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>处理这种请求的函数如下，我们晚点解释：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWriteBlock</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m Message</span><br><span class="line"></span><br><span class="line">	decoder := json.NewDecoder(r.Body)</span><br><span class="line">	<span class="keyword">if</span> err := decoder.Decode(&amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		respondWithJSON(w, r, http.StatusBadRequest, r.Body)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line">	newBlock, err := generateBlock(Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>], m.BPM)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		respondWithJSON(w, r, http.StatusInternalServerError, m)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isBlockValid(newBlock, Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]) &#123;</span><br><span class="line">		newBlockchain := <span class="built_in">append</span>(Blockchain, newBlock)</span><br><span class="line">		replaceChain(newBlockchain)</span><br><span class="line">		spew.Dump(Blockchain)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	respondWithJSON(w, r, http.StatusCreated, newBlock)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为我们需要使用新结构体来接受来自POST请求的JSON数据，这样我们就可以简单的通过发送POST请求并附带下面这种数据来生成新区块了：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"BPM"</span>:<span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p>50是一个心跳次数的例子，你可以随意替换。</p><p>当我们从请求的body中解码出数据到<code>var m Message</code>中，我们通过调用<code>generateBlock</code>函数并传递前一个区块和心跳次数作为参数来创建一个新区块。然后通过<code>isBlockValid</code>函数来进行验证。</p><p>２点说明：</p><ol><li><code>spwe.Dump</code>　是一个转换函数可以在命令行中输出好看的结构体，这对于调试十分有用。</li><li>为了测试POST请求，我们喜欢使用postman，如果你喜欢使用终端<code>curl</code>也是不错的选择。</li></ol><p>不管请求是否成功，我们都想收到通知。同样写一个函数来让我们知道发生了什么。记住，在GO语言中，永远不要忽略了<code>error</code>，要 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">优雅的处理它们</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">respondWithJSON</span><span class="params">(w http.ResponseWriter, r *http.Request, code <span class="keyword">int</span>, payload <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	response, err := json.MarshalIndent(payload, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP 500: Internal Server Error"</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.WriteHeader(code)</span><br><span class="line">	w.Write(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们完成<code>main</code>函数：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := godotenv.Load()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line">		genesisBlock := Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>&#125;</span><br><span class="line">		spew.Dump(genesisBlock)</span><br><span class="line">		Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line">	&#125;()</span><br><span class="line">	log.Fatal(run())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个函数都做什么了呢？</p><ul><li><code>godotenv.Load()</code>可以让我们从根目录<code>.env</code>文件中读取类似端口这种变量，这样就不用硬编码了。</li><li><code>genesisBlock</code>是<code>main</code>函数中最重要的部分，我们需要一个创世块，否则新的区块链就没有前一个区块的Hash了。</li><li>我们分离了生成区块的代码到goroutine中，也就是分离区块链逻辑和web服务逻辑。</li></ul><p><strong>哈！完成了！</strong></p><p>完整代码在 <a href="https://github.com/mycoralhealth/blockchain-tutorial/blob/master/main.go" target="_blank" rel="noopener">这里</a>。</p><p>娱乐时间到，让我们试试。</p><p>打开终端并运行<code>go run main.go</code>，我们可以看到web服务启动并生成了一个区块：</p><p><img src="http://mypic-1252424367.coshk.myqcloud.com/block3.png" alt="b3"></p><p>在浏览器中访问本机端口，我们使用8080，同样的我们看到相同的区块：<br><img src="http://mypic-1252424367.coshk.myqcloud.com/block4.png" alt="b4"></p><p>接下来发送post请求生成区块：<br><img src="http://mypic-1252424367.coshk.myqcloud.com/block5.png" alt="b5"></p><p>刷新浏览器，我们将看到区块链中有新的区块并且<code>PrevHash</code>值等于老区块的<code>Hash</code>值，一切都在预料中！<br><img src="http://mypic-1252424367.coshk.myqcloud.com/block6.png" alt="b6"></p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>恭喜，你已经完成了有Hash和验证功能你的区块链！你现在可以去探索更高级的主题比如:工作量证明、权益证明、智能合约、分布式app、边链等等。这篇文章并没有处理结合工作量证明挖矿的问题。这应该写一个单独的文章，并且很多区块链并没有使用工作量证明。此外网络广播部分现在是通过web服务模拟的，本文中没涉及到Ｐ２Ｐ相关知识。</p></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-link" href="/source/all-tags/go/">go</a> <a class="tag tag--primary tag--small t-link" href="/source/all-tags/区块链/">区块链</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2018/05/21/200行GO代码实现区块链2/" data-tooltip="200行GO代码实现区块链2"><i class="fa fa-angle-left"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2018/05/14/区块链学习笔记1/" data-tooltip="区块链学习笔记1"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions"><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-google-plus"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-weibo"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/&amp;title=200行GO代码实现区块链1"><i class="fa fa-qq"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-star"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-renren"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#"><i class="fa fa-list"></i></a></li></ul></div></div></article><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2019 Roy. All Rights Reserved.</span></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="4"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2018/05/21/200行GO代码实现区块链2/" data-tooltip="200行GO代码实现区块链2"><i class="fa fa-angle-left"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2018/05/14/区块链学习笔记1/" data-tooltip="区块链学习笔记1"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions"><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-google-plus"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-weibo"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/&amp;title=200行GO代码实现区块链1"><i class="fa fa-qq"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-star"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-renren"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#"><i class="fa fa-list"></i></a></li></ul></div></div><div id="share-options-bar" class="share-options-bar" data-behavior="4"><i id="btn-close-shareoptions" class="fa fa-close"></i><ul class="share-options"><li class="share-option"><a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-facebook-official"></i><span>分享到 Facebook</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-twitter"></i><span>分享到 Twitter</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-google-plus"></i><span>分享到 Google+</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-weibo"></i><span>分享到 Weibo</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/&amp;title=200行GO代码实现区块链1"><i class="fa fa-qq"></i><span>分享到 QQ</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-star"></i><span>分享到 Qzone</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2018/05/18/200行GO代码实现区块链1/"><i class="fa fa-renren"></i><span>分享到 Renren</span></a></li></ul></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-remove"></i></div><img id="about-card-picture" src="/assets/images/my.jpg" alt="作者的图片"><h4 id="about-card-name">Roy</h4><div id="about-card-bio"><p>君以国士待我，我必以国士报君。</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>野生程序猿</p></div><div id="about-card-location"><i class="fa fa-map-marker"></i><br>China</div></div></div><div id="algolia-search-modal" class="modal-container"><div class="modal"><div class="modal-header"><span class="close-button"><i class="fa fa-close"></i></span> <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled"><span class="searchby-algolia-text text-color-light text-small">by</span> <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg"> </a><i class="search-icon fa fa-search"></i><form id="algolia-search-form"><input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search "></form></div><div class="modal-body"><div class="no-result text-color-light text-center">没有找到文章</div><div class="results"><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/02/12/Ubuntu下Gogant的简易破墙术/"><h3 class="media-heading">Ubuntu下Gogant的简易破墙术</h3></a><span class="media-meta"><span class="media-date text-small">2013年2月12日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/10/31/python常用第三方库-转载/"><h3 class="media-heading">Python常用第三方库(转载)</h3></a><span class="media-meta"><span class="media-date text-small">2013年10月31日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19安装ar8161网卡驱动/"><h3 class="media-heading">fedora19安装ar8161网卡驱动</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19源，rpmforge，fastestmirror/"><h3 class="media-heading">fedora19源，rpmforge，fastestmirror</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/python中如何自定义解析域名/"><h3 class="media-heading">python中如何自定义解析域名</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django版本更换/"><h3 class="media-heading">django版本更换</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django-groundwork个人1-5-3修改版/"><h3 class="media-heading">django-groundwork个人1.5.3修改版</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19美化/"><h3 class="media-heading">fedora19美化</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/装饰器/"><h3 class="media-heading">装饰器</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/SVN常用操作/"><h3 class="media-heading">SVN常用操作</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div></div></div><div class="modal-footer"><p class="results-count text-medium" data-message-zero="没有找到文章" data-message-one="找到 1 篇文章" data-message-other="找到 {n} 篇文章">找到 225 篇文章</p></div></div></div><div id="cover" style="background-image:url(/assets/images/cover.jpg)"></div><script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script><script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><script>var algoliaClient=algoliasearch("51U8PIBLP6","16909d9ce1780cda71113841864e7aa8"),algoliaIndex=algoliaClient.initIndex("my-blog")</script></body></html>