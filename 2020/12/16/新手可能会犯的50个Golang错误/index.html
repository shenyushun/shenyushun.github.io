<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Hi!Roy!"><title>新手可能会犯的50个Golang错误 - Hi!Roy!</title><meta name="author" content="Roy"><link rel="icon" href="http://www.hi-roy.com/assets/images/favicon.ico"><link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml"><meta name="description" content="原文，向原作者表示感谢。这里省略了一些无关的介绍说明以及过于简单的说明，直接看代码就懂了。左花括号不能单独一行在大多数语言中你可以随便放置花括号的位置，但go语言不一样，你可以理解为为go会自动注入分号（automatic semicolon injection）：错误代码：12345678package mainimport &quot;fmt&quot;func main()  &amp;#123; //error, c"><meta name="keywords" content="go"><meta property="og:type" content="blog"><meta property="og:title" content="新手可能会犯的50个Golang错误"><meta property="og:url" content="http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/index.html"><meta property="og:site_name" content="Hi!Roy!"><meta property="og:description" content="原文，向原作者表示感谢。这里省略了一些无关的介绍说明以及过于简单的说明，直接看代码就懂了。左花括号不能单独一行在大多数语言中你可以随便放置花括号的位置，但go语言不一样，你可以理解为为go会自动注入分号（automatic semicolon injection）：错误代码：12345678package mainimport &quot;fmt&quot;func main()  &amp;#123; //error, c"><meta property="og:locale" content="zh-cn"><meta property="og:updated_time" content="2021-01-15T12:59:54.033Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="新手可能会犯的50个Golang错误"><meta name="twitter:description" content="原文，向原作者表示感谢。这里省略了一些无关的介绍说明以及过于简单的说明，直接看代码就懂了。左花括号不能单独一行在大多数语言中你可以随便放置花括号的位置，但go语言不一样，你可以理解为为go会自动注入分号（automatic semicolon injection）：错误代码：12345678package mainimport &quot;fmt&quot;func main()  &amp;#123; //error, c"><meta property="og:image" content="http://www.hi-roy.com/assets/images/my.jpg"><link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?21513ec2bcd577b3297a1b16da82fa40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div id="blog"><header id="header" data-behavior="4"><i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i><div class="header-title"><a class="header-title-link" href="/">Hi!Roy!</a></div><a class="header-right-icon" href="#about"><i class="fa fa-lg fa-question"></i></a></header><nav id="sidebar" data-behavior="4"><div class="sidebar-container"><div class="sidebar-profile"><a href="/#about"><img class="sidebar-profile-picture" src="/assets/images/my.jpg" alt="作者的图片"></a><h4 class="sidebar-profile-name">Roy</h4><h5 class="sidebar-profile-bio"><p>君以国士待我，我必以国士报君。</p></h5></div><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/"><i class="sidebar-button-icon fa fa-lg fa-home"></i> <span class="sidebar-button-desc">首页</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-categories"><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i> <span class="sidebar-button-desc">分类</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-tags"><i class="sidebar-button-icon fa fa-lg fa-tags"></i> <span class="sidebar-button-desc">标签</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="/all-archives"><i class="sidebar-button-icon fa fa-lg fa-archive"></i> <span class="sidebar-button-desc">归档</span></a></li><li class="sidebar-button"><a class="sidebar-button-link open-algolia-search" href="#search"><i class="sidebar-button-icon fa fa-lg fa-search"></i> <span class="sidebar-button-desc">搜索</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="#about"><i class="sidebar-button-icon fa fa-lg fa-question"></i> <span class="sidebar-button-desc">关于</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="https://github.com/shenyushun" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-github"></i> <span class="sidebar-button-desc">GitHub</span></a></li><li class="sidebar-button"><a class="sidebar-button-link" href="mailto:darkcooking@gmail.com" target="_blank" rel="noopener"><i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i> <span class="sidebar-button-desc">邮箱</span></a></li></ul><ul class="sidebar-buttons"><li class="sidebar-button"><a class="sidebar-button-link" href="/atom.xml"><i class="sidebar-button-icon fa fa-lg fa-rss"></i> <span class="sidebar-button-desc">RSS</span></a></li></ul></div></nav><div id="main" data-behavior="4" class="hasCoverMetaIn"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><div class="post-header main-content-wrap text-left"><h1 class="post-title" itemprop="headline">新手可能会犯的50个Golang错误</h1><div class="post-meta"><time itemprop="datePublished" datetime="2020-12-16T21:32:59+08:00">12月 16, 2020 </time><span>发布在 </span><a class="category-link" href="/source/all-categories/Golang/">Golang</a>, <a class="category-link" href="/source/all-categories/Golang/菜鸟翻译屋/">菜鸟翻译屋</a></div></div><div class="post-content markdown" itemprop="articleBody"><div class="main-content-wrap"><p><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html" target="_blank" rel="noopener">原文</a>，向原作者表示感谢。这里省略了一些无关的介绍说明以及过于简单的说明，直接看代码就懂了。</p><h2 id="左花括号不能单独一行"><a href="#左花括号不能单独一行" class="headerlink" title="左花括号不能单独一行"></a>左花括号不能单独一行</h2><p>在大多数语言中你可以随便放置花括号的位置，但go语言不一样，你可以理解为为go会自动注入分号（automatic semicolon injection）：</p><p>错误代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//error, can't have the opening brace on a separate line</span></span><br><span class="line">    fmt.Println(<span class="string">"hello there!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/sandbox826898458/main.<span class="keyword">go</span>:<span class="number">6</span>: syntax error: unexpected semicolon or newline before &#123;</span><br></pre></td></tr></table></figure><p>正确代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"works!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="未使用的变量"><a href="#未使用的变量" class="headerlink" title="未使用的变量"></a>未使用的变量</h2><p>在go中如果有未使用的变量，即便对其进行了赋值，编译时也会报错。只有全局变量和函数参数可以声明而不使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gvar <span class="keyword">int</span> <span class="comment">//not an error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> one <span class="keyword">int</span>   <span class="comment">//error, unused variable</span></span><br><span class="line">    two := <span class="number">2</span>      <span class="comment">//error, unused variable</span></span><br><span class="line">    <span class="keyword">var</span> three <span class="keyword">int</span> <span class="comment">//error, even though it's assigned 3 on the next line</span></span><br><span class="line">    three = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(unused <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Unused arg. No compile error"</span>)</span><br><span class="line">    &#125;(<span class="string">"what?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未使用的包"><a href="#未使用的包" class="headerlink" title="未使用的包"></a>未使用的包</h2><p>如果引用了某个包而又不使用其中的任何函数、结构体、接口或者变量，则会编译报错。</p><p>如果真的需要引入这些包(Roy注：比如仅想执行这些包的init函数时)，可以使用<code>_</code>作为包的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    _ <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = log.Println</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简短声明的变量只能在函数内部使用"><a href="#简短声明的变量只能在函数内部使用" class="headerlink" title="简短声明的变量只能在函数内部使用"></a>简短声明的变量只能在函数内部使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">myvar := <span class="number">1</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用简短声明来重复声明变量"><a href="#使用简短声明来重复声明变量" class="headerlink" title="使用简短声明来重复声明变量"></a>使用简短声明来重复声明变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    one,two = two,one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="短声明不能用于给结构体赋值"><a href="#短声明不能用于给结构体赋值" class="headerlink" title="短声明不能用于给结构体赋值"></a>短声明不能用于给结构体赋值</h2><p>错误代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;  </span><br><span class="line">  result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>,error)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span>,<span class="literal">nil</span>  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data info</span><br><span class="line"></span><br><span class="line">  data.result, err := work() <span class="comment">//error</span></span><br><span class="line">  fmt.Printf(<span class="string">"info: %+v\n"</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译错误：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog.<span class="keyword">go</span>:<span class="number">18</span>: non-name data.result on left side of :=</span><br></pre></td></tr></table></figure><p></p><p>即使有方法可以解决这个问题，但go语言之父挺喜欢目前这样的。<br>可以使用临时变量或预先声明所有变量并使用标准赋值操作。</p><p>正确代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;  </span><br><span class="line">  result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>,error)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span>,<span class="literal">nil</span>  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data info</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> err error</span><br><span class="line">  data.result, err = work() <span class="comment">//ok</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"info: %+v\n"</span>,data) <span class="comment">//prints: info: &#123;result:13&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="意外的变量修改"><a href="#意外的变量修改" class="headerlink" title="意外的变量修改"></a>意外的变量修改</h2><p>短声明语法对于从动态语言转go的人来说太方便了，但很容易被误认为是赋值操作，如果你在新的代码块中犯了这个错误，编译不会报错，但也不会如预期那样工作：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    fmt.Println(x)     <span class="comment">//prints 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        fmt.Println(x) <span class="comment">//prints 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        fmt.Println(x) <span class="comment">//prints 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(x)     <span class="comment">//prints 1 (bad if you need 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>对于有一定经验的开发人员这都是一个常见的陷阱，而且很难调试出来。</strong></p><p>可以通过<code>go tool vet -shadow your_file.go</code>命令来进行检测，但注意<code>vet</code>命令并不能检测出所有被覆盖的变量，可以使用<a href="https://github.com/barakmich/go-nyet" target="_blank" rel="noopener">go-nyet</a>来进一步检测。(Roy注：这个已经集成到vet中了，这里仅仅为了保持原文)</p><h2 id="显式类型的变量无法使用nil来初始化"><a href="#显式类型的变量无法使用nil来初始化" class="headerlink" title="显式类型的变量无法使用nil来初始化"></a>显式类型的变量无法使用nil来初始化</h2><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用值为-nil-的-slice、map"><a href="#使用值为-nil-的-slice、map" class="headerlink" title="使用值为 nil 的 slice、map"></a>使用值为 nil 的 slice、map</h2><p>允许对值为<code>nil</code>的slice添加元素，但对值为<code>nil</code>的map添加元素则会造成运行时错误:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    m[<span class="string">"one"</span>] = <span class="number">1</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map容量"><a href="#map容量" class="headerlink" title="map容量"></a>map容量</h2><p>在创建map类型的变量时可以指定容量，但不能像slice一样使用 cap() 来检测分配空间的大小：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>,<span class="number">99</span>)</span><br><span class="line">    <span class="built_in">cap</span>(m) <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="string类型的变量值不能为nil"><a href="#string类型的变量值不能为nil" class="headerlink" title="string类型的变量值不能为nil"></a>string类型的变量值不能为nil</h2><p>string类型的初始值为””而不是<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">string</span> = <span class="literal">nil</span> <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">//error</span></span><br><span class="line">        x = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">string</span> <span class="comment">//defaults to "" (zero value)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">        x = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><p>如果是c或者c++程序，传递数组作为函数参数时是传指针，所以可以在函数内部对数组进行修改。而go中，传递的是值，是一份原始数组的拷贝。所以在函数内部对数组的修改无法影响到外部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x) <span class="comment">//prints [1 2 3] (not ok if you need [7 2 3])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要的话可以使用传递指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr) <span class="comment">//prints &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用slice，即便函数得到的是一份副本，但由于副本指向底层的指针和原来一样，所以可以修改数据：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x) <span class="comment">//prints [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(Roy注：这里需要了解一下slice的构造，由指向底层数组的指针、len、cap构成，但这个例子里如果超出cap引起底层数组变化，还是有问题。这里原意是修改里面的数据值，而非添加数据。)</p><h2 id="混淆了range遍历slice和array时的返回值"><a href="#混淆了range遍历slice和array时的返回值" class="headerlink" title="混淆了range遍历slice和array时的返回值"></a>混淆了range遍历slice和array时的返回值</h2><p>与其他编程语言中的<code>for-in</code>、<code>foreach</code>语句不同，go中的<code>range</code>在遍历时会返回2个值，第一个是元素索引，第二个是元素的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v) <span class="comment">//prints 0, 1, 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v) <span class="comment">//prints a, b, c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice和array是一维数据"><a href="#slice和array是一维数据" class="headerlink" title="slice和array是一维数据"></a>slice和array是一维数据</h2><p>看上去go中支持多维数组或切片，但实际上并不是。尽管可以创建多维数组或切片，但对于依赖动态多维数组的数值计算型程序，go是远远不够的。</p><p>可以使用原始的一维数组、“独立的”切片、“共享数据”的切片来创建动态的多维数组。</p><p>如果使用原始的一维数组，则需要在数组需要增长时负责索引、边界检查和内存重新分配。</p><p>使用独立的切片来创建动态多维数组分2步：首先创建一个外部切片，然后再分配每个内部切片。内部切片相互独立，所以可以独立的增大或减小他们而不互相影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>,x)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>,y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用共享数据的切片来创建动态多维数组分3步：首先创建一个数据容器切片来存储所有数据，然后创建外部切片，最后切割原始的容器切片来初始化内部切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">int</span>,h*w)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(raw,&amp;raw[<span class="number">4</span>])</span><br><span class="line">    <span class="comment">//prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>,h)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = raw[i*w:i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table,&amp;table[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//prints: [[0 1 2 3] [4 5 6 7]] &lt;ptr_addr_x&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前有增加多维数组和切片的提议，不过优先级比较低。</p><h2 id="访问字典中不存在的key"><a href="#访问字典中不存在的key" class="headerlink" title="访问字典中不存在的key"></a>访问字典中不存在的key</h2><p>这对于习惯使用返回值是否是默认值来判断key是否存在的开发人员来说是个陷阱，go中可以使用第二个返回值来确定key是否存在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>:<span class="string">"a"</span>,<span class="string">"two"</span>:<span class="string">""</span>,<span class="string">"three"</span>:<span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">"two"</span>]; v == <span class="string">""</span> &#123; <span class="comment">//incorrect two是存在的，值为''</span></span><br><span class="line">        fmt.Println(<span class="string">"no entry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>:<span class="string">"a"</span>,<span class="string">"two"</span>:<span class="string">""</span>,<span class="string">"three"</span>:<span class="string">"c"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _,ok := x[<span class="string">"two"</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"no entry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串是不可变的"><a href="#字符串是不可变的" class="headerlink" title="字符串是不可变的"></a>字符串是不可变的</h2><p>尝试使用下标改变字符串中的某个字符会报错，字符串是只读的byte slice，如果确实需要更新一个字符串，那么在必要时使用byte slice而不是字符串类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">'T'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xbytes := []<span class="keyword">byte</span>(x)</span><br><span class="line">    xbytes[<span class="number">0</span>] = <span class="string">'T'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(xbytes)) <span class="comment">//prints Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，上面的代码并不是修改字符串中字符的正确方法，</strong> 因为某些字符可能占用多个字节。如果需要的话先将字符串转换为rune切片。即使使用了rune切片，单个字符也可能会占用多个rune，比如字符有grave accent，这种“字符”的复杂和模棱两可的性质是Go字符串被表示为字节序列的原因。</p><h2 id="string和-byte相互转换"><a href="#string和-byte相互转换" class="headerlink" title="string和[]byte相互转换"></a>string和[]byte相互转换</h2><p>当进行string和[]byte的相互转换时得到的是原始数据的完整拷贝，而不是其他语言中的强制转换或分配一个新的切片变量指针指向原始数据同一个底层数组。</p><p>go中做了2点优化来避免转换时分配额外的内存分配：</p><ol><li>在<code>map[string]</code>字典<code>m[string(key)]</code>上使用[]byte来获取内容时。</li><li>在<code>for range</code>操作中将string转换为[]byte时：<code>for i,v := range []byte(str) {...}</code>。</li></ol><h2 id="字符串和索引操作"><a href="#字符串和索引操作" class="headerlink" title="字符串和索引操作"></a>字符串和索引操作</h2><p>在字符串上使用索引下标操作反回的是byte类型，而不是字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>]) <span class="comment">//print 116</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T"</span>,x[<span class="number">0</span>]) <span class="comment">//prints uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要访问字符串中的“字符”(unicode code points/runes)，使用<code>for range</code>操作。内置的<code>unicode/utf8</code>包和实验性的<code>golang.org/x/exp/utf8string</code>包都可以用，utf8string包中有个<code>At()</code>方法。当然把字符串转换成[]runes也可以达到目的。</p><h2 id="字符串并不总是utf8格式"><a href="#字符串并不总是utf8格式" class="headerlink" title="字符串并不总是utf8格式"></a>字符串并不总是utf8格式</h2><p>string的值不必是UTF8文本，可以包含任意的值。只有使用字符串文字字面值时才一定是UTF8文本，字串可以通过转义来包含其他数据。</p><p>判断字符串是否是UTF8文本，可使用”unicode/utf8”包中的<code>ValidString()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data1 := <span class="string">"ABC"</span></span><br><span class="line">    fmt.Println(utf8.ValidString(data1)) <span class="comment">//prints: true</span></span><br><span class="line"></span><br><span class="line">    data2 := <span class="string">"A\xfeC"</span></span><br><span class="line">    fmt.Println(utf8.ValidString(data2)) <span class="comment">//prints: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>假设你是一个python开发者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">u'♥'</span>  </span><br><span class="line">print(len(data)) <span class="comment">#prints: 1</span></span><br></pre></td></tr></table></figure><p>但在go中：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data)) <span class="comment">//prints: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>内置的<code>len()</code>函数返回字节长度替代了字符长度。</p><p>想得到同样的结果使用<code>unicode/utf8</code>包的<code>RuneCountInString()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(data)) <span class="comment">//prints: 1</span></span><br></pre></td></tr></table></figure><p>注意这个函数反悔的并不是字符长度，因为单个字符可能占用多个rune：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"é"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data))                    <span class="comment">//prints: 3</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(data)) <span class="comment">//prints: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="在多行array、slice、map语句中缺少逗号"><a href="#在多行array、slice、map语句中缺少逗号" class="headerlink" title="在多行array、slice、map语句中缺少逗号"></a>在多行array、slice、map语句中缺少逗号</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span> <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    x := []<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    x = x</span><br><span class="line"></span><br><span class="line">    y := []<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">4</span>,&#125; <span class="comment">//no error</span></span><br><span class="line">    y = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将声明写为一行时最后的逗号，不会报编译错误。</p><h2 id="log-Fatal和log-Painc"><a href="#log-Fatal和log-Painc" class="headerlink" title="log.Fatal和log.Painc"></a>log.Fatal和log.Painc</h2><p>logging库通常提供不同的日志等级，而go中的<code>Fatal*()</code>和<code>Panic*()</code>函数不仅仅输出日志还会停止程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    log.Fatalln(<span class="string">"Fatal Level: log entry"</span>) <span class="comment">//app exits here</span></span><br><span class="line">    log.Println(<span class="string">"Normal Level: log entry"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对内置数据结构的操作并不是同步的"><a href="#对内置数据结构的操作并不是同步的" class="headerlink" title="对内置数据结构的操作并不是同步的"></a>对内置数据结构的操作并不是同步的</h2><p>尽管go天生支持并发编程，但并不保证并发操作数据安全。开发人员需要自己负责确保数据操作的原子性。goroutine和channel是实现原子操做的推荐方法，当然需要的话也可以使用<code>sync</code>包。</p><h2 id="对string使用range操作得到的值"><a href="#对string使用range操作得到的值" class="headerlink" title="对string使用range操作得到的值"></a>对string使用range操作得到的值</h2><p>使用range对string进行迭代时，得到的索引(返回的第一个值)时当前“字符”（返回的第二个值）的第一个字节位置，而非当前字符的位置。而一个字符可以由多个rune组成。如果需要对字符进行操作，确保使用<code>norm</code>（golang.org/x/text/unicode/norm）包来进行检查。</p><p><code>for range</code>操作会尝试将字符串当utf8类型，对于任何它不理解的字节序列都会返回<code>0xfffd</code>来替代真实数值。如果你有特殊值存在字符串中，确保转换成byte切片来获取全部数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := <span class="string">"A\xfe\x02\xff\x04"</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> []<span class="keyword">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prints: 0x41 0xfe 0x2 0xff 0x4 (good)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对map进行range操作"><a href="#对map进行range操作" class="headerlink" title="对map进行range操作"></a>对map进行range操作</h2><p><strong>map是无序的！！</strong> go运行时会尽可能的打乱返回顺序，但这并不能每次都成功。所以连续得到5个相同的顺序也有可能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>:<span class="number">1</span>,<span class="string">"two"</span>:<span class="number">2</span>,<span class="string">"three"</span>:<span class="number">3</span>,<span class="string">"four"</span>:<span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在go playground来执行上面的代码，你总会得到同样的顺序，因为这个网站除非你改了代码，否则并不会重新编译代码。</p><h2 id="switch中的fallthrough语句"><a href="#switch中的fallthrough语句" class="headerlink" title="switch中的fallthrough语句"></a>switch中的fallthrough语句</h2><p>switch语句中case分支默认自带break，这和默认执行下一个case的语言略有不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>: <span class="comment">//error</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>)) <span class="comment">//prints true (ok)</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">' '</span>))  <span class="comment">//prints false (not ok)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>fallthrough</code>关键字来强制当前case块执行完成后执行下一个case块，当然也可以改写case条件为表达式列表来实现同样功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'\t'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>)) <span class="comment">//prints true (ok)</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">' '</span>))  <span class="comment">//prints true (ok)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自增和自减操作"><a href="#自增和自减操作" class="headerlink" title="自增和自减操作"></a>自增和自减操作</h2><p>自增自减操作在很多语言中都提供，不过go中不支持前置的这两种操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i <span class="comment">//error</span></span><br><span class="line">    fmt.Println(data[i++]) <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h2><p>很多语言中使用<code>~</code>来进行取反，但go中复用了XOR操作符<code>^</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(~<span class="number">2</span>) <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d <span class="keyword">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%08b\n"</span>,^d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能让人困惑，如果你愿意，可以使用XOR操作来代替一元的取反操作，比如使用<code>0x02 XOR 0xFF</code> 替代 <code>NOT 0x02</code>，这也解释了为什么<code>^</code>可以重用来进行取反操作了。</p><p>go中也提供了一个特殊的操作符<code>&amp;^</code>来执行<code>AND NOT</code>操作，但这增加了NOT操作的混乱性。这看上去就像是没有括号的<code>A AND (NOT B)</code>操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">"%08b [A]\n"</span>,a)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b [B]\n"</span>,b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%08b (NOT B)\n"</span>,^b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b ^ %08b = %08b [B XOR 0xff]\n"</span>,b,<span class="number">0xff</span>,b ^ <span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%08b ^ %08b = %08b [A XOR B]\n"</span>,a,b,a ^ b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b &amp; %08b = %08b [A AND B]\n"</span>,a,b,a &amp; b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b &amp;^%08b = %08b [A 'AND NOT' B]\n"</span>,a,b,a &amp;^ b)</span><br><span class="line">    fmt.Printf(<span class="string">"%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n"</span>,a,b,a &amp; (^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>除了<code>&amp;^</code>，go也提供了和其他语言一样的标准运算符，但优先级并不总和其他的一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"0x2 &amp; 0x2 + 0x4 -&gt; %#x\n"</span>,<span class="number">0x2</span> &amp; <span class="number">0x2</span> + <span class="number">0x4</span>)</span><br><span class="line">    <span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">    <span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n"</span>,<span class="number">0x2</span> + <span class="number">0x2</span> &lt;&lt; <span class="number">0x1</span>)</span><br><span class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"0xf | 0x2 ^ 0x2 -&gt; %#x\n"</span>,<span class="number">0xf</span> | <span class="number">0x2</span> ^ <span class="number">0x2</span>)</span><br><span class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不导出的struct字段无法被encode"><a href="#不导出的struct字段无法被encode" class="headerlink" title="不导出的struct字段无法被encode"></a>不导出的struct字段无法被encode</h2><p>小写字母开头的字段成员是无法被外部直接访问的，所以<code>struct</code>在进行json、xml、gob等格式的encode操作时，这些私有字段会被忽略，导出时得到零值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyData <span class="keyword">struct</span> &#123;  </span><br><span class="line">    One <span class="keyword">int</span></span><br><span class="line">    two <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    in := MyData&#123;<span class="number">1</span>,<span class="string">"two"</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>,in) <span class="comment">//prints main.MyData&#123;One:1, two:"two"&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded,_ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(encoded)) <span class="comment">//prints &#123;"One":1&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded,&amp;out)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>,out) <span class="comment">//prints main.MyData&#123;One:1, two:""&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序结束时还有goroutine在运行"><a href="#程序结束时还有goroutine在运行" class="headerlink" title="程序结束时还有goroutine在运行"></a>程序结束时还有goroutine在运行</h2><p>程序并不等待所有的goroutine运行完才结束，这是一个新手常见的错误，不需要觉得害羞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doit(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doit</span><span class="params">(workerId <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0] is running </span><br><span class="line">[1] is running </span><br><span class="line">all done!</span><br></pre></td></tr></table></figure><p>一个常见的解决方案是使用<code>WaitGroup</code>，他将阻塞主goroutine等待其他goroutine执行完成。如果goroutine需要长时间运行的来处理消息，可以直接发送kill命令给每个goroutine,或者关闭所有goroutin都需要接收的channel，这里有个简单的方法一次性通知所有goroutine:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doit(i,done,wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doit</span><span class="params">(workerId <span class="keyword">int</span>,done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,wg sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;- done</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>] is running </span><br><span class="line">[<span class="number">0</span>] is done </span><br><span class="line">[<span class="number">1</span>] is running </span><br><span class="line">[<span class="number">1</span>] is done</span><br></pre></td></tr></table></figure><p>看起来好像是所有的goroutine都已经执行完成了，然而你会看到报错：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>WTF??这个问题的主要原因在于每个goroutine得到的都是原始WaitGroup的一个副本，当goroutine内部执行<code>wg.Done()</code>时，并不会影响主goroutine中的WaitGroup：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    wq := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doit(i,wq,done,&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wq &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doit</span><span class="params">(workerId <span class="keyword">int</span>, wq &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;- wq:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] m =&gt; %v\n"</span>,workerId,m)</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码才是正确的姿势。（Roy注：总之一句话，当把WaitGroup传递给goroutine时请传递指针）</p><h2 id="向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行"><a href="#向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行" class="headerlink" title="向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行"></a>向无缓冲的channel发送数据时，只要recevier准备好了就会继续向下执行</h2><p>发送方不会阻塞直到接收方处理这个消息。取决于运行下列代码的环境，接收方可能有时间处理消息也可能来不及处理消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">"processed:"</span>,m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">"cmd.1"</span></span><br><span class="line">    ch &lt;- <span class="string">"cmd.2"</span> <span class="comment">//won't be processed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Roy注：上面的代码可能执行多次结果不同，有时候可以看到”processed cmd.2”，有时候主goroutine把cmd.2丢掉channel里就结束退出了。但如果goroutine中一直没有处理channel中的消息，那么程序就会一直阻塞等待channel中cmd.1这个数据被消费而报错)</p><h2 id="向close的channel发送数据会panic"><a href="#向close的channel发送数据会panic" class="headerlink" title="向close的channel发送数据会panic"></a>向close的channel发送数据会panic</h2><p>从一个已经关闭的channel读取数据时安全的，如果<code>ok</code>字段接收到的值为<code>false</code>则代表没有数据可以接受了（Roy注：这里应该是指channel关闭了），对于有缓冲的channel，会将缓存中的数据全部取出后<code>ok</code>返回<code>false</code>。</p><p>向一个关闭的channel发送数据会引发panic，虽然文档中记录很清楚，但很多新人还是会掉进这个坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the first result</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(ch) <span class="comment">//not ok (you still have other senders)</span></span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据程序不同，修改方法也是不同的，可以大改也可以小改，但不论如何都要保证程序不会向关闭的channel发送数据。</p><p>上面的例子可以使用一个专门用于通知取消的channel来进行修复：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>: fmt.Println(idx,<span class="string">"sent result"</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;- done: fmt.Println(idx,<span class="string">"exiting"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get first result</span></span><br><span class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nil值的channel"><a href="#nil值的channel" class="headerlink" title="nil值的channel"></a>nil值的channel</h2><p>对一个nil值的channel读取或发送数据会永远阻塞，文档里也写的挺清楚，不过还是有新手会跳进这个坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get first result</span></span><br><span class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个代码将会报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p><p>不过这个特性也可以作为一种实现动态启停case块的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    inch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    outch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;- <span class="keyword">chan</span> <span class="keyword">int</span> = inch</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span> &lt;- <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inch</span><br><span class="line">            <span class="keyword">case</span> val = &lt;- in:</span><br><span class="line">                out = outch</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outch &#123;</span><br><span class="line">            fmt.Println(<span class="string">"result:"</span>,r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inch &lt;- <span class="number">1</span></span><br><span class="line">    inch &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用值传递的方法不能改变参数原有值"><a href="#使用值传递的方法不能改变参数原有值" class="headerlink" title="使用值传递的方法不能改变参数原有值"></a>使用值传递的方法不能改变参数原有值</h2><p>结构体方法的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p><p>例外是map或slice类型的变量，并且是以指针方式更新map中的字段、slice中的元素的，才会更新原有值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">    key *<span class="keyword">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span> <span class="title">pmethod</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span> <span class="title">vmethod</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">"v.key"</span></span><br><span class="line">    this.items[<span class="string">"vmethod"</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    key := <span class="string">"key.1"</span></span><br><span class="line">    d := data&#123;<span class="number">1</span>,&amp;key,<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items)</span><br><span class="line">    <span class="comment">//prints num=1 key=key.1 items=map[]</span></span><br><span class="line"></span><br><span class="line">    d.pmethod()</span><br><span class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items) </span><br><span class="line">    <span class="comment">//prints num=7 key=key.1 items=map[]</span></span><br><span class="line"></span><br><span class="line">    d.vmethod()</span><br><span class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items)</span><br><span class="line">    <span class="comment">//prints num=7 key=v.key items=map[vmethod:true]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭HTTP响应体"><a href="#关闭HTTP响应体" class="headerlink" title="关闭HTTP响应体"></a>关闭HTTP响应体</h2><p>当使用标准http库获取响应时，即便不需要获取响应体的内容也需要手动关闭它，即便是一个空响应也是如此。这点很容易忘记，或者方法不对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()<span class="comment">//not ok</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在响应成功时没问题，但如果响应失败，<code>resp</code>为nil，就会引发运行时错误。</p><p>最常见的方法是在检查响应后使用<code>defer</code>关闭响应体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()<span class="comment">//ok, most of the time :-)</span></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况，当http请求失败时resp将会是nil，err是非空值。然而如果得到的是重定向失败这2者都是非空值，也就是说程序还会泄露。</p><p>可以通过在http响应错误时的处理代码中来进行关闭，另一个方法则是使用一次<code>defer</code>调用来处理所有成功或失败的响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早先版本的<code>resp.Body.Close()</code>实现是读取响应体的数据之后丢弃，保证了keep-alive的HTTP连接能重用处理不止一个请求。但Go的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP连接可能会直接关闭而非重用，参考在Go1.5版本文档。</p><p>如果重用http链接对你的程序是否重要，你也许需要添加类似下面的代码在响应处理逻辑中：</p><p><code>_, err = io.Copy(ioutil.Discard, resp.Body)</code></p><p>如果使用正确的方法读取全部的响应体，这是非常重要的。比如你处理一个json api的响应时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)</span><br></pre></td></tr></table></figure><h2 id="关闭HTTP连接"><a href="#关闭HTTP连接" class="headerlink" title="关闭HTTP连接"></a>关闭HTTP连接</h2><p>有些HTTP服务器会通过使用<code>keep-alive</code>来保持连接，而默认情况下标准http库只有当服务器要求时才会关闭连接。也就是说，你的程序可能会在某种场景下耗尽socket描述符。</p><p>可以通过设置<code>Close</code>字段的值为true，来要求标准http库在请求完成后关闭连接。</p><p>另一个选项是添加<code>Connection</code>请求头并设置为<code>close</code>。目标服务器收到后会返回响应并在header中携带<code>Connection: close</code>，当标准库收到这个响应头就会关闭连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>,<span class="string">"http://golang.org"</span>,<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.Close = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//or do this:</span></span><br><span class="line">    <span class="comment">//req.Header.Add("Connection", "close")</span></span><br><span class="line"></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="keyword">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以全局禁用掉http连接复用功能，这需要创建一个自定义http transport：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    tr := &amp;http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := client.Get(<span class="string">"http://golang.org"</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(resp.StatusCode)</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="keyword">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要发送很多请求到同一个HTTP服务器，保持连接是没问题的。然而，如果程序在短时间内向许多不同的HTTP服务器发送请求，那么收到响应后立即关闭网络连接是一个好主意。</p><p>或者提高文件描述符数量限制也是个好主意，取决于实际情况来选择解决方案。</p><h2 id="JSON解码时会添加换行符"><a href="#JSON解码时会添加换行符" class="headerlink" title="JSON解码时会添加换行符"></a>JSON解码时会添加换行符</h2><p>当使用JSON Encoder 对象时，那么将在编码后的JSON对象的末尾获得一个额外的换行符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"key"</span>: <span class="number">1</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">  json.NewEncoder(&amp;b).Encode(data)</span><br><span class="line"></span><br><span class="line">  raw,_ := json.Marshal(data)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> b.String() == <span class="keyword">string</span>(raw) &#123;</span><br><span class="line">    fmt.Println(<span class="string">"same encoded data"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"'%s' != '%s'\n"</span>,raw,b.String())</span><br><span class="line">    <span class="comment">//prints:</span></span><br><span class="line">    <span class="comment">//'&#123;"key":1&#125;' != '&#123;"key":1&#125;\n'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON encoder对象是为了流设计的，使用JSON流通常意味着以换行符分隔的JSON对象，这就是Encode方法添加换行符的原因。文档中有写，不过通常被忽略。</p><h2 id="JSON包转义键和字符串值中的特殊HTML字符"><a href="#JSON包转义键和字符串值中的特殊HTML字符" class="headerlink" title="JSON包转义键和字符串值中的特殊HTML字符"></a>JSON包转义键和字符串值中的特殊HTML字符</h2><p>这也是文档里有的，不过需要特别仔细的查看所有JSON相关的文档才能发现这个。 <code>SetEscapeHTML</code>方法描述了关于一些特殊字符的encoding默认行为。</p><p>这是一个很糟糕的设计，首先你不能禁用这个行为在<code>json.Marshal</code>时，其次这引起很糟糕的安全问题因为它假设所有的web程序都能够做出充足的xss漏洞检测。最后它假设所有的用例都是为了web页面的，打破了默认的REST/HTTP APIs配置库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data := <span class="string">"x &lt; y"</span></span><br><span class="line">  </span><br><span class="line">  raw,_ := json.Marshal(data)</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(raw))</span><br><span class="line">  <span class="comment">//prints: "x \u003c y" &lt;- probably not what you expected</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> b1 bytes.Buffer</span><br><span class="line">  json.NewEncoder(&amp;b1).Encode(data)</span><br><span class="line">  fmt.Println(b1.String())</span><br><span class="line">  <span class="comment">//prints: "x \u003c y" &lt;- probably not what you expected</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> b2 bytes.Buffer</span><br><span class="line">  enc := json.NewEncoder(&amp;b2)</span><br><span class="line">  enc.SetEscapeHTML(<span class="literal">false</span>)</span><br><span class="line">  enc.Encode(data)</span><br><span class="line">  fmt.Println(b2.String())</span><br><span class="line">  <span class="comment">//prints: "x &lt; y" &lt;- looks better</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将JSON中的数字解码为interface类型"><a href="#将JSON中的数字解码为interface类型" class="headerlink" title="将JSON中的数字解码为interface类型"></a>将JSON中的数字解码为interface类型</h2><p>默认情况下，go在编码、解码时将JSON中的数值型数据转化为<code>float64</code>类型，也就是说下面的代码会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status = result[<span class="string">"status"</span>].(<span class="keyword">int</span>) <span class="comment">//error</span></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几种方法处理：</p><p>使用float类型声明字典值的类型。</p><p>将float类型转换为需要的整型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status = <span class="keyword">uint64</span>(result[<span class="string">"status"</span>].(<span class="keyword">float64</span>)) <span class="comment">//ok</span></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Decoder</code>来解码并指定使用数字类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">  decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status,_ = result[<span class="string">"status"</span>].(json.Number).Int64() <span class="comment">//ok</span></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用字符串来表示数值类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">  decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> status <span class="keyword">uint64</span></span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(result[<span class="string">"status"</span>].(json.Number).String()), &amp;status); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">"status value:"</span>,status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用结构体来接收转码后的数据并定义需要的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status <span class="keyword">uint64</span> <span class="string">`json:"status"`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"result =&gt; %+v"</span>,result)</span><br><span class="line">  <span class="comment">//prints: result =&gt; &#123;Status:200&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要延时解码或某个字段类型是可变的，可以使用结构体结合<code>json.RawMessage</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  records := [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">    []<span class="keyword">byte</span>(<span class="string">`&#123;"status": 200, "tag":"one"&#125;`</span>),</span><br><span class="line">    []<span class="keyword">byte</span>(<span class="string">`&#123;"status":"ok", "tag":"two"&#125;`</span>),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">      StatusCode <span class="keyword">uint64</span></span><br><span class="line">      StatusName <span class="keyword">string</span></span><br><span class="line">      Status json.RawMessage <span class="string">`json:"status"`</span></span><br><span class="line">      Tag <span class="keyword">string</span>             <span class="string">`json:"tag"`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sstatus <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(result.Status, &amp;sstatus); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      result.StatusName = sstatus</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nstatus <span class="keyword">uint64</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(result.Status, &amp;nstatus); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      result.StatusCode = nstatus</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"[%v] result =&gt; %+v\n"</span>,idx,result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON字符串值不适合十六进制或其他非utf8转义序列"><a href="#JSON字符串值不适合十六进制或其他非utf8转义序列" class="headerlink" title="JSON字符串值不适合十六进制或其他非utf8转义序列"></a>JSON字符串值不适合十六进制或其他非utf8转义序列</h2><p>go期望所有的字符串都是utf8编码，这意味着不能在JSON字符串中使用任意十六进制转义的二进制数据(还必须转义反斜杠字符)，这是一个非常常见的坑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="keyword">string</span> <span class="string">`json:"data"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  raw := []<span class="keyword">byte</span>(<span class="string">`&#123;"data":"\xc2"&#125;`</span>)</span><br><span class="line">  <span class="keyword">var</span> decoded config</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(raw, &amp;decoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    <span class="comment">//prints: invalid character 'x' in string escape code</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你确实需要在字符串中使用反斜杠，确保用另一个反斜杠来转义它。如果想使用十六进制编码的二进制数据，可以转义反斜杠，然后将十六进制转义与解码数据存在JSON字符串中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="keyword">string</span> <span class="string">`json:"data"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  raw := []<span class="keyword">byte</span>(<span class="string">`&#123;"data":"\\xc2"&#125;`</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> decoded config</span><br><span class="line">  </span><br><span class="line">  json.Unmarshal(raw, &amp;decoded)</span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"%#v"</span>,decoded) <span class="comment">//prints: main.config&#123;Data:"\\xc2"&#125;</span></span><br><span class="line">  <span class="comment">//todo: do your own hex escape decoding for decoded.Data  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方式就是在json中使用byte数组或切片，但这需要将数据进行base64编码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data []<span class="keyword">byte</span> <span class="string">`json:"data"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  raw := []<span class="keyword">byte</span>(<span class="string">`&#123;"data":"wg=="&#125;`</span>)</span><br><span class="line">  <span class="keyword">var</span> decoded config</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(raw, &amp;decoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"%#v"</span>,decoded) <span class="comment">//prints: main.config&#123;Data:[]uint8&#123;0xc2&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他需要注意的是Unicode替换字符(U+FFFD)。go将使用替换字符而不是无效的UTF8，因此Unmarshal/Decode调用不会失败，但获得的字符串值可能不是预期的。</p><h2 id="比较结构体、数组、切片和字典"><a href="#比较结构体、数组、切片和字典" class="headerlink" title="比较结构体、数组、切片和字典"></a>比较结构体、数组、切片和字典</h2><p>可以使用相等运算符<code>==</code>来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">    fp <span class="keyword">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">complex64</span></span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">    char <span class="keyword">rune</span></span><br><span class="line">    yes <span class="keyword">bool</span></span><br><span class="line">    events &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref *<span class="keyword">byte</span></span><br><span class="line">    raw [<span class="number">10</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,v1 == v2) <span class="comment">//prints: v1 == v2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果任何成员是不可比较的，则会报错。需要注意，只有在其中元素是可以比较的类型时数组才是可以比较的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span>                <span class="comment">//ok</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span> //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">doit</span> <span class="title">func</span><span class="params">()</span> <span class="title">bool</span>       //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">m</span> <span class="title">map</span>[<span class="title">string</span>] <span class="title">string</span>   //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">bytes</span> []<span class="title">byte</span>           //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go中也提供了很多函数来进行比较操作，最常用的就是reflect包中的<code>DeepEqual()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    num <span class="keyword">int</span>                <span class="comment">//ok</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span> //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">doit</span> <span class="title">func</span><span class="params">()</span> <span class="title">bool</span>       //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">m</span> <span class="title">map</span>[<span class="title">string</span>] <span class="title">string</span>   //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">    <span class="title">bytes</span> []<span class="title">byte</span>           //<span class="title">not</span> <span class="title">comparable</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,reflect.DeepEqual(v1,v2)) <span class="comment">//prints: v1 == v2: true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"a"</span>,<span class="string">"two"</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"two"</span>: <span class="string">"b"</span>, <span class="string">"one"</span>: <span class="string">"a"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"m1 == m2:"</span>,reflect.DeepEqual(m1, m2)) <span class="comment">//prints: m1 == m2: true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"s1 == s2:"</span>,reflect.DeepEqual(s1, s2)) <span class="comment">//prints: s1 == s2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了速度慢一点外，这个函数也有个小陷阱：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="keyword">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"b1 == b2:"</span>,reflect.DeepEqual(b1, b2)) <span class="comment">//prints: b1 == b2: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DeepEqual()</code>并不认为空切片和nil切片相同。这个行为和<code>bytes.Equal()</code>不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="keyword">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"b1 == b2:"</span>,bytes.Equal(b1, b2)) <span class="comment">//prints: b1 == b2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>DeepEqual()</code>不推荐用来比较切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"one"</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">"one"</span></span><br><span class="line">    fmt.Println(<span class="string">"str == in:"</span>,str == in,reflect.DeepEqual(str, in)) </span><br><span class="line">    <span class="comment">//prints: str == in: true true</span></span><br><span class="line"></span><br><span class="line">    v1 := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125;</span><br><span class="line">    v2 := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,reflect.DeepEqual(v1, v2)) </span><br><span class="line">    <span class="comment">//prints: v1 == v2: false (not ok)</span></span><br><span class="line"></span><br><span class="line">    data := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">"value"</span>: []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    encoded, _ := json.Marshal(data)</span><br><span class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">    fmt.Println(<span class="string">"data == decoded:"</span>,reflect.DeepEqual(data, decoded)) </span><br><span class="line">    <span class="comment">//prints: data == decoded: false (not ok)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要大小写不敏感来比较byte或string中的英文文本，可以使用bytes或strings包的<code>ToUpper()</code>和<code>ToLower()</code>函数将大小写统一后再使用<code>==</code>、<code>bytes.Equal()</code>或<code>bytes.Compare()</code>比较。比较非英语的byte或string，应使用<code>bytes.EqualFold()</code>和<code>strings.EqualFold()</code>。</p><p>如果byte切片中含有验证用户身份的数据（密文哈希、token 等），不应再使用<code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、<code>bytes.Compare()</code>。这三个函数容易对程序造成<a href="http://en.wikipedia.org/wiki/Timing_attack" target="_blank" rel="noopener">timing attacks</a>，此时应使用<code>crypto/subtle</code>包中的<code>subtle.ConstantTimeCompare()</code>等函数。</p><h2 id="从panic中恢复"><a href="#从panic中恢复" class="headerlink" title="从panic中恢复"></a>从panic中恢复</h2><p>在defer函数中 <strong>直接调用</strong> <code>recover()</code>函数可以捕获、中断panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="built_in">recover</span>() <span class="comment">//doesn't do anything</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">    <span class="built_in">recover</span>() <span class="comment">//won't be executed :)</span></span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"recovered:"</span>,<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"recovered =&gt;"</span>,<span class="built_in">recover</span>()) <span class="comment">//prints: recovered =&gt; &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover() <span class="comment">//panic is not recovered</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice-Array-Map在range语句中更新引用元素的值"><a href="#Slice-Array-Map在range语句中更新引用元素的值" class="headerlink" title="Slice,Array,Map在range语句中更新引用元素的值"></a>Slice,Array,Map在range语句中更新引用元素的值</h2><p>在range操作中得到的值是原始元素的拷贝，也就是说对其修改并不会影响原始数据，换言之得到的指针也不会指向原始数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span> <span class="comment">//original item is not changed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"data:"</span>,data) <span class="comment">//prints data: [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想修改原始数据，可以通过索引的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i,_ := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"data:"</span>,data) <span class="comment">//prints data: [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的集合保存的是指针，那规则会稍有不同。</p><p>如果要更新原有记录指向的数据，你依然需要使用索引操作，但你可以使用for range语句中的第二个值来更新存储在目标位置的数据:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123;num <span class="keyword">int</span>&#125; &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data[<span class="number">0</span>],data[<span class="number">1</span>],data[<span class="number">2</span>]) <span class="comment">//prints &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice中的隐藏数据"><a href="#slice中的隐藏数据" class="headerlink" title="slice中的隐藏数据"></a>slice中的隐藏数据</h2><p>当你重新划分一个slice时，新的slice将引用原有slice的数组。如果你忘了这个行为的话，在你的应用分配大量临时的slice用于创建新的slice来引用原有数据的一小部分时，会导致难以预期的内存使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;  </span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw),<span class="built_in">cap</span>(raw),&amp;raw[<span class="number">0</span>]) <span class="comment">//prints: 10000 10000 &lt;byte_addr_x&gt;</span></span><br><span class="line">    <span class="keyword">return</span> raw[:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data),<span class="built_in">cap</span>(data),&amp;data[<span class="number">0</span>]) <span class="comment">//prints: 3 10000 &lt;byte_addr_x&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这样要确保从临时的slice中拷贝数据（而不是重新划分slice）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;  </span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw),<span class="built_in">cap</span>(raw),&amp;raw[<span class="number">0</span>]) <span class="comment">//prints: 10000 10000 &lt;byte_addr_x&gt;</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res,raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data),<span class="built_in">cap</span>(data),&amp;data[<span class="number">0</span>]) <span class="comment">//prints: 3 3 &lt;byte_addr_y&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice数据“损坏”"><a href="#slice数据“损坏”" class="headerlink" title="slice数据“损坏”"></a>slice数据“损坏”</h2><p>假设需要重新一个路径（在slice中保存）。你通过修改第一个文件夹的名字，然后把名字合并来创建新的路劲，来重新划分指向各个文件夹的路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    path := []<span class="keyword">byte</span>(<span class="string">"AAAA/BBBBBBBBB"</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path,<span class="string">'/'</span>)</span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1,<span class="string">"suffix"</span>...)</span><br><span class="line">    path = bytes.Join([][]<span class="keyword">byte</span>&#123;dir1,dir2&#125;,[]<span class="keyword">byte</span>&#123;<span class="string">'/'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB (not ok)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"new path =&gt;"</span>,<span class="keyword">string</span>(path))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果与你想的不一样。与”AAAAsuffix/BBBBBBBBB”相反，你将会得到”AAAAsuffix/uffixBBBB”。这个情况的发生是因为两个文件夹的slice都潜在的引用了同一个原始的路径slice。这意味着原始路径也被修改了。根据你的应用，这也许会是个问题。</p><p>通过分配新的slice并拷贝需要的数据，你可以修复这个问题。另一个选择是使用完整的slice表达式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    path := []<span class="keyword">byte</span>(<span class="string">"AAAA/BBBBBBBBB"</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path,<span class="string">'/'</span>)</span><br><span class="line">    dir1 := path[:sepIndex:sepIndex] <span class="comment">//full slice expression</span></span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1,<span class="string">"suffix"</span>...)</span><br><span class="line">    path = bytes.Join([][]<span class="keyword">byte</span>&#123;dir1,dir2&#125;,[]<span class="keyword">byte</span>&#123;<span class="string">'/'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="keyword">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></span><br><span class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="keyword">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB (ok now)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"new path =&gt;"</span>,<span class="keyword">string</span>(path))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的slice表达式中的额外参数可以控制新的slice的容量。现在在那个slice后添加元素将会触发一个新的buffer分配，而不是覆盖第二个slice中的数据。</p><h2 id="陈旧的slices"><a href="#陈旧的slices" class="headerlink" title="陈旧的slices"></a>陈旧的slices</h2><p>多个slice可以引用同一个数据。比如，当从一个已有的slice创建一个新的slice时，这就会发生。如果你的应用功能需要这种行为，那么你将需要关注下“陈旧的”slice。</p><p>在某些情况下，在一个slice中添加新的数据，在原有数组无法保持更多新的数据时，将导致分配一个新的数组。而现在其他的slice还指向老的数组（和老的数据）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1),s1) <span class="comment">//prints 3 3 [1 2 3]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2),<span class="built_in">cap</span>(s2),s2) <span class="comment">//prints 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123; s2[i] += <span class="number">20</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//still referencing the same array</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//prints [1 22 23]</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//prints [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123; s2[i] += <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1 is now "stale"</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//prints [1 22 23]</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//prints [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Roy注：凡是用到slice操作的时候一定要注意底层指向的数组是不是同一个。）</p><h2 id="类型声明和方法"><a href="#类型声明和方法" class="headerlink" title="类型声明和方法"></a>类型声明和方法</h2><p>当使用旧类型（非interface）创建新的类型时，新类型并不会继承旧类型的方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> mtx myMutex</span><br><span class="line">    mtx.Lock() <span class="comment">//error</span></span><br><span class="line">    mtx.Unlock() <span class="comment">//error  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你确实需要原有类型的方法，你可以定义一个新的struct类型，用匿名方式把原有类型嵌入其中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;  </span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> lock myLocker</span><br><span class="line">    lock.Lock() <span class="comment">//ok</span></span><br><span class="line">    lock.Unlock() <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型声明也会继承原有的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> lock myLocker = <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">    lock.Lock() <span class="comment">//ok</span></span><br><span class="line">    lock.Unlock() <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从”for-switch”和”for-select”代码块中跳出"><a href="#从”for-switch”和”for-select”代码块中跳出" class="headerlink" title="从”for switch”和”for select”代码块中跳出"></a>从”for switch”和”for select”代码块中跳出</h2><p>没有标签的“break”声明只能从内部的switch/select代码块中跳出来。如果无法使用“return”声明的话，那就为外部循环定义一个标签是另一个好的选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    loop:</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">                fmt.Println(<span class="string">"breaking out..."</span>)</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"out!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goto</code>语句也是同理。</p><h2 id="for循环中的迭代和闭包"><a href="#for循环中的迭代和闭包" class="headerlink" title="for循环中的迭代和闭包"></a>for循环中的迭代和闭包</h2><p>这是一个很常见的陷阱，for语句中的迭代变量在每次迭代时被重新使用，也就是for循环中每个闭包（又名函数字面量）都会引用相同的变量（并且goroutine执行时会得到这个变量）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: three, three, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的解决办法（不需要改goroutine）就是在for循环语句中创建一个本地变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        vcopy := v <span class="comment">//</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(vcopy)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决办法就是把变量当做参数传递给goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个陷阱还有个复杂的版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: three, three, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v := v</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">//goroutines print: one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>猜猜下面的代码输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    data := []*field&#123;&#123;<span class="string">"one"</span>&#125;,&#123;<span class="string">"two"</span>&#125;,&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Roy注：会输出 one tow three 顺序随机，因为传递的是地址)</p><h2 id="Defer函数调用参数的求值"><a href="#Defer函数调用参数的求值" class="headerlink" title="Defer函数调用参数的求值"></a>Defer函数调用参数的求值</h2><p>对defer延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"result =&gt;"</span>,<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">    <span class="comment">//prints: result =&gt; 2 (not ok if you expected 4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但对于指针类型又有所不同：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">(in *<span class="keyword">int</span>)</span></span> &#123; fmt.Println(<span class="string">"result =&gt;"</span>, *in) &#125;(&amp;i)</span><br><span class="line">  </span><br><span class="line">  i = <span class="number">2</span></span><br><span class="line">  <span class="comment">//prints: result =&gt; 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="defer函数执行时机"><a href="#defer函数执行时机" class="headerlink" title="defer函数执行时机"></a>defer函数执行时机</h2><p>对defer延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p><p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start, err := os.Stat(os.Args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir()&#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="keyword">string</span></span><br><span class="line">    filepath.Walk(os.Args[<span class="number">1</span>], <span class="function"><span class="keyword">func</span><span class="params">(fpath <span class="keyword">string</span>, fi os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fi.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets,fpath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"bad target:"</span>,target,<span class="string">"error:"</span>,err) <span class="comment">//prints error: too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">//will not be closed at the end of this code block</span></span><br><span class="line">        <span class="comment">//do something with the file...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法之一就是增加一层函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start, err := os.Stat(os.Args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir()&#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="keyword">string</span></span><br><span class="line">    filepath.Walk(os.Args[<span class="number">1</span>], <span class="function"><span class="keyword">func</span><span class="params">(fpath <span class="keyword">string</span>, fi os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fi.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets,fpath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"bad target:"</span>,target,<span class="string">"error:"</span>,err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close() <span class="comment">//ok</span></span><br><span class="line">            <span class="comment">//do something with the file...</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者去掉defer，直接调用<code>f.Close()</code>。</p><h2 id="失败的类型断言"><a href="#失败的类型断言" class="headerlink" title="失败的类型断言"></a>失败的类型断言</h2><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int] value =&gt;"</span>,data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int] value =&gt;"</span>,data) </span><br><span class="line">        <span class="comment">//prints: [not an int] value =&gt; 0 (not "great")</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int] value =&gt;"</span>,res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int] value =&gt;"</span>,data) </span><br><span class="line">        <span class="comment">//prints: [not an int] value =&gt; great (as expected)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞的Goroutine和资源泄露"><a href="#阻塞的Goroutine和资源泄露" class="headerlink" title="阻塞的Goroutine和资源泄露"></a>阻塞的Goroutine和资源泄露</h2><p>Rob Pike在2012年的Google I/O大会上所做的“Go Concurrency Patterns”的演讲上，说道过几种基础的并发模式。从一组目标中获取第一个结果就是其中之一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数每次循环时都会启动goroutine来进行数据处理，将第一个值写入到channel中。</p><p>那么其他的goroutine的搜索结果怎么处理？关于这些goroutine本身又会如何？</p><p>Frist函数中result这个channel是无缓冲的，也就是说只有第一个goroutine会返回并结束，而其他的goroutine将阻塞到向channel中写数据的地方。也就是说造成了资源泄露。</p><p>避免这个问题需要保证所有的goroutine都退出，一种解决方案就是使用有缓冲的channel确保每个goroutine都能写入数据后退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决方案就是使用select结合default语句来解决goroutine阻塞的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用一个取消channel来通知goroutine退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="keyword">string</span>, replicas ...Search)</span> <span class="title">Result</span></span> &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何在演讲中会包含这些bug？Rob Pike仅仅是不想把演示复杂化。这么作是合理的，但对于Go新手而言，可能会直接使用代码，而不去思考它可能有问题。</p><h2 id="0大小的变量初始地址相同"><a href="#0大小的变量初始地址相同" class="headerlink" title="0大小的变量初始地址相同"></a>0大小的变量初始地址相同</h2><p>不同的变量不应该有不同的内存地址么？go中有个小陷阱，0大小(zero-size)的变量可能指向了同一个内存地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := &amp;data&#123;&#125;</span><br><span class="line">  b := &amp;data&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> a == b &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"same address - a=%p b=%p\n"</span>,a,b)</span><br><span class="line">    <span class="comment">//prints: same address - a=0x1953e4 b=0x1953e4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iota不一定总是从0开始"><a href="#iota不一定总是从0开始" class="headerlink" title="iota不一定总是从0开始"></a>iota不一定总是从0开始</h2><p>看起来iota像是个自增操作，当第一次使用iota创建常量时候会得到0，第二次会得到1…但并不是总会如此：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  azero = <span class="literal">iota</span></span><br><span class="line">  aone  = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  info  = <span class="string">"processing"</span></span><br><span class="line">  bzero = <span class="literal">iota</span></span><br><span class="line">  bone  = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(azero,aone) <span class="comment">//prints: 0 1</span></span><br><span class="line">  fmt.Println(bzero,bone) <span class="comment">//prints: 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iota</code>实际上是定义常量语句块内部的行数，所以如果不在第一行使用的话，他的值就不会是0。</p><h2 id="使用指针作为方法的receiver"><a href="#使用指针作为方法的receiver" class="headerlink" title="使用指针作为方法的receiver"></a>使用指针作为方法的receiver</h2><p>只要值是可取址的，那在这个值上调用指针接收方法是没问题的。换句话说，在某些情况下，你不需要在有一个接收值的方法版本。</p><p>然而并不是所有的变量是可取址的。Map的元素就不是。通过interface引用的变量也不是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span> <span class="title">print</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">"name:"</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    d1 := data&#123;<span class="string">"one"</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>() <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">"two"</span>&#125; <span class="comment">//error</span></span><br><span class="line">    in.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data &#123;<span class="string">"x"</span>:data&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"x"</span>].<span class="built_in">print</span>() <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新Map的值"><a href="#更新Map的值" class="headerlink" title="更新Map的值"></a>更新Map的值</h2><p>如果你有一个struct值的map，你无法更新单个的struct值，因为 <strong>Map类型是无法寻址的</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"two"</span> <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下：<code>/tmp/sandbox380452744/main.go:9: cannot assign to m[&quot;x&quot;].name</code>。</p><p>更让人困惑得是，slice是可以寻址的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := []data &#123;&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">"two"</span> <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(s)    <span class="comment">//prints: [&#123;two&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不久前gccgo编译器可更新map struct元素的字段值，不过很快便修复了，官方认为是Go1.3的潜在特性，无需及时实现，依旧在todo list中。</p><p>更新map中struct元素的字段值，第一个方法是使用临时变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    r := m[<span class="string">"x"</span>]</span><br><span class="line">    r.name = <span class="string">"two"</span></span><br><span class="line">    m[<span class="string">"x"</span>] = r</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>,m) <span class="comment">//prints: map[x:&#123;two&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个是使用指向map的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"two"</span> <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(m[<span class="string">"x"</span>]) <span class="comment">//prints: &amp;&#123;two&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便，你猜下面的代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data &#123;<span class="string">"x"</span>:&#123;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">"z"</span>].name = <span class="string">"what?"</span> <span class="comment">//???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Roy注：会报错<code>panic: runtime error: invalid memory address or nil pointer dereference</code>)</p><h2 id="“nil”-Interfaces和”nil”-Interfaces的值"><a href="#“nil”-Interfaces和”nil”-Interfaces的值" class="headerlink" title="“nil” Interfaces和”nil” Interfaces的值"></a>“nil” Interfaces和”nil” Interfaces的值</h2><p>这在Go中是第二最常见的陷阱，因为interface虽然看起来像指针，但并不是指针。interface变量仅在类型和值为“nil”时才为“nil”。</p><p>interface的类型和值会根据用于创建对应interface变量的类型和值的变化而变化。当你检查一个interface变量是否等于“nil”时，这就会导致未预期的行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> data *<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data,data == <span class="literal">nil</span>) <span class="comment">//prints: &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in,in == <span class="literal">nil</span>)     <span class="comment">//prints: &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in,in == <span class="literal">nil</span>)     <span class="comment">//prints: &lt;nil&gt; false</span></span><br><span class="line">    <span class="comment">//'data' is 'nil', but 'in' is not 'nil'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要小心这个陷阱当你的函数返回interface时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 错误代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    doit := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doit(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"good result:"</span>,res) <span class="comment">//prints: good result: &lt;nil&gt;</span></span><br><span class="line">        <span class="comment">//'res' is not 'nil', but its value is 'nil'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    doit := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//return an explicit 'nil'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doit(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"good result:"</span>,res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"bad result (res is nil)"</span>) <span class="comment">//here as expected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈和堆变量"><a href="#栈和堆变量" class="headerlink" title="栈和堆变量"></a>栈和堆变量</h2><p>你并不总是知道变量是分配到栈还是堆上。在C++中，使用new创建的变量总是在堆上。在Go中，即使是使用<code>new()</code>或者<code>make()</code>函数来分配，变量的位置还是由编译器决定。编译器根据变量的大小和“泄露分析”的结果来决定其位置。这也意味着在局部变量上返回引用是没问题的，而这在C或者C++这样的语言中是不行的。</p><p>如果你想知道变量分配的位置，在“go build”或“go run”上传入“-m” gc标志（即，<code>go run -gcflags -m app.go</code>）。</p><h2 id="GOMAXPROCS、并发和并行"><a href="#GOMAXPROCS、并发和并行" class="headerlink" title="GOMAXPROCS、并发和并行"></a>GOMAXPROCS、并发和并行</h2><p>Go1.4及以下版本，程序只会使用1个执行上下文/OS线程，即任何时间都最多只有1个goroutine在执行。</p><p>Go1.5版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑CPU核心数，这个数与系统实际总的CPU逻辑核心数是否一致，取决于你的CPU分配给程序的核心数，可以使用GOMAXPROCS环境变量或者动态的使用<code>runtime.GOMAXPROCS()</code>来调整。</p><p>一个常见的误解是，GOMAXPROCS表示用来运行goroutineCPU的数量，<code>runtime.GOMAXPROCS()</code>函数文档更让人困惑。</p><p>GOMAXPROCS变量<a href="https://golang.org/pkg/runtime/" target="_blank" rel="noopener">描述</a>更好的解释了关于OS线程问题。</p><p>你可以设置GOMAXPROCS的值大于CPU数量，在1.10版本已经不再对这个进行限制。最大值从256提升到了1024。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: X (1 on play.golang.org)</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())       <span class="comment">//prints: X (1 on play.golang.org)</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: 256</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写操作的顺序重排"><a href="#读写操作的顺序重排" class="headerlink" title="读写操作的顺序重排"></a>读写操作的顺序重排</h2><p>go也许会对某些操作进行重新排序，但它能保证在一个goroutine内的所有行为顺序是不变的。然而，它并不保证多goroutine的执行顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> u1()</span><br><span class="line">    <span class="keyword">go</span> u2()</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你多运行几次上面的代码，你可能会发现a和b变量有多个不同的组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3 </span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">0 </span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">0 </span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">1 </span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>最有趣的组合式是”02”。这表明b在a之前更新了。</p><p>如果你需要在多goroutine内放置读写顺序的变化，你将需要使用channel，或者使用”sync”包构建合适的结构体。</p><h2 id="优先调度"><a href="#优先调度" class="headerlink" title="优先调度"></a>优先调度</h2><p>有可能会出现这种情况，一个无耻的goroutine阻止其他goroutine运行。当你有一个不让调度器运行的for循环时，这就会发生。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环并不需要是空的。只要它包含了不会触发调度执行的代码，就会发生这种问题。</p><p>调度器会在GC、“go”声明、阻塞channel操作、阻塞系统调用和lock操作后运行。它也会在非内联函数调用后执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        fmt.Println(<span class="string">"not done!"</span>) <span class="comment">//not inlined</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想知道你在for循环中调用的函数是否是内联的，你可以在“go build”或“go run”时传入“-m” gc标志（如，<code>go build -gcflags -m</code>）。</p><p>也可以使用 runtime 包中的 Gosched() 来 手动启动调度器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的代码存在竞态条件(race condition)，这里仅仅为了演示这个坑。</p><h2 id="引入C模块和多行导入"><a href="#引入C模块和多行导入" class="headerlink" title="引入C模块和多行导入"></a>引入C模块和多行导入</h2><p>你需要引入C包来使用Cgo，你可以使用单行import或者使用import块:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"C"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cs := C.CString(<span class="string">"my go string"</span>)</span><br><span class="line">  C.free(unsafe.Pointer(cs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入C包不能和其他包一起：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"C"</span></span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cs := C.CString(<span class="string">"my go string"</span>)</span><br><span class="line">  C.free(unsafe.Pointer(cs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下<code>./main.go:13:2: could not determine kind of name for C.free</code>。</p><h2 id="import-C包和Cgo注释之间不要有空行"><a href="#import-C包和Cgo注释之间不要有空行" class="headerlink" title="import C包和Cgo注释之间不要有空行"></a>import C包和Cgo注释之间不要有空行</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cs := C.CString(<span class="string">"my go string"</span>)</span><br><span class="line">  C.free(unsafe.Pointer(cs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错<code>./main.go:15:2: could not determine kind of name for C.free</code>,确保不会有任何空行。</p><h2 id="使用可变参数不能调用C函数"><a href="#使用可变参数不能调用C函数" class="headerlink" title="使用可变参数不能调用C函数"></a>使用可变参数不能调用C函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cstr := C.CString(<span class="string">"go"</span>)</span><br><span class="line">  C.printf(<span class="string">"%s\n"</span>,cstr) <span class="comment">//not ok</span></span><br><span class="line">  C.free(unsafe.Pointer(cstr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下<code>./main.go:15:2: unexpected type: ...</code></p><p>您必须将可变参数C函数包装在具有已知参数数量的函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void out(char* in) &#123;</span></span><br><span class="line"><span class="comment">  printf("%s\n", in);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  cstr := C.CString(<span class="string">"go"</span>)</span><br><span class="line">  C.out(cstr) <span class="comment">//ok</span></span><br><span class="line">  C.free(unsafe.Pointer(cstr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div id="post-footer" class="post-footer main-content-wrap"><div class="post-footer-tags"><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small t-link" href="/source/all-tags/go/">go</a></div><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2020/12/16/golang小技巧/" data-tooltip="golang小技巧"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions"><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-google-plus"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-weibo"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/&amp;title=新手可能会犯的50个Golang错误"><i class="fa fa-qq"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-star"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-renren"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#"><i class="fa fa-list"></i></a></li></ul></div></div></article><footer id="footer" class="main-content-wrap"><span class="copyrights">Copyrights &copy; 2021 Roy. All Rights Reserved.</span></footer></div><div id="bottom-bar" class="post-bottom-bar" data-behavior="4"><div class="post-actions-wrap"><nav><ul class="post-actions post-action-nav"><li class="post-action"><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i> <span class="hide-xs hide-sm text-small icon-ml">上一篇</span></a></li><li class="post-action"><a class="post-action-btn btn btn--default tooltip--top" href="/2020/12/16/golang小技巧/" data-tooltip="golang小技巧"><span class="hide-xs hide-sm text-small icon-mr">下一篇</span> <i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions"><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-google-plus"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-weibo"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/&amp;title=新手可能会犯的50个Golang错误"><i class="fa fa-qq"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-star"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-renren"></i></a></li><li class="post-action"><a class="post-action-btn btn btn--default" href="#"><i class="fa fa-list"></i></a></li></ul></div></div><div id="share-options-bar" class="share-options-bar" data-behavior="4"><i id="btn-close-shareoptions" class="fa fa-close"></i><ul class="share-options"><li class="share-option"><a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-facebook-official"></i><span>分享到 Facebook</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-twitter"></i><span>分享到 Twitter</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-google-plus"></i><span>分享到 Google+</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-weibo"></i><span>分享到 Weibo</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/&amp;title=新手可能会犯的50个Golang错误"><i class="fa fa-qq"></i><span>分享到 QQ</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-star"></i><span>分享到 Qzone</span></a></li><li class="share-option"><a class="share-option-btn" target="new" href="http://widget.renren.com/dialog/share?resourceUrl=http://www.hi-roy.com/2020/12/16/新手可能会犯的50个Golang错误/"><i class="fa fa-renren"></i><span>分享到 Renren</span></a></li></ul></div></div><div id="about"><div id="about-card"><div id="about-btn-close"><i class="fa fa-remove"></i></div><img id="about-card-picture" src="/assets/images/my.jpg" alt="作者的图片"><h4 id="about-card-name">Roy</h4><div id="about-card-bio"><p>君以国士待我，我必以国士报君。</p></div><div id="about-card-job"><i class="fa fa-briefcase"></i><br><p>野生程序猿</p></div><div id="about-card-location"><i class="fa fa-map-marker"></i><br>China</div></div></div><div id="algolia-search-modal" class="modal-container"><div class="modal"><div class="modal-header"><span class="close-button"><i class="fa fa-close"></i></span> <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled"><span class="searchby-algolia-text text-color-light text-small">by</span> <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg"> </a><i class="search-icon fa fa-search"></i><form id="algolia-search-form"><input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search "></form></div><div class="modal-body"><div class="no-result text-color-light text-center">没有找到文章</div><div class="results"><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/02/12/Ubuntu下Gogant的简易破墙术/"><h3 class="media-heading">Ubuntu下Gogant的简易破墙术</h3></a><span class="media-meta"><span class="media-date text-small">2013年2月12日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/10/31/python常用第三方库-转载/"><h3 class="media-heading">Python常用第三方库(转载)</h3></a><span class="media-meta"><span class="media-date text-small">2013年10月31日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19安装ar8161网卡驱动/"><h3 class="media-heading">fedora19安装ar8161网卡驱动</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19源，rpmforge，fastestmirror/"><h3 class="media-heading">fedora19源，rpmforge，fastestmirror</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/python中如何自定义解析域名/"><h3 class="media-heading">python中如何自定义解析域名</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django版本更换/"><h3 class="media-heading">django版本更换</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/django-groundwork个人1-5-3修改版/"><h3 class="media-heading">django-groundwork个人1.5.3修改版</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/fedora19美化/"><h3 class="media-heading">fedora19美化</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/装饰器/"><h3 class="media-heading">装饰器</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div><div class="media"><div class="media-body"><a class="link-unstyled" href="http://www.hi-roy.com/2013/11/01/SVN常用操作/"><h3 class="media-heading">SVN常用操作</h3></a><span class="media-meta"><span class="media-date text-small">2013年11月1日</span></span><div class="media-content hide-xs font-merryweather"></div></div><div style="clear:both"></div><hr></div></div></div><div class="modal-footer"><p class="results-count text-medium" data-message-zero="没有找到文章" data-message-one="找到 1 篇文章" data-message-other="找到 {n} 篇文章">找到 234 篇文章</p></div></div></div><div id="cover" style="background-image:url(/assets/images/cover.jpg)"></div><script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script><script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><script>var algoliaClient=algoliasearch("51U8PIBLP6","16909d9ce1780cda71113841864e7aa8"),algoliaIndex=algoliaClient.initIndex("my-blog")</script></body></html>